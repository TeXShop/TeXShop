#!/usr/bin/env perl

#     Modified by Koch for internal use; only one change: ARGV[0] --> ARGV[3]
#     August 13, 2009

#     Copyright Â© 2009 by Nicola Vitacolonna. All rights reserved.
#
#     This program is free software: you can redistribute it and/or modify
#     it under the terms of the GNU General Public License as published by
#     the Free Software Foundation, either version 3 of the License, or
#     (at your option) any later version.
# 
#     This program is distributed in the hope that it will be useful,
#     but WITHOUT ANY WARRANTY; without even the implied warranty of
#     MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#     GNU General Public License for more details.
# 
#     You should have received a copy of the GNU General Public License
#     along with this program.  If not, see <http://www.gnu.org/licenses/>.

# Requires: mpost, pdflatex and, well, perl
use strict;
use warnings;

my $VERSION = '1.3.0';
my $RELEASE_DATE = '2009/06/01';
my $MPOST = 'mpost'; # MetaPost executable (specify full path if needed)
my $FIGEXT = '(\d+|mps|eps|ps)';  # Recognized filename extensions for figures
my $EXCLEXT = '(log|mpo|mpx)'; # Filename extensions to ignore
my $VERBOSE = 1; # Set to 1 and typeset for debugging
my $FIG = 'Fig.'; # Change or translate if you want
print "This is MetaPost Engine $VERSION ($RELEASE_DATE) by Nicola Vitacolonna\n";
print 'Filename: ' . $ARGV[3] . "\n" if $VERBOSE;
if ($ARGV[3] =~ /(\\|\%)/) {
	print "Sorry, your filename must not contain the character '$1'.";
	print " Please rename your file.\n";
	exit(1);
}
my ($suffix) = ($ARGV[3] =~ /((\.mp)|(\.mf))$/);
unless (defined $suffix) {
	print "Sorry, your source file must have a .mp or .mf suffix\n";
	exit(1);
}
my $mf = '';
if ($suffix eq '.mf') {
	$mf = '-mem=mfplain';
	$FIG = 'Charcode';
}
my ($jobname) = ($ARGV[3] =~ /^(.+)$suffix$/);
die "Please give a non-empty name to you file." unless (defined $jobname);
if ($jobname =~ /\s/) {
	print "WARNING: '$jobname$suffix' contain spaces,";
	print "	which *may* cause trouble.";
	print "	If compilation fails, try to rename '$jobname$suffix'";
	print "	without using spaces.\n";
}
my $mpost_cmd = "$MPOST $mf -jobname=\"$jobname\" -recorder \"$ARGV[3]\"";
print "Going to process $jobname$suffix...\n";
print "Command: $mpost_cmd\n" if $VERBOSE;
system($mpost_cmd); # Have fun!
my $exit_status = verifySystemCall($mpost_cmd);
print "$MPOST has exited with status code: $exit_status.\n" if $VERBOSE;
if ($mf and $exit_status == 1) { # mfplain.mem missing?
	print "\nMmh, probably mfplain.mem is missing.";
	print " To create it, open Terminal and execute 'mpost -ini mfplain dump',";
	print " then move the generated mfplain.mem into an appropriate place";
	print " (typically, /usr/local/texlive/<year>/texmf-var/web2c/metapost);";
	print " finally, execute 'sudo mktexlsr'.\n";
	exit($exit_status);
}
# Read output files
my @mpout = (); # Any output file
my @mps = ();   # Figures
my $fn;
open(FLS, $jobname . '.fls') or die "Gosh! Cannot open $jobname.fls :o";
while (my $l = <FLS>) {
	if ( ($fn) = ($l =~ /^\s*OUTPUT\s*(.+)$/) ) {
		chomp($fn);
		unless ($fn =~ /\.$EXCLEXT$/) {
			push(@mpout, $fn);
			push(@mps, $fn) if ($fn =~ /\.$FIGEXT$/);
		}
	}
}
close(FLS);

unless (@mpout) {
	print "No output file generated.";
	print " Is your source really supposed to generate any file?" if ($VERBOSE);
	print "\n";
	exit($exit_status);
}
my $nn = @mpout;
my $s = ($nn > 1) ? 's' :  '';
my $a = ($nn > 1) ? ''  : ' a';
print "$jobname$suffix has generated the following" .
	(($nn > 1) ? " $nn"  : '') . " output file$s: @mpout.\n" if ($VERBOSE);
unless (@mps) {
	print "$nn output file$s generated (not$a figure$s).";
	print " Is your source really supposed to generate any figure?" if $VERBOSE;
	print "\n";
	exit($exit_status);
}

# Get charcodes from log file.
# This works reliably as long as the log file does not contain other [<number>]
# expressions, e.g., printed by 'show' or 'message' commands.
my @fignum = ();
my @charname = ();
if (open(LOG, $jobname . '.log')) {
	print "Opened $jobname.log\n" if $VERBOSE;
	my @text = <LOG>;
	close(LOG);
	my $log = join('', @text);
	if ($mf) { # Using mfplain, try to parse character name
		while ($log =~ /(.*) \[(\d+)[^\]]*\]/g) {
			push(@charname, $1);
			push(@fignum, $2);
		}
		if (scalar(@mps) != scalar(@fignum)) {
			# Mmh, maybe no char names: revert to 'normal' parsing
			print "It seems that characters have no names. Parsing charcodes.\n" if $VERBOSE;
			@charname = (); @fignum = ();
			while ($log =~ /\[(\d+)[^\]]*\]/g) {
				push(@fignum, $1);
			}		
		}
	}
	else { # Plain MetaPost
		while ($log =~ /\[(\d+)[^\]]*\]/g) {
			push(@fignum, $1);
		}
	}
	print scalar(@fignum) . ' charcode' . (scalar(@fignum) > 1 ? 's' : '')
		. " found: @fignum.\n" if $VERBOSE;
	if ($mf and $VERBOSE) {
		print "Character names found: @charname.\n";
	}
}
else {
	print "Mmh, cannot open $jobname.log... Maybe something went wrong?\n";
}
if (scalar(@mps) != scalar(@fignum)) {
	print "WARNING: cannot reliably determine the figures' charcodes.";
	print " They will be ignored.\n";
	@fignum = ();
}
# Not to be overwritten by pdftex's log
if (-e "$jobname.log") {
	system("mv -f \"$jobname.log\" \"$jobname-mp.log\"");
	print "Renamed $jobname.log into $jobname-mp.log.\n";
}

my $hsize = 0;
my $vsize = 0;
my $f;
# Determine the largest horizontal/vertical size of a bounding box
foreach $f (@mps) {
	# Open the file and determine its bounding box
	unless (open(EPS, $f)) {
		print "Oh oh, cannot open $f. Skipping this file.\n";
		next;
	}
	my $line;
	while ($line = <EPS>) {
		# break the loop when the bounding box is found
		last if ($line =~ /BoundingBox/);
	}
	close(EPS);
	if (defined $line) {
		my ($llx, $lly, $urx, $ury) =
			($line =~ /BoundingBox:\s+(.+)\s+(.+)\s+(.+)\s+(.+)/);
		if ($hsize < $urx - $llx) { $hsize = $urx - $llx; }
		if ($vsize < $ury - $lly) { $vsize = $ury - $lly; }
		print "Bounding box of $f: $llx $lly $urx $ury\n" if $VERBOSE;
	}
	else {
		print "WARNING: it seems that $f does not have a bounding box.\n";
		print "Is $f really a Postscript file?\n" if $VERBOSE;
	}
}

# Set size to approximately A4 paper if no bounding box has been found
$hsize = 495 if ($hsize == 0);
$vsize = 742 if ($vsize == 0);
# Add some margins
$hsize += 100;
$vsize += 100;
# Enlarge if it's still too small
$hsize = 200 if ($hsize < 200);
$vsize = 200 if ($vsize < 200);
# Make pdf output using LaTeX
my $latex = '\documentclass{minimal}';
$latex .= '\usepackage[T1]{fontenc}';
#$latex .= '\usepackage[multidot,extendedchars]{grffile}';
$latex .= '\usepackage[paperwidth=' . $hsize . 'pt,paperheight=' . $vsize .  'pt,margin=1cm]{geometry}';
$latex .= '\usepackage[pdftex]{graphicx}' . '\DeclareGraphicsRule{*}{mps}{*}{}';
$latex .= '\begin{document}';
foreach $f (@mps) {
	my $title = $f;
	my ($pref,$suff) = ($f =~ /^(.+)(\.[^\.]+)$/);
	$suff = '' unless defined $suff; # No filename extension??
	if (@fignum) {
		$title .= ' [' . $FIG . ' ' . shift(@fignum);
		if ($mf) {
			my $cn = shift(@charname);
			$title .= ": $cn" if defined $cn;
		}
		$title .= ']';
	}
	$title =~ s/[\$\_\#\&\%]/\\$&/g; # Escape special characters with backslash
	$latex .= '\begin{center}\textbf{' . $title . '}\bigskip\par' .
	'\noindent\includegraphics{"' . $pref . '"' . $suff .
	'}\end{center}\newpage';
}
$latex .= '\end{document}\end' . "\n";

open(LATEX, "| pdflatex -no-shell-escape -jobname=\"$jobname\"")
  or die "Cannot execute pdflatex";
local $SIG{PIPE} = sub { die "pdflatex pipe broken" };
print LATEX $latex or die "Cannot write output pdf file";
close(LATEX) or die "Could not close pipe. Probably, pdflatex has (unexpectedly) produced an error.";

print "Generated pdf for " . scalar(@mps) . ' figure' .
	(scalar(@mps) > 1 ? 's' : '' ) . ": @mps\n";
exit($exit_status);

# verifySystemCall()
#
#  Usage    : my $exit_status = verifySystemCall($program_name);
#  Returns  : -1 if the program couldn't be run;
#             -2 if the program died (a msg is printed to stdout);
#             the exit code of the program, otherwise.
sub verifySystemCall {
	my $prog = shift;
	return -1 if ($? == -1);
    if ($? & 127) {
	    my $sig = ($? & 127);
	    my $core = ($? & 128) ? 'with' : 'without';
		print "$prog died with signal $sig, $core coredump.\n";
		return -2;
	}
	elsif (($? >> 8) != 0) {
		my $x = $? >> 8;
		return $x;
	}
	return 0;
}
