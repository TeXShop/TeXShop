#!/usr/bin/env perl

#     Copyright Â© 2009 by Nicola Vitacolonna. All rights reserved.
#
#     This program is free software: you can redistribute it and/or modify
#     it under the terms of the GNU General Public License as published by
#     the Free Software Foundation, either version 3 of the License, or
#     (at your option) any later version.
# 
#     This program is distributed in the hope that it will be useful,
#     but WITHOUT ANY WARRANTY; without even the implied warranty of
#     MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#     GNU General Public License for more details.
# 
#     You should have received a copy of the GNU General Public License
#     along with this program.  If not, see <http://www.gnu.org/licenses/>.

# Requires: mpost, ConTeXt and, well, Perl!
use strict;
use warnings;

my $VERSION = '1.3.0';
my $RELEASE_DATE = '2009/06/01';
my $MPOST = 'mpost'; # MetaPost executable (specify full path if needed)
my $FIGEXT = '(\d+|mps|eps|ps)';  # Recognized filename extensions for figures
my $EXCLEXT = '(log|mpo|mpx)'; # Filename extensions to ignore
my $VERBOSE = 0; # Set to 1 and typeset for debugging
my $FIG = 'Fig.'; # Change or translate if you want
print "This is MetaFun Engine $VERSION ($RELEASE_DATE) by Nicola Vitacolonna\n";
print 'Filename: ' . $ARGV[0] . "\n" if $VERBOSE;
if ($ARGV[0] =~ /(\\|\%)/) {
	print "Sorry, your filename must not contain the character '$1'.";
	print " Please rename your file.\n";
	exit(1);
}
my ($suffix) = ($ARGV[0] =~ /(\.mp)$/);
unless (defined $suffix) {
	print "Sorry, your source file must have a .mp suffix\n";
	exit(1);
}
my ($jobname) = ($ARGV[0] =~ /^(.+)$suffix$/);
die "Please give a non-empty name to you file." unless (defined $jobname);
if ($jobname =~ /\s/) {
	print "WARNING: '$jobname$suffix' contain spaces,";
	print "	which *may* cause trouble.";
	print "	If compilation fails, try to rename '$jobname$suffix'";
	print "	without using spaces.\n";
}
my $mpost_cmd = "$MPOST -mem=metafun -jobname=\"$jobname\" -recorder \"$ARGV[0]\"";
print "Going to process $jobname$suffix...\n";
print "Command: $mpost_cmd\n" if $VERBOSE;
# We do not use mptopdf here, because it does not work
# with 'filenametemplate'/'outputtemplate'
system($mpost_cmd); # Have fun
my $exit_status = verifySystemCall($mpost_cmd);
print "$MPOST has exited with status code: $exit_status.\n" if $VERBOSE;
# Read output files
my @mpout = (); # Any output file
my @mps = ();   # Figures
my $fn;
open(FLS, $jobname . '.fls') or die "Gosh! Cannot open $jobname.fls :o";
while (my $l = <FLS>) {
	if ( ($fn) = ($l =~ /^\s*OUTPUT\s*(.+)$/) ) {
		chomp($fn);
		unless ($fn =~ /\.$EXCLEXT$/) {
			push(@mpout, $fn);
			push(@mps, $fn) if ($fn =~ /\.$FIGEXT$/);
		}
	}
}
close(FLS);

unless (@mpout) {
	print "No output file generated.";
	print " Is your source really supposed to generate any file?" if ($VERBOSE);
	print "\n";
	exit($exit_status);
}
my $nn = @mpout;
my $s = ($nn > 1) ? 's' :  '';
my $a = ($nn > 1) ? ''  : ' a';
print "$jobname$suffix has generated the following" .
	(($nn > 1) ? " $nn"  : '') . " output file$s: @mpout.\n" if ($VERBOSE);
unless (@mps) {
	print "$nn output file$s generated (not$a figure$s).";
	print " Is your source really supposed to generate any figure?" if $VERBOSE;
	print "\n";
	exit($exit_status);
}

# Get charcodes from log file.
# This works reliably as long as the log file does not contain other [<number>]
# expressions, e.g., printed by 'show' or 'message' commands.
my @fignum = ();
if (open(LOG, $jobname . '.log')) {
	print "Opened $jobname.log\n" if $VERBOSE;
	my @text = <LOG>;
	close(LOG);
	my $log = join('', @text);
	while ($log =~ /\[(\d+)[^\]]*\]/g) {
		push(@fignum, $1);
	}
	print scalar(@fignum) . ' charcode' . (scalar(@fignum) > 1 ? 's' : '')
		. " found: @fignum.\n" if $VERBOSE;
}
else {
	print "Mmh, cannot open $jobname.log... Maybe something went wrong?\n";
}
if (scalar(@mps) != scalar(@fignum)) {
	print "WARNING: cannot reliably determine the figures' charcodes.";
	print " They will be ignored.\n";
	@fignum = ();
}
# Not to be overwritten by pdftex's log
if (-e "$jobname.log") {
	system("mv -f \"$jobname.log\" \"$jobname-mp.log\"");
	print "Renamed $jobname.log into $jobname-mp.log.\n";
}

my $hsize = 0;
my $vsize = 0;
my $f;
# Determine the largest horizontal/vertical size of a bounding box
foreach $f (@mps) {
	# Open the file and determine its bounding box
	unless (open(EPS, $f)) {
		print "Oh oh, cannot open $f. Skipping this file.\n";
		next;
	}
	my $line;
	while ($line = <EPS>) {
		# break the loop when the bounding box is found
		last if ($line =~ /BoundingBox/);
	}
	close(EPS);
	if (defined $line) {
		my ($llx, $lly, $urx, $ury) =
			($line =~ /BoundingBox:\s+(.+)\s+(.+)\s+(.+)\s+(.+)/);
		if ($hsize < $urx - $llx) { $hsize = $urx - $llx; }
		if ($vsize < $ury - $lly) { $vsize = $ury - $lly; }
		print "Bounding box of $f: $llx $lly $urx $ury\n" if $VERBOSE;
	}
	else {
		print "WARNING: it seems that $f does not have a bounding box.\n";
		print "Is $f really a Postscript file?\n" if $VERBOSE;
	}
}

# Set size to approximately A4 paper if no bounding box has been found
$hsize = 495 if ($hsize == 0);
$vsize = 742 if ($vsize == 0);
# Add some margins
$hsize += 100;
$vsize += 100;
# Enlarge if it's still too small
$hsize = 200 if ($hsize < 200);
$vsize = 200 if ($vsize < 200);

# Convert figures to pdf using mptopdf
my @pdf = ();
foreach $f (@mps) {
	# Integrity check on suffix (mptopdf only recognizes .mps and .'number')
	my ($pref,$suff) = ($f =~ /^(.+)(\.[^\.]+)$/);
	unless (defined $suff and $suff =~ /^(\.mps)|(\.\d+)$/) {
		print "WARNING: mptopdf only accepts .mps and .<num> suffixes. ";
		print "Appended .mps suffix to $f.\n";
		# Append .mps suffix to filename
		my $newname = $f . '.mps';
		system("mv -f $f $newname");
		$f = $newname;
	}
	my $mptopdf_output = `mptopdf $f`;
	my ($pdfname) = ($mptopdf_output =~ /converted to (.+\.pdf)/);
	unless (defined $pdfname) {
		print "WARNING: cannot get pdf name for $f from mptopdf. ";
		print "Skipping this file.\n";
		next;
	}
	push(@pdf,$pdfname);
	print "Generated PDF figure: $pdfname\n";
}

# Make pdf output using ConTeXt
my $context = '\setupoutput[pdftex]';
$context .= '\definepapersize[MetaFun!][width=' . $hsize . 'pt,height=' . $vsize .  'pt]';
$context .= '\setuppapersize[MetaFun!][MetaFun!]';
$context .= '\setupcolors[state=start]';
$context .= '\setuppagenumbering[state=stop]';
#$context .= '\showframe';
$context .= '\starttext';
foreach $f (@pdf) {
	my $title = $f;
	if (@fignum) {
		$title .= ' [' . $FIG . ' ' . shift(@fignum) . ']';
	}
	$title =~ s/[\$\_\#\&\%]/\\$&/g; # Escape special characters with backslash
	$context .= '{\bf ' . $title . '}\blank[2*medium]' .
	'\midaligned{\externalfigure[' . $f . ']}\page' . "\n";
}
$context .= '\stoptext\end' . "\n";
# I do not call texexec here, because I have found no way to pipe code into it
open(TEXEXEC, "| pdftex -progname=context -fmt=cont-en -translate-file=natural.tcx --8bit -jobname=\"$jobname\" -no-shell-escape")
  or die "Cannot execute pdftex";
local $SIG{PIPE} = sub { die "pdftex pipe broken" };
print TEXEXEC $context or die "Cannot write output pdf file";
close(TEXEXEC) or die "Could not close pipe. Probably, pdftex has (unexpectedly) produced an error.";

print "Generated pdf for " . scalar(@pdf) . ' figure' .
	(scalar(@pdf) > 1 ? 's' : '' ) . ": @pdf\n";
exit($exit_status);

# verifySystemCall()
#
#  Usage    : my $exit_status = verifySystemCall($program_name);
#  Returns  : -1 if the program couldn't be run;
#             -2 if the program died (a msg is printed to stdout);
#             the exit code of the program, otherwise.
sub verifySystemCall {
	my $prog = shift;
	return -1 if ($? == -1);
    if ($? & 127) {
	    my $sig = ($? & 127);
	    my $core = ($? & 128) ? 'with' : 'without';
		print "$prog died with signal $sig, $core coredump.\n";
		return -2;
	}
	elsif (($? >> 8) != 0) {
		my $x = $? >> 8;
		return $x;
	}
	return 0;
}
