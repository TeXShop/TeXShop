<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE plist PUBLIC "-//Apple//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd">
<plist version="1.0">
<dict>
	<key>content</key>
	<string></string>
	<key>key</key>
	<string></string>
	<key>name</key>
	<string>ROOT</string>
	<key>submenu</key>
	<array>
		<dict>
			<key>content</key>
			<string>--Applescript direct

-- Script that improves on the TeXShop default macro called "Program",
-- i.e., %!TEX TS-program =  #INS#
-- by letting the user choose which engine she/he wants to use,
-- deleting the first old (if any) engine command,
-- inserting the command at the beginning of the document, and
-- restoring the original selection.
-- It assumes that engines are installed in ~/Library/TeXShop/Engines/
-- Ramon Figueroa-Centeno (March 10, 2009)
-- http://www2.hawaii.edu/~ramonf

-- History:
-- 1.1: March 19, 2008
-- Added missing default engines: metapost, metafont, and context.
-- 1.2: March 28, 2009
-- Added code to respect first lines that start with "%&amp;"


-- If you wish you can change this so that your favorite engine is the default choice
property default_engine : "pdflatexmk"

tell application "TeXShop"
	
	-- Get a sorted list of the default and installed TeXShop engines
	tell me
		-- Shell script to get the names of the engines installed in ~/Library/TeXShop/Engines/
		set command to "ls ~/Library/TeXShop/Engines/ | egrep -e '^.*\\.engine$' | sed 's/\\.engine//'"
		set engines to paragraphs of (do shell script command)
		set engines to sort({"tex", "latex", "pdflatex", "pdftex", "personaltex", "personallatex", "metapost", "metafont", "context"} &amp; engines)
	end tell
	
	-- Figure out which is the index of the "default_engine" in the "engines" list
	if default_engine is in engines then
		repeat with i from 1 to count of engines
			if item i of engines is default_engine then
				exit repeat
			end if
		end repeat
	else
		-- if the "default_engine" is not among the engines then choose the alphabetically first available engine name
		set i to 1
	end if
	
	set the engine to choose from list engines with prompt "Pick an engine:" default items item i of engines OK button name "OK" cancel button name "Cancel" without multiple selections allowed and empty selection allowed
	if the result is false then
		return
	end if
	
	-- The linefeed character
	set linefeed to ASCII character 10
	
	-- The whole text of the document
	set whole_document to (the text of the front document) as string
	
	-- The offset of the selection
	set selection_offset to offset of the selection of the front document
	
	-- The length of the selection
	set selection_length to length of the selection of the front document
	
	-- Find and delete a previous engine specification
	-- (it will not handle more than one specification)
	set searchString1 to "%!TEX TS-program ="
	set search1 to (search for searchString1 starting from 0) of front document
	set searchString2 to "% !TEX TS-program ="
	set search2 to (search for searchString2 starting from 0) of front document
	
	if search1 * search2 &gt; 0 then
		if search1 &lt; search2 then
			set first_occurrence to search1
		else
			set first_occurrence to search2
		end if
	else if search1 &gt; 0 then
		set first_occurrence to search1
	else
		set first_occurrence to search2
	end if
	if first_occurrence &gt; 0 then
		set offset of selection of front document to (first_occurrence - 1)
		
		-- Get the offset of the line feed (or eof) ending the line containing "%!TEX TS-program ="
		-- (here we use a "try" statement to avoid  needing to have a saved file
		-- from which we could get the "eof") 
		set i to first_occurrence
		set end_of_file to false
		set char to character i of whole_document
		repeat while char is not in {linefeed, return}
			set i to i + 1
			try
				set char to character i of whole_document
			on error
				set end_of_file to true
				exit repeat
			end try
		end repeat
		
		-- Detect if the line starts with "% !TEX TS-program =" and it is not the last line,
		-- if so we will delete not only "% !TEX TS-program =..." but the whole line
		if ((first_occurrence = 1) or (character (first_occurrence - 1) of whole_document is in {linefeed, return})) and not end_of_file then
			set i to i + 1
		end if
		
		set length of selection of front document to (i - first_occurrence)
		-- Delete the line
		set the content of the selection of the front document to ""
		
		-- We will try to restore the selection the user had before invoking this script
		-- so we compute what the new selection_offset should be.
		if (selection_offset ≥ first_occurrence - 1) and (selection_offset &lt; i - 1) then
			set selection_offset to first_occurrence - 1
			set selection_length to 0
		else if selection_offset ≥ i - 1 then
			set selection_offset to selection_offset - (i - first_occurrence)
		end if
	end if
	
	set program to "% !TEX TS-program = " &amp; engine &amp; linefeed
	set selection_offset to selection_offset + (count of program)
	
	-- If the first line starts with "%&amp;" set the insertion offset
	-- to the beginning of the second line.
	try
		set first_line to paragraph 1 of the text of the front document as string
		if the first_line starts with "%&amp;" then
			set insertion_offset to count the characters of the first_line
			try
				get paragraph 2 of the text of the front document
			on error -- There is only one line?
				set selection_offset to selection_offset + 1
				set program to linefeed &amp; program
			end try
		else
			set insertion_offset to 0
		end if
	on error -- The document was empty?
		set insertion_offset to 0
	end try
	
	-- Insert Engine
	set offset of the selection of the front document to insertion_offset
	set length of the selection of the front document to 0
	set content of the selection of the front document to program
	
	-- Restore the offset of the selection
	set offset of the selection of the front document to selection_offset
	
	-- Restore the length of the selection
	set length of the selection of the front document to selection_length
	
end tell

(* 
http://www.macosxhints.com/article.php?story=20040513173003941
Sort lists in AppleScript using the Unix sort command
Mon, May 17 '04 at 09:13AM • from: erickaterman *)
on sort(the_list)
	set old_delims to AppleScript's text item delimiters
	set AppleScript's text item delimiters to {ASCII character 10} -- always a linefeed
	set list_string to (the_list as string)
	set new_string to do shell script "echo " &amp; quoted form of list_string &amp; " | sort -f -u"
	set new_list to (paragraphs of new_string)
	set AppleScript's text item delimiters to old_delims
	return new_list
end sort</string>
			<key>key</key>
			<string></string>
			<key>name</key>
			<string>Program</string>
		</dict>
		<dict>
			<key>content</key>
			<string>--Applescript direct

-- Script that improves on the TeXShop default macro called "Encoding",
-- i.e., %!TEX encoding =  #INS#
-- by letting the user choose which encoding she/he wants to use,
-- deleting the first old (if any) encoding command,
-- inserting the command at the beginning of the document, and
-- restoring the original selection.
-- Ramon Figueroa-Centeno (March 10, 2009)
-- http://www2.hawaii.edu/~ramonf

-- History: 
-- 1.1: March 18, 2009
-- Added missing encodings.
-- 1.2: March 28, 2009
-- Added code to respect first lines that start with "%&amp;"

-- If you wish you can change this so that your favorite encoding is the default choice
property default_encoding : "MacOSRoman"

tell application "TeXShop"
	
	-- Get a sorted list of the TeXShop encodings
	tell me
		set encodings to {"MacOSRoman", "IsoLatin", "IsoLatin2", "IsoLatin5", "IsoLatin9", "IsoLatinGreek", "Mac Central European Roman", "MacJapanese", "DOSJapanese", "SJIS_X0213", "EUC_JP", "JISJapanese", "MacKorean", "UTF-8 Unicode", "Standard Unicode", "Mac Cyrillic", "DOS Cyrillic", "DOS Russian", "Windows Latin 1", "WindowsCentralEurRoman", "Windows Cyrillic", "KOI8_R", "Mac Chinese Traditional", "Mac Chinese Simplified", "DOS Chinese Traditional", "DOS Chinese Simplified", "GBK", "GB 2312", "GB 18030"}
		set encodings to sort(encodings)
	end tell
	
	-- Figure out which is the index of the "default_encoding" in the "encodings" list
	if default_encoding is in encodings then
		repeat with i from 1 to count of encodings
			if item i of encodings is default_encoding then
				exit repeat
			end if
		end repeat
	else
		-- if the "default_encoding" is not among the encodings then choose the alphabetically first available encoding name
		set i to 1
	end if
	
	set the encoding to choose from list encodings with prompt "Pick an encoding:" default items item i of encodings OK button name "OK" cancel button name "Cancel" without multiple selections allowed and empty selection allowed
	if the result is false then
		return
	end if
	
	-- The linefeed character
	set linefeed to ASCII character 10
	
	-- The whole text of the document
	set whole_document to (the text of the front document) as string
	
	-- The offset of the selection
	set selection_offset to offset of the selection of the front document
	
	-- The length of the selection
	set selection_length to length of the selection of the front document
	
	-- Find and delete a previous encoding specification
	-- (it will not handle more than one specification)
	set searchString1 to "%!TEX encoding ="
	set search1 to (search for searchString1 starting from 0) of front document
	set searchString2 to "% !TEX encoding ="
	set search2 to (search for searchString2 starting from 0) of front document
	
	if search1 * search2 &gt; 0 then
		if search1 &lt; search2 then
			set first_occurrence to search1
		else
			set first_occurrence to search2
		end if
	else if search1 &gt; 0 then
		set first_occurrence to search1
	else
		set first_occurrence to search2
	end if
	if first_occurrence &gt; 0 then
		set offset of selection of front document to (first_occurrence - 1)
		
		-- Get the offset of the line feed (or eof) ending the line containing "% !TEX encoding ="
		-- (here we use a "try" statement to avoid  needing to have a saved file
		-- from which we could get the "eof") 
		set i to first_occurrence
		set end_of_file to false
		set char to character i of whole_document
		repeat while char is not in {linefeed, return}
			set i to i + 1
			try
				set char to character i of whole_document
			on error
				set end_of_file to true
				exit repeat
			end try
		end repeat
		
		-- Detect if the line starts with "% !TEX encoding =" and it is not the last line,
		-- if so we will delete not only "% !TEX encoding =..." but the whole line
		if ((first_occurrence = 1) or (character (first_occurrence - 1) of whole_document is in {linefeed, return})) and not end_of_file then
			set i to i + 1
		end if
		
		set length of selection of front document to (i - first_occurrence)
		-- Delete the line
		set the content of the selection of the front document to ""
		
		-- We will try to restore the selection the user had before invoking this script
		-- so we compute what the new selection_offset should be.
		if (selection_offset ≥ first_occurrence - 1) and (selection_offset &lt; i - 1) then
			set selection_offset to first_occurrence - 1
			set selection_length to 0
		else if selection_offset ≥ i - 1 then
			set selection_offset to selection_offset - (i - first_occurrence)
		end if
	end if
	
	set program to "% !TEX encoding = " &amp; encoding &amp; linefeed
	set selection_offset to selection_offset + (count of program)
	
	-- If the first line starts with "%&amp;" set the insertion offset
	-- to the beginning of the second line.
	try
		set first_line to paragraph 1 of the text of the front document as string
		if the first_line starts with "%&amp;" then
			set insertion_offset to count the characters of the first_line
			try
				get paragraph 2 of the text of the front document
			on error -- There is only one line?
				set selection_offset to selection_offset + 1
				set program to linefeed &amp; program
			end try
		else
			set insertion_offset to 0
		end if
	on error -- The document was empty?
		set insertion_offset to 0
	end try
	
	-- Insert Encoding
	set offset of the selection of the front document to insertion_offset
	set length of the selection of the front document to 0
	set content of the selection of the front document to program
	
	-- Restore the offset of the selection
	set offset of the selection of the front document to selection_offset
	
	-- Restore the length of the selection
	set length of the selection of the front document to selection_length
	
end tell

(* 
http://www.macosxhints.com/article.php?story=20040513173003941
Sort lists in AppleScript using the Unix sort command
Mon, May 17 '04 at 09:13AM • from: erickaterman *)
on sort(the_list)
	set old_delims to AppleScript's text item delimiters
	set AppleScript's text item delimiters to {ASCII character 10} -- always a linefeed
	set list_string to (the_list as string)
	set new_string to do shell script "echo " &amp; quoted form of list_string &amp; " | sort -f -u"
	set new_list to (paragraphs of new_string)
	set AppleScript's text item delimiters to old_delims
	return new_list
end sort</string>
			<key>key</key>
			<string></string>
			<key>name</key>
			<string>Encoding</string>
		</dict>
		<dict>
			<key>content</key>
			<string>--Applescript direct

-- Script that improves on the TeXShop default macro called "Root",
-- i.e., %!TEX root =  #INS#
-- by letting the user choose which root document she/he wants to use
-- (as a relative or absolute path),
-- deleting the first old (if any) root command,
-- inserting the command at the beginning of the document, and
-- restoring the original selection.
-- Ramon Figueroa-Centeno (March 10, 2009)
-- http://www2.hawaii.edu/~ramonf

-- History: 
-- 1.1: March 18, 2009
-- Added code to respect first lines that start with "%&amp;"


-- What is the default choice: relative or not relative (i.e. absolute)
property relative : true

tell application "TeXShop"
	
	try
		path of the front document
		set TeX_path to the result
	on error -- there is no front document  or it has not ever been saved
		beep
		display dialog "there is no front document" &amp; return &amp; "or it has not been saved ever!" buttons {"Ok"} default button "Ok" with icon caution giving up after 5
		return
	end try
	
	set TeX_path to do shell script "dirname " &amp; quoted form of TeX_path
	
	-- Get the absolute path to the Root document
	try
		set Root_abs_path to POSIX path of (choose file with prompt "Pick the Root document:")
	on error
		return
	end try
	
	-- Use perl to convert the absolute path to the Root document 
	-- to a relative path to it.
	set command to "perl -e 'use File::Spec; "
	set command to command &amp; "$rel_path = File::Spec-&gt;abs2rel"
	set command to command &amp; "( \"" &amp; Root_abs_path &amp; "\","
	set command to command &amp; "\"" &amp; TeX_path &amp; "\" ) ; "
	set command to command &amp; "print $rel_path'"
	tell me to set Root_rel_path to do shell script command
	
	if relative then
		set i to 1
	else
		set i to 2
	end if
	
	set roots to {Root_rel_path, Root_abs_path}
	set the root to choose from list roots with prompt "Choose between a relative and absolute path:" default items item i of roots OK button name "OK" cancel button name "Cancel" without multiple selections allowed and empty selection allowed
	if the result is false then
		return
	end if
	
	-- The linefeed character
	set linefeed to ASCII character 10
	
	-- The whole text of the document
	set whole_document to (the text of the front document) as string
	
	-- The offset of the selection
	set selection_offset to offset of the selection of the front document
	
	-- The length of the selection
	set selection_length to length of the selection of the front document
	
	-- Find and delete a previous encoding specification
	-- (it will not handle more than one specification)
	set searchString1 to "%!TEX root ="
	set search1 to (search for searchString1 starting from 0) of front document
	set searchString2 to "% !TEX root ="
	set search2 to (search for searchString2 starting from 0) of front document
	
	if search1 * search2 &gt; 0 then
		if search1 &lt; search2 then
			set first_occurrence to search1
		else
			set first_occurrence to search2
		end if
	else if search1 &gt; 0 then
		set first_occurrence to search1
	else
		set first_occurrence to search2
	end if
	
	if first_occurrence &gt; 0 then
		set offset of selection of front document to (first_occurrence - 1)
		
		-- Get the offset of the line feed (or eof) ending the line containing "%!TEX root ="
		-- (here we use a "try" statement to avoid  needing to have a saved file
		-- from which we could get the "eof") 
		set i to first_occurrence
		set end_of_file to false
		set char to character i of whole_document
		repeat while char is not in {linefeed, return}
			set i to i + 1
			try
				set char to character i of whole_document
			on error
				set end_of_file to true
				exit repeat
			end try
		end repeat
		
		-- Detect if the line starts with "% !TEX root =" and it is not the last line,
		-- if so we will delete not only "% !TEX root =..." but the whole line
		if ((first_occurrence = 1) or (character (first_occurrence - 1) of whole_document is in {linefeed, return})) and not end_of_file then
			set i to i + 1
		end if
		
		set length of selection of front document to (i - first_occurrence)
		-- Delete the line
		set the content of the selection of the front document to ""
		
		-- We restore the selection the user had before invoking this script
		-- so we compute what the new selection_offset should be.
		if (selection_offset ≥ first_occurrence - 1) and (selection_offset &lt; i - 1) then
			set selection_offset to first_occurrence - 1
			set selection_length to 0
		else if selection_offset ≥ i - 1 then
			set selection_offset to selection_offset - (i - first_occurrence)
		end if
	end if
	
	set program to "% !TEX root = " &amp; root &amp; linefeed
	set selection_offset to selection_offset + (count of program)
	
	-- If the first line starts with "%&amp;" set the insertion offset
	-- to the beginning of the second line.
	try
		set first_line to paragraph 1 of the text of the front document as string
		if the first_line starts with "%&amp;" then
			set insertion_offset to count the characters of the first_line
			try
				get paragraph 2 of the text of the front document
			on error -- There is only one line?
				set selection_offset to selection_offset + 1
				set program to linefeed &amp; program
			end try
		else
			set insertion_offset to 0
		end if
	on error -- The document was empty?
		set insertion_offset to 0
	end try
	
	-- Insert Root
	set offset of the selection of the front document to insertion_offset
	set length of the selection of the front document to 0
	set content of the selection of the front document to program
	
	-- Restore the offset of the selection
	set offset of the selection of the front document to selection_offset
	
	-- Restore the length of the selection
	set length of the selection of the front document to selection_length
end tell</string>
			<key>key</key>
			<string></string>
			<key>name</key>
			<string>Root</string>
		</dict>
		<dict>
			<key>content</key>
			<string>% !TEX root =  #INS#</string>
			<key>key</key>
			<string></string>
			<key>name</key>
			<string>Root (Short Version)</string>
		</dict>
		<dict>
			<key>content</key>
			<string></string>
			<key>key</key>
			<string></string>
			<key>name</key>
			<string>Separator</string>
		</dict>
		<dict>
			<key>content</key>
			<string>--Applescript direct
-- Script to insert a begin/end block
-- Ramon Figueroa-Centeno March 10, 2009

tell application "TeXShop"
	
	-- The linefeed character.
	set linefeed to ASCII character 10
	
	set TeX_delimiters to {linefeed, return, tab} &amp; characters of ¬
		" {}[](),:;.\\|/?!&lt;&gt;`'\"@#$%^~&amp;-+=" as list
	
	set the front_document to the front document
	-- set the front_document to document #DOCUMENTNAME#
	
	-- The whole text of the document
	set whole_document to (the text of the front_document) as string
	
	-- The offset of the selection
	set selection_offset to offset of the selection of the front_document
	
	repeat until (selection_offset = 0) or (character selection_offset of ¬
		the whole_document is in TeX_delimiters)
		set selection_offset to selection_offset - 1
	end repeat
	set the offset of the selection of the front_document to selection_offset
	
	set selection_length to 0
	
	try
		set next_character to character (selection_offset + selection_length + 1) of ¬
			the whole_document
		repeat until (next_character is in TeX_delimiters)
			set selection_length to selection_length + 1
			try
				set next_character to character (selection_offset + selection_length + 1) of ¬
					the whole_document
			on error
				-- reached the end of the document
				exit repeat
			end try
		end repeat
	end try
	set the length of the selection of the front_document to selection_length
	
	-- The selection is empty, so stop
	if selection_length = 0 then
		beep
		return
	end if
	
	set environment_name to the content of the selection of the front_document
	set begin_environment to "\\begin{" &amp; environment_name &amp; "}"
	set end_environment to "\\end{" &amp; environment_name &amp; "}"
	set environment to begin_environment &amp; linefeed &amp; " " &amp; linefeed &amp; end_environment
	set insertion_point to (count of begin_environment) + selection_offset + 3
	
	-- determine if we are the beginning of a line
	set at_the_beginning to ((selection_offset = 0) or (character selection_offset of ¬
		the whole_document is in {linefeed, return}))
	
	-- determine if we are at the end of a line
	-- (since we do not know if we are at the end of the document
	-- we use a "try" to avoid having to count the characters of the document)
	set at_the_end to false
	try
		if character (selection_offset + selection_length + 1) of ¬
			the whole_document is in {linefeed, return} then
			set at_the_end to true
		end if
	on error
		set at_the_end to true
	end try
	
	if at_the_beginning and at_the_end then
		-- say "at the beginning and the end"
		set the content of the selection of the front_document to ¬
			environment
		set the offset of the selection of the front_document to ¬
			insertion_point - 1
	else if at_the_beginning then
		-- say "at the beginning"
		set the content of the selection of the front_document to ¬
			environment &amp; linefeed
		set the offset of the selection of the front_document to ¬
			insertion_point
	else if at_the_end then
		-- say "at the end"
		set the content of the selection of the front_document to ¬
			linefeed &amp; environment
		set the offset of the selection of the front_document to ¬
			insertion_point
	else
		-- say "at the middle"
		set the content of the selection of the front_document to ¬
			linefeed &amp; environment &amp; linefeed
		set the offset of the selection of the front_document to ¬
			insertion_point
	end if
end tell</string>
			<key>key</key>
			<string></string>
			<key>name</key>
			<string>Insert Begin/End</string>
		</dict>
		<dict>
			<key>content</key>
			<string>--Applescript direct
-- Script to close a begin/end block
-- Ramon Figueroa-Centeno March 10, 2009

tell application "TeXShop"
	
	-- The linefeed character.
	set linefeed to ASCII character 10
	
	set the front_document to the front document
	-- set the front_document to document #DOCUMENTNAME#
	
	-- The whole text of the document
	set whole_document to (the text of the front_document) as string
	
	-- If the front document is not saved dump its 
	-- content to a temporary file and use that
	if the front_document is modified then
		tell me
			set texpath to do shell script "mktemp /tmp/XXXXXXXX"
			set TMP to POSIX file texpath
			open for access TMP with write permission
			write whole_document to TMP
			close access TMP
		end tell
	else
		set texpath to the path of the front_document
		-- set texpath to the #FILEPATH#
	end if
	
	-- The offset of the selection
	set selection_offset to offset of the selection of the front_document
	
	-- Move the insertion point to the beginning of the selected word.
	-- Unless we are at the end of a line.
	-- If one removes " " (space) from the list  the insertion point moves to the
	-- beginning of the line. 
	
	try
		if the character (selection_offset + 1) of the whole_document is not in {linefeed, return} then
			repeat until (selection_offset = 0) or ¬
				(character selection_offset of the whole_document is in {linefeed, return, " "})
				set selection_offset to selection_offset - 1
			end repeat
			set the offset of the selection of the front_document to selection_offset
		end if
	on error
		-- It appears that we are at the end of the file!
	end try
	
	-- Stop if the insertion point is at the beginning of the document
	if selection_offset = 0 then
		return
	end if
	
	-- The document up to the selection
	set partial_document to ¬
		(characters 1 thru (selection_offset) of the whole_document) as string
	
	-- Let selection_line_number be the number of the line of the start of the current selection
	set selection_line_number to count paragraphs of the partial_document
	
	set report to "selection line: " &amp; selection_line_number &amp; return
	
	-- The total number of lines
	set total_lines to count paragraphs of the whole_document
	
	set report to report &amp; "total # of lines: " &amp; total_lines &amp; return
	
	-- The "command" is a shell script that does this: 
	-- delete all comments:
	-- sed 's/%.*$//'  (or sed '/%.*$/ s/%.*$//' for speed)
	set command to " | sed '/%.*$/ s/%.*$//'"
	-- replace all "\" with a linefeed character:
	-- tr -s "\\" "\n" 
	set command to command &amp; " | tr -s \"\\\\\" \"\\n\""
	-- delete everything after and including the first "}":
	-- sed 's/}.*//'  (or sed '/}.*/ s/}.*//'  for speed)
	set command to command &amp; " | sed '/}.*/ s/}.*//'"
	-- keep only the lines that start with "begin{" or "end{":
	-- egrep -e '^begin{|^end{' 
	set command to command &amp; " | egrep -e '^begin{|^end{'"
	-- replace all "{" by spaces:
	-- tr -s "{" " " 
	set command to command &amp; " | tr -s \"{\" \" \""
	
	-- shell command to convert returns (\r) to line feeds (\n)
	set mac2unix to "tr \\\\r \\\\n"
	
	--select insertion point before the selection
	set length of the selection of the front_document to 0
	
	-- Divide the line of the selection into two chunks
	-- one before and another after the beginning of the selection
	try
		set firstLineChunk to the last paragraph of the partial_document
	on error
		set firstLineChunk to ""
	end try
	set the_line to paragraph selection_line_number of the whole_document
	try
		set secondLineChunk to characters ((count of the firstLineChunk) + 1) ¬
			thru (count of the_line) of the_line as string
	on error
		set secondLineChunk to ""
	end try
	
	-- Set list_1 to a list that contains strings, each with two words
	-- the first word is "begin" or "end" and the second is the 
	-- name of the corresponding environment
	
	set list_1 to {}
	
	set command_2 to ¬
		mac2unix &amp; " &lt; " &amp; (quoted form of texpath) ¬
		&amp; " | head -n " &amp; (selection_line_number - 1) &amp; command
	tell me to set parsed to do shell script command_2
	if parsed is not "" then
		set list_1 to list_1 &amp; (paragraphs of parsed)
	end if
	
	set command_2 to ¬
		"echo " &amp; (quoted form of firstLineChunk) &amp; " | " &amp; mac2unix &amp; command
	tell me to set parsed to do shell script command_2
	if parsed is not "" then
		set list_1 to list_1 &amp; (paragraphs of parsed)
	end if
	
	-- If list_1 is empty then there is no environment to close
	if (count of list_1) = 0 then
		beep
		say "There are no environments before this point."
		--display dialog "There are no environments before this point." buttons {"OK"} default button 1 with icon caution
		return
	end if
	
	set flips to 0
	repeat with i from (count list_1) to 1 by -1
		if word 1 of item i of list_1 is "end" then
			set flips to flips + 1
		else
			set flips to flips - 1
		end if
		
		if flips = -1 -- The next line does this:			-- The next line does this:
			-- but handles starred commands correctly
			tell me to  to set environment_name to do shell script ¬
				"echo \"" &amp; (item i of list_1) &amp; "\" |  sed '/.* / s/.* //'"
			exit repeat
		end if
		
	end repeat
	if not (flips = -1) then
		beep
		say "I did not find an open environment!"
		--display dialog "I did not find an open environment!" buttons {"OK"} default button 1 with icon caution
		return
	end if
	
	-- Now we check to see if the environment we are in is already closed
	
	set list_2 to {}
	
	set command_2 to ¬
		"echo " &amp; (quoted form of secondLineChunk) &amp; " | " &amp; mac2unix &amp; command
	tell me to set parsed to do shell script command_2
	if parsed is not "" then
		set list_2 to paragraphs of parsed
	end if
	
	set command_2 to ¬
		mac2unix &amp; " &lt; " &amp; (quoted form of texpath) ¬
		&amp; " | tail -n +" &amp; (selection_line_number + 1) &amp; command
	tell me to set parsed to do shell script command_2
	if parsed is not "" then
		set list_2 to list_2 &amp; (paragraphs of parsed)
	end if
	
	set close_environment to true
	
	if (count of list_2) &gt; 0 then
		set flips to 0
		repeat with i from 1 to (count list_2)
			if word 1 of item i of list_2 is "begin" then
				set flips to flips + 1
			else
				set flips to flips - 1
			end if
			if flips = -1 then
				-- The next line does this:
				-- set environment_name_2 to word 2 of item i of list_2
				-- but handles starred commands correctly
				set environment_name_2 to do shell script ¬
					"echo \"" &amp; (item i of list_2) &amp; "\" |  sed '/.* / s/.* //'"
				if environment_name_2 = environment_name then
					beep
					activate
					display dialog "The environment \"" &amp; environment_name ¬
						&amp; "\"" &amp; return &amp; "you are working on is already closed." &amp; return ¬
						&amp; "Do you still want to close it?" buttons {"No", "Yes"} ¬
						default button "No" with icon note
					set close_environment to (button returned of the result is not "No")
				end if
				exit repeat
			end if
		end repeat
	end if
	
	-- Close the environment
	if close_environment then
		if the_line = "" then
			set the content of the selection of the front_document to ¬
				"\\end{" &amp; environment_name &amp; "}"
		else
			-- If we are at the beginning of a line then close the environment
			-- and then enter a return. Otherwise, enter a return before doing so.
			if (character selection_offset of the whole_document is in {linefeed, return}) then
				set the content of the selection of the front_document to ¬
					"\\end{" &amp; environment_name &amp; "}" &amp; linefeed
			else
				set the content of the selection of the front_document to ¬
					linefeed &amp; "\\end{" &amp; environment_name &amp; "}" &amp; linefeed
			end if
		end if
	end if
	
	-- If a temporary file was created delete it.
	try
		do shell script "rm " &amp; POSIX path of TMP
	end try
	
end tell</string>
			<key>key</key>
			<string></string>
			<key>name</key>
			<string>Close Begin/End</string>
		</dict>
		<dict>
			<key>content</key>
			<string>--Applescript

-- "INSERT REFERENCE"
-- This script searches through the current file (or within every file in the current folder) for \label{...} commands, then pops up a list for you to choose from which you may insert one.
--The inserted reference label is wrapped in a (optional) customisable LaTeX command.
-- It will cut down the list to include only those entries that contain the current selection. So if you type "sec" and select it, then run this script, you will get a choice of only, e.g., "sec:intro","sec:conc","fig:secunia", but not other labels in your document e.g., "cha:monkey","equ:maxwell",etc. 

-- v2004-08-24


-- CUSTOMISE TO YOUR LIKING:

property ref_command : "ref" -- or "vref" or "fref" etc... N.B. no backslash!
-- Inserts e.g. "\ref{fig:ladle}" or "\vref{fig:ladle}" or ... based on this property
-- Put "" to insert the plain label: e.g. "fig:ladle" 

property only_scan_current_file : true
-- If false, the script will search through every .tex file in the folder containing the current file.
-- This is useful for projects with other \include{} -ed files in the same folder.
-- Otherwise, it will only look in the current file.

property sort_output : false
-- If false, displays labels in the order they're found in the document.
-- Otherwise, displays them in alphabetical order.

property save_before_run : true
-- The script only finds labels created in saved documents. If you don't want this script to save your document before it runs for whatever reason, set this to true.

--THE SCRIPT:


if save_before_run then
	tell application "TeXShop" to save the front document
end if

tell application "TeXShop" to set texpath to the path of the front document -- the current tex file: "/path/to/docu.tex"

if only_scan_current_file then
	set texfiles_tosearch to the quoted form of the texpath -- search the current file
else
	set texloc to POSIX file texpath -- Convert to applescript format: "path:to:docu.tex"
	tell application "Finder" to set texfolder to the container of (texloc as alias) -- Get the folder: "path:to:"
	set texdir to the POSIX path of (texfolder as alias) -- Convert to UNIX path: "/path/to"
	set texfiles_tosearch to the quoted form of texdir &amp; "*.tex" -- search all .tex files: "/path/to/*.tex"
end if

tell application "TeXShop"
	
	set current_selection to the content of the selection of the front document
	
	-- DO SHELL SCRIPT COMPONENTS:
	--set find_label_lines to ("grep -h '\\\\label' " &amp; texfiles_tosearch) as string
	set find_label_lines to ("cat " &amp; texfiles_tosearch &amp; " | tr '\\r' '\\n'  | grep '\\\\label{' " &amp; texfiles_tosearch) as string
	-- (Better commmand suggested by Matthew Hills which also converts the line-endings to UNIX form - thanks!)
	set trim_to_raw_labels to " | sed 's/.*\\\\label{//' | sed 's/}.*//'"
	set filter_selection to " | grep " &amp; quoted form of the current_selection
	if sort_output then
		set sort to " | sort -u"
	else
		set sort to ""
	end if
	
	-- glue the shell scripts together:
	set get_labels_shell_script to find_label_lines &amp; trim_to_raw_labels &amp; sort
	
	try
		-- filter choices with the current selection:
		set choose_labels to every paragraph of (do shell script get_labels_shell_script &amp; filter_selection)
	on error
		-- If it fails (e.g., nothing found) ask to diplay all labels:
		display dialog "No labels found that contain '" &amp; the current_selection &amp; "'. Would you like to view the whole list?" buttons {"Cancel", "View all"} default button "View all"
		if the button returned of the result is "View all" then
			set choose_labels to every paragraph of (do shell script get_labels_shell_script)
		else
			return -- exit script
		end if
	end try
	
	-- In case the document doesn't contain any labels:
	if choose_labels = {""} then
		display dialog "Sorry, no \\label{} items have been found." buttons {"No worries"} default button "No worries"
		return
	end if
	
	set label_insert to choose from list choose_labels with prompt "Please choose the label of the reference to insert:"
	if label_insert ≠ false then
		if ref_command = "" then
			set ref_insert to label_insert
		else
			set ref_insert to "\\" &amp; ref_command &amp; "{" &amp; label_insert &amp; "}"
		end if
		set the selection of the front document to ref_insert as string
	end if
	
end tell</string>
			<key>key</key>
			<string>R+ShiftKey</string>
			<key>name</key>
			<string>Insert reference</string>
		</dict>
		<dict>
			<key>content</key>
			<string>--applescript direct
property sort_output : false-- If false, displays labels in the order they're found in the document.-- Otherwise, displays them in alphabetical order.property save_before_run : true-- The script only finds labels created in saved documents. If you don't want this script to save your document before it runs for whatever reason, set this to true.
--Adapted from Will Robertson's Insert Reference by Michael Sharpe, 2012
--THE SCRIPT:set tid to Applescript's text item delimiters
set docname to #DOCUMENTNAME#if docname is equal to "" then	display dialog "No document---bailing out."	returnend ifif save_before_run then	tell application "TeXShop" to save docnameend ifset texpath to #FILEPATH#set texfiles_tosearch to the quoted form of the texpath -- search the current fileset q1 to display dialog "Choose from labels containing text:" default answer "" buttons {"Cancel", "Go"} default button "Go"if the button returned of q1 is "Go" then	set current_selection to text returned of q1else	return -- exit scriptend if-- DO SHELL SCRIPT COMPONENTS:set find_label_lines to ("/bin/cat " &amp; texfiles_tosearch &amp; " | /usr/bin/tr '\\r' '\\n'  | /usr/bin/grep '\\\\label{' ") as stringset trim_to_raw_labels to " | /usr/bin/sed 's/.*\\\\label{//' | /usr/bin/sed 's/}.*//'"set filter_selection to ""if (count of current_selection) &gt; 0 then	set filter_selection to " | /usr/bin/grep -i " &amp; quoted form of the current_selectionend ifif sort_output then	set sort to " | /usr/bin/sort -u"else	set sort to ""end if-- glue the shell scripts together:set get_labels_shell_script to find_label_lines &amp; trim_to_raw_labels &amp; sort

try	-- filter choices with the current selection:	set s to (do shell script get_labels_shell_script &amp; filter_selection)
	set choose_labels to every paragraph of son error	-- If it fails (e.g., nothing found) ask to diplay all labels:
          if (count of current_selection) &gt; 0 then	    display dialog "No labels found that contain '" &amp; the current_selection &amp; "'. Would you like to view the whole list?" buttons {"Cancel", "View all"} default button "View all"	    if the button returned of the result is "View all" then	   	set s to (do shell script get_labels_shell_script)		set choose_labels to every paragraph of s	    else		return -- exit script	    end if
        end ifend try-- In case the document doesn't contain any labels:if (count of choose_labels) is 0 then	display dialog "Sorry, no \\label{} items have been found." buttons {"OK"} default button "OK"	returnend if

set label_chosen to choose from list choose_labels with prompt "Please choose from names of matching labels:"if label_chosen ≠ false then
   --set find_label_line to ("/bin/cat " &amp; texfiles_tosearch &amp; " | /usr/bin/tr '\\r' '\\n'  | /usr/bin/grep -n '\\\\label{" &amp; label_chosen &amp;"}'") as string
   --set s to (do shell script find_label_line)
   --set Applescript's text item delimiters to ":"
   --set j to item 1 of (s as list)
   --set Applescript's text item delimiters to tid
   set j to 7+(count of (item 1 of label_chosen))
   tell application "TeXShop" --to tell document docname to goto line j
            set i to search document docname for "\\label{" &amp; label_chosen &amp; "}" starting from 1
            set offset of selection of document docname to i
            set length of selection of document docname to j
            tell application "System Events" to tell process "TeXShop" to keystroke (ASCII character 28) using {shift down}
    end tellend if</string>
			<key>key</key>
			<string></string>
			<key>name</key>
			<string>Goto label</string>
		</dict>
		<dict>
			<key>content</key>
			<string>-- Applescript direct

-- OPEN QUICKLY...
-- The idea for this script was stolen from iTeXMac.
-- This script pops up a dialog box with a list of  files in the current directory.
-- The selection (multiple allowed) is opened.

-- CUSTOMISE TO YOUR LIKING:
property extensions_to_open : {"tex", "sty", "pdf"}


-- THE SCRIPT:

--get the path to the current tex file - "/path/to/docu.tex":
tell application "TeXShop" to set texpath to the path of the front document

-- Convert to applescript format - "path:to:docu.tex"
set texloc to POSIX file texpath
-- Get the folder it's in - "path:to:"
tell application "Finder" to set texfolder to the container of (texloc as alias)
-- Get the path to the folder - "/path/to/"
set texdir to the POSIX path of (texfolder as alias)
-- Get a list of all the filenames to open:
set texfiles to the name of every file of texfolder whose name extension is in extensions_to_open

tell application "TeXShop" to set openfiles to choose from list texfiles with prompt "Which file(s) do you wish to open?" with multiple selections allowed
if openfiles is not false then
	repeat with this_filename in openfiles
		set file_to_open to POSIX file (texdir &amp; this_filename)
		tell application "TeXShop" to open file_to_open
	end repeat
end if</string>
			<key>key</key>
			<string>O+ShiftKey</string>
			<key>name</key>
			<string>Open quickly…</string>
		</dict>
		<dict>
			<key>content</key>
			<string></string>
			<key>key</key>
			<string></string>
			<key>name</key>
			<string>Applescript</string>
			<key>submenu</key>
			<array>
				<dict>
					<key>content</key>
					<string>--AppleScript direct

tell application "Adobe Reader"
  activate
  open POSIX file #PDFPATH#
end tell
</string>
					<key>key</key>
					<string></string>
					<key>name</key>
					<string>View pdf with Acrobat</string>
				</dict>
				<dict>
					<key>content</key>
					<string>--AppleScript direct
-- #FILEPATH# in the text will be replaced by the path of the document
-- #DVIPATH#, #PSPATH#, #PDFPATH# are also replaced by the paths of .dvi, .ps, .dvi files.  
-- to use the path in Finder, use (alias POSIX file filepath)
-- example: show tex and pdf files in Finder

try
tell application "Finder"
  activate
  reveal {alias POSIX file #FILEPATH#, alias POSIX file #PDFPATH#}
end tell
on error
end try</string>
					<key>key</key>
					<string></string>
					<key>name</key>
					<string>Show files</string>
				</dict>
				<dict>
					<key>content</key>
					<string>--AppleScript direct
-- If the content field starts with "--AppleScript" then it will be interpreted as an AppleScript and will be executed.  
-- example: show TeXShop home page in a web browser

open location "http://darkwing.uoregon.edu/~koch/texshop/texshop.html"</string>
					<key>key</key>
					<string></string>
					<key>name</key>
					<string>TeXShop home page</string>
				</dict>
				<dict>
					<key>content</key>
					<string>--AppleScript direct
-- If the content field starts with "--AppleScript" then it will be interpreted as an AppleScript and will be executed.  

open location "http://tug.org/mactex/"</string>
					<key>key</key>
					<string></string>
					<key>name</key>
					<string>MacTeX home page</string>
				</dict>
				<dict>
					<key>content</key>
					<string>--Applescript direct

-- OPEN TeXLive FILE
-- Type the name of a file in the TeXLive tree, for example "geometry.sty". This macro will find it and open it.

set q1 to display dialog "Open TeX File" &amp; return &amp; return &amp; "Enter the name, including extension, of the TeX file you want to open." default answer "" buttons {"Cancel", "Open"} default button "Open"
set filename_to_open to the text returned of q1

try
	set file_path to do shell script "/usr/texbin/kpsewhich " &amp; filename_to_open
	set theFile to alias (POSIX file file_path)
	tell application "TeXShop"
		activate
		open theFile
	end tell
on error
	display dialog ("There don't seem to be any files in the teTeX tree with the filename: " &amp; filename_to_open) buttons {"OK"} default button "OK"
end try
</string>
					<key>key</key>
					<string></string>
					<key>name</key>
					<string>View TeX Live file</string>
				</dict>
				<dict>
					<key>content</key>
					<string>--Applescript direct
-- If front file is named "Test.tex", write a copy as "Test_Mac.tex", changing all line feeds to
-- Macintosh Classic line feeds

set fileName to  #NAMEPATH#
set n to (number of characters of contents of fileName)
set fileNamequoted to quoted form of fileName
set baseName to do shell script "basename " &amp; fileNamequoted
set m to (number of characters of contents of baseName)
set dirName to quoted form of (characters 1 thru (n - m - 1) of fileName as string)
set texName to baseName &amp; ".tex"
set backupTexName to baseName &amp; "_Mac.tex"

set shellScript to  "cd " &amp; dirName &amp; ";"
set shellScript to shellScript &amp; "cp  " &amp; texName &amp;" " &amp; backupTexName &amp;";"
set shellScript to shellScript &amp; "/bin/tcsh -c '~/Library/TeXShop/bin/flip -m  " &amp; backupTexName &amp; "'"
do shell script shellScript


</string>
					<key>key</key>
					<string></string>
					<key>name</key>
					<string>Convert to MAC</string>
				</dict>
				<dict>
					<key>content</key>
					<string>--Applescript direct
-- If front file is named "Test.tex", write a copy as "Test_Unix.tex", changing all line feeds to
-- Unix line feeds

set fileName to  #NAMEPATH#
set n to (number of characters of contents of fileName)
set fileNamequoted to quoted form of fileName
set baseName to do shell script "basename " &amp; fileNamequoted
set m to (number of characters of contents of baseName)
set dirName to quoted form of (characters 1 thru (n - m - 1) of fileName as string)
set texName to baseName &amp; ".tex"
set backupTexName to baseName &amp; "_Unix.tex"

set shellScript to  "cd " &amp; dirName &amp; ";"
set shellScript to shellScript &amp; "cp  " &amp; texName &amp;" " &amp; backupTexName &amp;";"
set shellScript to shellScript &amp; "/bin/tcsh -c '~/Library/TeXShop/bin/flip -u  " &amp; backupTexName &amp; "'"
do shell script shellScript
</string>
					<key>key</key>
					<string></string>
					<key>name</key>
					<string>Convert to Unix</string>
				</dict>
				<dict>
					<key>content</key>
					<string>--Applescript direct
-- If front file is named "Test.tex", write a copy as "Test_Windows.tex", changing all line feeds to
-- Windows line feeds

set fileName to  #NAMEPATH#
set n to (number of characters of contents of fileName)
set fileNamequoted to quoted form of fileName
set baseName to do shell script "basename " &amp; fileNamequoted
set m to (number of characters of contents of baseName)
set dirName to quoted form of (characters 1 thru (n - m - 1) of fileName as string)
set texName to baseName &amp; ".tex"
set backupTexName to baseName &amp; "_Windows.tex"

set shellScript to  "cd " &amp; dirName &amp; ";"
set shellScript to shellScript &amp; "cp  " &amp; texName &amp;" " &amp; backupTexName &amp;";"
set shellScript to shellScript &amp; "/bin/tcsh -c '~/Library/TeXShop/bin/flip -d  " &amp; backupTexName &amp; "'"
do shell script shellScript
</string>
					<key>key</key>
					<string></string>
					<key>name</key>
					<string>Convert to Windows</string>
				</dict>
				<dict>
					<key>content</key>
					<string>--Applescript

set fileName to #FILEPATH#
if fileName is equal to  ""
activate
display dialog "Please save the file first"  buttons {"OK"} default button "OK"
return
end if

set frontName to #DOCUMENTNAME#

tell document frontName of application "TeXShop"

	latexinteractive

	repeat
		delay 2
		if taskdone
			exit repeat
		end if
	end repeat

	bibtex

	repeat
		delay 2
		if taskdone
			exit repeat
		end if
	end repeat

	latex

	repeat
		delay 2
		if taskdone
			exit repeat
		end if
	end repeat

	latex

	repeat
		delay 2
		if taskdone
			exit repeat
		end if
	end repeat

end tell

</string>
					<key>key</key>
					<string></string>
					<key>name</key>
					<string>Bibliography</string>
				</dict>
				<dict>
					<key>content</key>
					<string>--Applescript direct

--TeXShop restart required for changes to take effect

do shell script "defaults write TeXShop background_R 0.3"
do shell script "defaults write TeXShop background_G 0.3"
do shell script "defaults write TeXShop background_B 0.3"
do shell script "defaults write TeXShop foreground_R 1.0"
do shell script "defaults write TeXShop foreground_G 1.0"
do shell script "defaults write TeXShop foreground_B 1.0"</string>
					<key>key</key>
					<string></string>
					<key>name</key>
					<string>Colored source</string>
				</dict>
				<dict>
					<key>content</key>
					<string>--Applescript direct

--TeXShop restart required for changes to take effect

do shell script "defaults write TeXShop background_R 1.00"
do shell script "defaults write TeXShop background_G 1.00"
do shell script "defaults write TeXShop background_B 1.00"
do shell script "defaults write TeXShop foreground_R .0"
do shell script "defaults write TeXShop foreground_G .0"
do shell script "defaults write TeXShop foreground_B .0"</string>
					<key>key</key>
					<string></string>
					<key>name</key>
					<string>Default Colored source</string>
				</dict>
			</array>
		</dict>
		<dict>
			<key>content</key>
			<string></string>
			<key>key</key>
			<string></string>
			<key>name</key>
			<string>Column macros</string>
			<key>submenu</key>
			<array>
				<dict>
					<key>content</key>
					<string>--Applescript direct

-- NEW TABULAR
-- This script inserts a new tabular environment with a user-specified number of rows and columns. You can choose to have a plain table or a booktabs table - for the latter case you need to be using either the Memoir class or the booktabs package. Finally you may choose whether to have the table floating with a caption or simply centred.

-- CUSTOMISE TO YOUR LIKING:

property indent : "  " -- edit this if you want other than 2 spaces for your indent
property cell_text : "• " -- edit this if you want a different text blob

property default_tabular_type: "Booktabs" -- or "Plain"
property default_table_type: "Floating" -- or "Centred"

-- THE SCRIPT:

property texapp : "TeXShop"
tell application texapp
	
	set q1 to display dialog "New tabular" &amp; return &amp; return &amp; "Enter the number of columns you'd like and then select the type of tabular you want." default answer "3" buttons {"Cancel", "Plain", "Booktabs"} default button default_tabular_type
	set NCOLS to the text returned of q1
	set tabtype to the button returned of q1
	
	set q2 to display dialog "Enter the number of rows you'd like (not including a header row) and select whether you'd like a floating or simply centred table." default answer "3" buttons {"Cancel", "Centred", "Floating"} default button default_table_type
	set NROWS to the text returned of q2
	set floattype to the button returned of q2
	
	if the tabtype = "Booktabs" then
		set the toprule to "\\toprule"
		set the midrule to "\\midrule"
		set the bottomrule to "\\bottomrule"
	else
		set the toprule to "\\hline"
		set the midrule to "\\hline"
		set the bottomrule to "\\hline"
	end if
	
	if the floattype = "Floating" then
		set the beforetext to ¬
			"\\begin{table}[htbp]" &amp; return &amp; ¬
			indent &amp; "\\centering" &amp; return &amp; ¬
			indent &amp; "\\begin{tabular}" -- note no carriage return to allow space for the column preamble
		set the aftertext to ¬
			indent &amp; indent &amp; bottomrule &amp; return &amp; ¬
			indent &amp; "\\end{tabular}" &amp; return &amp; ¬
			indent &amp; "\\caption{TableCaption}" &amp; return &amp; ¬
			indent &amp; "\\label{tab:label}" &amp; return &amp; ¬
			"\\end{table}"
	else
		set the beforetext to ¬
			"\\begin{center}" &amp; return &amp; ¬
			indent &amp; "\\begin{tabular}"
		set the aftertext to ¬
			indent &amp; indent &amp; bottomrule &amp; return &amp; ¬
			indent &amp; "\\end{tabular}" &amp; return &amp; ¬
			"\\end{center}"
	end if
	
	set the column_preamble to "{@{} c"
	set the one_row_text to indent &amp; indent &amp; cell_text
	
	if NCOLS &gt; 1 then
		repeat with c from 2 to NCOLS
			set the column_preamble to column_preamble &amp; "c"
			set the one_row_text to one_row_text &amp; "&amp; " &amp; cell_text
		end repeat
	end if
	
	set the column_preamble to column_preamble &amp; " @{}}" &amp; return
	set the one_row_text to one_row_text &amp; "\\\\ "
	
	-- start off with a header row between two rules:
	set the midtext to ¬
		indent &amp; indent &amp; toprule &amp; return &amp; ¬
		one_row_text &amp; return &amp; ¬
		indent &amp; indent &amp; midrule &amp; return
	
	repeat with r from 1 to NROWS
		set the midtext to midtext &amp; one_row_text &amp; return
	end repeat
	
	set alltext to beforetext &amp; column_preamble &amp; midtext &amp; aftertext
	
	if texapp = "TeXShop" then
		tell application "TeXShop" to set the content of the selection of the front document to alltext
	else if texapp = "iTeXMac" then
		--tell application "iTeXMac" to insert alltext in the text of the front document
	end if
	
end tell

-- 2004 Will Robertson
-- (You may do what you like with this script)</string>
					<key>key</key>
					<string>T+ControlKey</string>
					<key>name</key>
					<string>New tabular</string>
				</dict>
				<dict>
					<key>content</key>
					<string>--Applescript direct

-- NEW TABULAR
-- This script inserts a new array environment with a user-specified number of rows and columns. You may choose to indent the array, since you'll be inserting it into a maths environment.

-- CUSTOMISE TO YOUR LIKING:
property indent : "  " -- edit this if you want other than 2 spaces for your indent
property cell_text : "• " -- edit this if you want a different text blob

property default_array_location: "Indent" -- or "Flush left"

-- THE SCRIPT:

property texapp : "TeXShop"
tell application texapp
	
	set q1 to display dialog "New maths array." &amp; return &amp; return &amp; "Enter the number of rows you'd like." default answer "3"
	set NROWS to the text returned of q1
	
	set q2 to display dialog "How many columns would you like? Would you like me to indent the array?" default answer "3" buttons {"Cancel", "Flush left", "Indent"} default button default_array_location
	set NCOLS to the text returned of q2
	set indentyesno to the button returned of q2
	
	if the indentyesno = "Indent" then
		set the preindent to indent
	else
		set the preindent to ""
	end if
	
	set the column_preamble to "{c"
	set the one_row_text to preindent &amp; indent &amp; cell_text
	
	if NCOLS &gt; 1 then
		repeat with c from 2 to NCOLS
			set the column_preamble to column_preamble &amp; "c"
			set the one_row_text to one_row_text &amp; "&amp; " &amp; cell_text
		end repeat
	end if
	
	set the column_preamble to column_preamble &amp; "}" &amp; return
	set the one_row_text to one_row_text &amp; "\\\\ " &amp; return
	
	set midtext to ""
	repeat with r from 1 to NROWS
		set the midtext to midtext &amp; one_row_text
	end repeat
	
	set the beforetext to preindent &amp; "\\begin{array}"
	set the aftertext to preindent &amp; "\\end{array}"
	
	set alltext to beforetext &amp; column_preamble &amp; midtext &amp; aftertext
	
	if texapp = "TeXShop" then
		tell application "TeXShop" to set the content of the selection of the front document to alltext
	else if texapp = "iTeXMac" then
		--tell application "iTeXMac" to insert alltext in the text of the front document
	end if
	
end tell

-- 2004 Will Robertson
-- (You may do what you like with this script)</string>
					<key>key</key>
					<string>A+ControlKey</string>
					<key>name</key>
					<string>New array</string>
				</dict>
				<dict>
					<key>content</key>
					<string>--Applescript direct

-- ADD COLUMN
--Select the tabular/array rows you wish to edit and run the script. The script will insert a new column at the specified location in each row. You'll have to adjust multicolumn rows and the column preamble (eg, the {ccc} part) manually.

-- CUSTOMISE TO YOUR LIKING:
property indent : "  "
property default_button : "After" -- or "Before"
property cell_blob : "•"


--THE SCRIPT:

property texapp : "TeXShop"
tell application texapp
	set q to display dialog "Add column." &amp; return &amp; return &amp; "Please enter the column number before or after which you would like to add a new column." default answer "1" buttons {"Before", "After"} default button default_button
	set add_where to the button returned of q
	set col_num to the text returned of q
	
	if texapp = "TeXShop" then
		tell application "TeXShop" to set tabular to the content of the selection of the front document
	else if texapp = "iTeXMac" then
		--tell application "iTeXMac" to set tabular to (the selection of the text of the front document)
	end if
	
	set new_tabular to ""
	repeat with ii from 1 to the count of the paragraphs of tabular
		
		set this_line to paragraph ii of tabular

		if this_line contains "\\\\" and this_line does not contain "\\multicolumn" then
			
			--Transform "    a &amp; b &amp; c \\" to "a &amp; b &amp; c":
			set trim_line to do shell script ¬
				"echo " &amp; the quoted form of this_line &amp; ¬
				" | sed 's/^[ ^t]*//' | sed 's/\\\\\\\\//'"
			-- "\\\\\\\\" is a TeX newline escaped in both Applescript and the shell
			
			
			set new_col to "&amp; " &amp; cell_blob &amp; " &amp;"
			if add_where = "After" then
				set line_start to do shell script "echo " &amp; the quoted form of trim_line &amp; " | cut -f -" &amp; col_num &amp; " -d '&amp;'"
				set line_end to do shell script "echo " &amp; the quoted form of trim_line &amp; " | cut -f " &amp; col_num + 1 &amp; "- -d '&amp;'"
				if line_end = "" then
					set new_col to "&amp; " &amp; cell_blob &amp; " "
				end if
			else if add_where = "Before" then
				if col_num = "1" then
					set line_start to ""
					set new_col to cell_blob &amp; " &amp; "
					set line_end to trim_line
				else
					set line_start to do shell script "echo " &amp; the quoted form of trim_line &amp; " | cut -f -" &amp; col_num - 1 &amp; " -d '&amp;'"
					set line_end to do shell script "echo " &amp; the quoted form of trim_line &amp; " | cut -f " &amp; col_num &amp; "- -d '&amp;'"
					if line_end = "" then
						set new_col to "&amp; " &amp; cell_blob &amp; " "
					end if
				end if
			end if
			
			set new_line to indent &amp; indent &amp; line_start &amp; new_col &amp; line_end &amp; "\\\\"
			if new_tabular = "" then
				set new_tabular to new_line
			else
				set new_tabular to new_tabular &amp; return &amp; new_line
			end if
		else
			if new_tabular = "" then
				set new_tabular to this_line
			else
				set new_tabular to new_tabular &amp; return &amp; this_line
			end if
		end if
		
	end repeat
	
	if tabular contains "\\multicolumn" then
		display dialog "I cannot parse lines with “\\multicolumn” in them. You'll have to do them by hand. Sorry." buttons {"Cancel", "Proceed"} default button "Proceed" with icon caution
	end if
	
	if texapp = "TeXShop" then
		tell application "TeXShop" to set the selection of the front document to new_tabular
	else if texapp = "iTeXMac" then
		--tell application "iTeXMac" to insert new_tabular in the text of the front document
	end if
	
	display dialog "Don't forget to add a column to the column header!" buttons {"•"} giving up after 2
	
end tell

-- 2004 Will Robertson
-- (You may do what you like with this script)</string>
					<key>key</key>
					<string></string>
					<key>name</key>
					<string>Add column</string>
				</dict>
				<dict>
					<key>content</key>
					<string>--Applescript direct

-- DELETE COLUMN
--Select the tabular/array rows you wish to edit and run the script. The script will delete the specified column from each row (after a confirmation). You'll have to adjust multicolumn rows and the column preamble (eg, the {ccc} part) manually.

-- CUSTOMISE TO YOUR LIKING:
property indent : "  "
property warn_before_delete: true

-- THE SCRIPT:

property texapp : "TeXShop"
tell application texapp
	
	set q to display dialog "Delete column." &amp; return &amp; return &amp; "Please enter the number of the column you would like to delete." default answer "1" buttons {"Cancel", "Delete"} default button "Delete"
	set col_num to the text returned of q

	if texapp = "TeXShop" then
		tell application "TeXShop" to set tabular to the content of the selection of the front document
	else if texapp = "iTeXMac" then
		--tell application "iTeXMac" to set tabular to (the selection of the text of the front document)
	end if
	
	if tabular = "" then
		display dialog "Nothing selected. Please select the tabular/array rows you wish to edit." buttons "Cancel" default button 1
	end if
	
	set sample_value to ""
	set new_tabular to ""
	repeat with ii from 1 to the count of the paragraphs of tabular
		
		set this_line to paragraph ii of tabular
		
		if this_line contains "\\\\" and this_line does not contain "\\multicolumn" then
			-- note "\\\\" means \\ because the backslashes are escaped
			
			--Transform "    a &amp; b &amp; c \\" to "a &amp; b &amp; c":
			set trim_line to do shell script ¬
				"echo " &amp; the quoted form of this_line &amp; ¬
				" | sed 's/^[ ^t]*//' | sed 's/\\\\\\\\//'"
			-- "\\\\\\\\" is a TeX newline escaped in both Applescript and the shell
			
			set new_col to "&amp;"
			if sample_value = "" then
				set sample_value to do shell script "echo " &amp; the quoted form of trim_line &amp; " | cut -f " &amp; col_num &amp; "-" &amp; col_num &amp; " -d '&amp;'"
			end if
			if col_num = "1" then
				set line_start to ""
				set line_end to do shell script "echo " &amp; the quoted form of trim_line &amp; " | cut -f " &amp; col_num + 1 &amp; "- -d '&amp;'"
				set new_col to ""
			else
				set line_start to do shell script "echo " &amp; the quoted form of trim_line &amp; " | cut -f -" &amp; col_num - 1 &amp; " -d '&amp;'"
				set line_end to do shell script "echo " &amp; the quoted form of trim_line &amp; " | cut -f " &amp; col_num + 1 &amp; "- -d '&amp;'"
				if line_end = "" then
					set new_col to ""
				end if
			end if
			
			
			set new_line to indent &amp; indent &amp; line_start &amp; new_col &amp; line_end &amp; "\\\\"
			if new_tabular = "" then
				set new_tabular to new_line
			else
				set new_tabular to new_tabular &amp; return &amp; new_line
			end if
		else
			if new_tabular = "" then
				set new_tabular to this_line
			else
				set new_tabular to new_tabular &amp; return &amp; this_line
			end if
		end if
		
	end repeat
	
	if warn_before_delete then
		display dialog "Are you sure you want to delete the column that begins with “" &amp; sample_value &amp; "”?" buttons {"Cancel", "Delete"} default button "Delete"
	end if
	
	if tabular contains "\\multicolumn" then
		display dialog "I cannot parse lines with “\\multicolumn” in them. You'll have to do them by hand. Sorry." buttons {"Cancel", "Proceed"} default button "Proceed" with icon caution
	end if
	
	if texapp = "TeXShop" then
		tell application "TeXShop" to set the selection of the front document to new_tabular
	else if texapp = "iTeXMac" then
		--tell application "iTeXMac" to insert new_tabular in the text of the front document
	end if
	
	display dialog "Don't forget to remove a column from the column header!" buttons {"•"} giving up after 2
	
end tell

-- 2004 Will Robertson
-- (You may do what you like with this script)</string>
					<key>key</key>
					<string></string>
					<key>name</key>
					<string>Delete column</string>
				</dict>
			</array>
		</dict>
		<dict>
			<key>content</key>
			<string>--Applescript direct
--This script copyright 2009,2010 by Alan Munn &lt;amunn@msu.edu&gt;
--Version 1.1 2010/01/31
--Copy cells from Excel or other spreadsheet program and
-- use this script to paste the cells into your LaTeX source
-- in a variety of different table styles.
set mainList to {"cells","booktabs", "simple","longtable" }
choose from list mainList with prompt "Choose a table format"
if the result is not false then
	set tablestyle to result as text
	do shell script  "~/Library/TeXShop/bin/csv2latex" &amp; " " &amp;  tablestyle
	tell application "System Events" to keystroke "v" using {command down}
end if
--End of Applescript
</string>
			<key>key</key>
			<string></string>
			<key>name</key>
			<string>Paste Spreadsheet Cells</string>
		</dict>
		<dict>
			<key>content</key>
			<string></string>
			<key>key</key>
			<string></string>
			<key>name</key>
			<string>Claus Gerhardt Macros</string>
			<key>submenu</key>
			<array>
				<dict>
					<key>content</key>
					<string>--Applescript
-- Apply only to an already saved file
-- Claus Gerhardt, Nov. 2003

set scriptPath to (do shell script "dirname " &amp; "~/Library/TeXShop/Scripts/ex")
set scriptPath to scriptPath &amp; "/setname.scpt"
set scriptName to POSIX file scriptPath as alias
set scriptLiB to (load script scriptName)
tell scriptLib
set frontName to setname(#NAMEPATH#,#TEXPATH#)
end tell

set fileName to  #NAMEPATH#
set n to (number of characters of contents of fileName)
set fileNamequoted to quoted form of fileName
set baseName to do shell script "basename " &amp; fileNamequoted
set m to (number of characters of contents of baseName)
set dirName to quoted form of (characters 1 thru (n - m - 1) of fileName as string)
set texName to baseName &amp; ".tex"

set shellScript to "cd " &amp; dirName &amp; ";"
set shellScript to shellScript &amp; "~/Library/TeXShop/bin/bibtexc  " &amp; baseName
do shell script shellScript

set shellScript to "cd " &amp; dirName &amp; ";"
set shellScript to shellScript &amp; "~/Library/TeXShop/bin/pdflatexc  " &amp; texName
do shell script shellScript

set shellScript to "cd " &amp; dirName &amp; ";"
set shellScript to shellScript &amp; "~/Library/TeXShop/bin/pdflatexc  " &amp; texName
do shell script shellScript


set fileLog to fileName &amp; ".blg"
set theFile to alias (POSIX file fileLog)
set logName to baseName &amp;".blg"

tell document frontName of application "TeXShop"
refreshpdf
end tell

tell application "TeXShop"
open theFile
end tell

tell document logName of application "TeXShop"
refreshtext
end tell




</string>
					<key>key</key>
					<string></string>
					<key>name</key>
					<string>bibtexc</string>
				</dict>
				<dict>
					<key>content</key>
					<string>--Applescript
-- Apply only to an already saved file
-- Claus Gerhardt, Nov. 2003

set scriptPath to (do shell script "dirname " &amp; "~/Library/TeXShop/Scripts/ex")
set scriptPath to scriptPath &amp; "/setname.scpt"
set scriptName to POSIX file scriptPath as alias
set scriptLiB to (load script scriptName)
tell scriptLib
set frontName to setname(#NAMEPATH#,#TEXPATH#)
end tell

set fileName to  #NAMEPATH#
set n to (number of characters of contents of fileName)
set fileNamequoted to quoted form of fileName
set baseName to do shell script "basename " &amp; fileNamequoted
set m to (number of characters of contents of baseName)
set dirName to quoted form of (characters 1 thru (n - m - 1) of fileName as string)
set texName to baseName &amp; ".tex"

set shellScript to "cd " &amp; dirName &amp; ";"
set shellScript to shellScript &amp; "~/Library/TeXShop/bin/pdflatexc  " &amp; texName
do shell script shellScript


set shellScript to "cd " &amp; dirName &amp; ";"
set shellScript to shellScript &amp; "~/Library/TeXShop/bin/bibtexc  " &amp; baseName
do shell script shellScript

set shellScript to "cd " &amp; dirName &amp; ";"
set shellScript to shellScript &amp; "~/Library/TeXShop/bin/pdflatexc  " &amp; texName
do shell script shellScript

set shellScript to "cd " &amp; dirName &amp; ";"
set shellScript to shellScript &amp; "~/Library/TeXShop/bin/pdflatexc  " &amp; texName
do shell script shellScript


set fileLog to fileName &amp; ".blg"
set theFile to alias (POSIX file fileLog)
set logName to baseName &amp;".blg"

tell document frontName of application "TeXShop"
refreshpdf
end tell

tell application "TeXShop"
open theFile
end tell

tell document logName of application "TeXShop"
refreshtext
end tell




</string>
					<key>key</key>
					<string></string>
					<key>name</key>
					<string>bibtexcpl</string>
				</dict>
				<dict>
					<key>content</key>
					<string></string>
					<key>key</key>
					<string></string>
					<key>name</key>
					<string>Separator</string>
				</dict>
				<dict>
					<key>content</key>
					<string>--Applescript
-- Apply only to an already saved file
-- Claus Gerhardt, Nov. 2003

set scriptPath to (do shell script "dirname " &amp; "~/Library/TeXShop/Scripts/ex")
set scriptPath to scriptPath &amp; "/setname.scpt"
set scriptName to POSIX file scriptPath as alias
set scriptLiB to (load script scriptName)
tell scriptLib
set frontName to setname(#NAMEPATH#,#TEXPATH#)
end tell

set fileName to  #NAMEPATH#
set n to (number of characters of contents of fileName)
set fileNamequoted to quoted form of fileName
set baseName to do shell script "basename " &amp; fileNamequoted
set m to (number of characters of contents of baseName)
set dirName to quoted form of (characters 1 thru (n - m - 1) of fileName as string)
set texName to baseName &amp; ".tex"

set shellScript to "cd " &amp; dirName &amp; ";"
set shellScript to shellScript &amp; "~/Library/TeXShop/bin/mpostc  " &amp; baseName
do shell script shellScript

set fileLog to fileName &amp; ".log"
set theFile to alias (POSIX file fileLog)
set logName to baseName &amp;".log"

tell application "TeXShop"
open theFile
end tell

tell document logName of application "TeXShop"
refreshtext
end tell


set shellScript to "cd " &amp; dirName &amp; ";"
set shellScript to shellScript &amp; "~/Library/TeXShop/bin/pdflatexc  " &amp; texName
do shell script shellScript


tell document frontName of application "TeXShop"
refreshpdf
end tell

 </string>
					<key>key</key>
					<string></string>
					<key>name</key>
					<string>mpostc</string>
				</dict>
				<dict>
					<key>content</key>
					<string>--Applescript
-- Apply only to an already saved file
-- Claus Gerhardt, Nov. 2003

set scriptPath to (do shell script "dirname " &amp; "~/Library/TeXShop/Scripts/ex")
set scriptPath to scriptPath &amp; "/setname.scpt"
set scriptName to POSIX file scriptPath as alias
set scriptLiB to (load script scriptName)
tell scriptLib
set frontName to setname(#NAMEPATH#,#TEXPATH#)
end tell

set fileName to  #NAMEPATH#
set n to (number of characters of contents of fileName)
set fileNamequoted to quoted form of fileName
set baseName to do shell script "basename " &amp; fileNamequoted
set m to (number of characters of contents of baseName)
set dirName to quoted form of (characters 1 thru (n - m - 1) of fileName as string)
set texName to baseName &amp; ".tex"

set shellScript to "cd " &amp; dirName &amp; ";"
set shellScript to shellScript &amp; "~/Library/TeXShop/bin/pdflatexc  " &amp; texName
do shell script shellScript

set shellScript to "cd " &amp; dirName &amp; ";"
set shellScript to shellScript &amp; "~/Library/TeXShop/bin/mpostc  " &amp; baseName
do shell script shellScript

set fileLog to fileName &amp; ".log"
set theFile to alias (POSIX file fileLog)
set logName to baseName &amp;".log"

tell application "TeXShop"
open theFile
end tell

tell document logName of application "TeXShop"
refreshtext
end tell


set shellScript to "cd " &amp; dirName &amp; ";"
set shellScript to shellScript &amp; "~/Library/TeXShop/bin/pdflatexc  " &amp; texName
do shell script shellScript


tell document frontName of application "TeXShop"
refreshpdf
end tell

 </string>
					<key>key</key>
					<string></string>
					<key>name</key>
					<string>mpostcpl</string>
				</dict>
				<dict>
					<key>content</key>
					<string></string>
					<key>key</key>
					<string></string>
					<key>name</key>
					<string>Separator</string>
				</dict>
				<dict>
					<key>content</key>
					<string>--Applescript
-- Apply only to an already saved file
-- Claus Gerhardt, Nov. 2003

set scriptPath to (do shell script "dirname " &amp; "~/Library/TeXShop/Scripts/ex")
set scriptPath to scriptPath &amp; "/setname.scpt"
set scriptName to POSIX file scriptPath as alias
set scriptLiB to (load script scriptName)
tell scriptLib
set frontName to setname(#NAMEPATH#,#TEXPATH#)
end tell

set fileName to  #NAMEPATH#
set n to (number of characters of contents of fileName)
set fileNamequoted to quoted form of fileName
set baseName to do shell script "basename " &amp; fileNamequoted
set m to (number of characters of contents of baseName)
set dirName to quoted form of (characters 1 thru (n - m - 1) of fileName as string)
set texName to baseName &amp; ".tex"

set shellScript to "cd " &amp; dirName &amp; ";"
set shellScript to shellScript &amp; "~/Library/TeXShop/bin/htlatexc  " &amp; baseName
do shell script shellScript

set theHTML to #HTMLPATH#
set htmlFile to alias POSIX file theHTML

tell application "Safari"
  activate
  open htmlFile
end tell
</string>
					<key>key</key>
					<string></string>
					<key>name</key>
					<string>htlatexc</string>
				</dict>
				<dict>
					<key>content</key>
					<string>--Applescript
-- Apply only to an already saved file
-- Claus Gerhardt, Nov. 2003

set scriptPath to (do shell script "dirname " &amp; "~/Library/TeXShop/Scripts/ex")
set scriptPath to scriptPath &amp; "/setname.scpt"
set scriptName to POSIX file scriptPath as alias
set scriptLiB to (load script scriptName)
tell scriptLib
set frontName to setname(#NAMEPATH#,#TEXPATH#)
end tell

set fileName to  #NAMEPATH#
set n to (number of characters of contents of fileName)
set fileNamequoted to quoted form of fileName
set baseName to do shell script "basename " &amp; fileNamequoted
set m to (number of characters of contents of baseName)
set dirName to quoted form of (characters 1 thru (n - m - 1) of fileName as string)
set texName to baseName &amp; ".tex"

set shellScript to "cd " &amp; dirName &amp; ";"
set shellScript to shellScript &amp; "~/Library/TeXShop/bin/htlatexr  " &amp; baseName
do shell script shellScript

set theHTML to #HTMLPATH#
set htmlFile to alias POSIX file theHTML

tell application "Safari"
  activate
  open htmlFile
end tell
</string>
					<key>key</key>
					<string></string>
					<key>name</key>
					<string>htlatexr</string>
				</dict>
				<dict>
					<key>content</key>
					<string></string>
					<key>key</key>
					<string></string>
					<key>name</key>
					<string>Separator</string>
				</dict>
				<dict>
					<key>content</key>
					<string>--Applescript
-- Apply only to an already saved file.
-- Claus Gerhardt, Nov. 2003

set scriptPath to (do shell script "dirname " &amp; "~/Library/TeXShop/Scripts/ex")
set scriptPath to scriptPath &amp; "/setname.scpt"
set scriptName to POSIX file scriptPath as alias
set scriptLiB to (load script scriptName)
tell scriptLib
set frontName to setname(#NAMEPATH#,#TEXPATH#)
end tell

set fileName to  #TEXPATH#
set n to (number of characters of contents of fileName)
set fileNamequoted to quoted form of fileName
set baseName to do shell script "basename " &amp; fileNamequoted
set m to (number of characters of contents of baseName)
set dirName to quoted form of (characters 1 thru (n - m - 1) of fileName as string)

set shellScript to "cd " &amp; dirName &amp; ";"
set shellScript to shellScript &amp; "~/Library/TeXShop/bin/altpdflatexc  " &amp; baseName
do shell script shellScript

tell document frontName of application "TeXShop"
refreshpdf
end tell
</string>
					<key>key</key>
					<string></string>
					<key>name</key>
					<string>altpdflatexc</string>
				</dict>
				<dict>
					<key>content</key>
					<string>--Applescript
-- Apply only to an already saved file.
-- Claus Gerhardt, Nov. 2003

set scriptPath to (do shell script "dirname " &amp; "~/Library/TeXShop/Scripts/ex")
set scriptPath to scriptPath &amp; "/setname.scpt"
set scriptName to POSIX file scriptPath as alias
set scriptLiB to (load script scriptName)
tell scriptLib
set frontName to setname(#NAMEPATH#,#TEXPATH#)
end tell

set fileName to  #TEXPATH#
set n to (number of characters of contents of fileName)
set fileNamequoted to quoted form of fileName
set baseName to do shell script "basename " &amp; fileNamequoted
set m to (number of characters of contents of baseName)
set dirName to quoted form of (characters 1 thru (n - m - 1) of fileName as string)

set shellScript to "cd " &amp; dirName &amp; ";"
set shellScript to shellScript &amp; "~/Library/TeXShop/bin/pdflatexc  " &amp; baseName
do shell script shellScript

tell document frontName of application "TeXShop"
	refreshpdf
end tell
</string>
					<key>key</key>
					<string></string>
					<key>name</key>
					<string>pdflatexc</string>
				</dict>
				<dict>
					<key>content</key>
					<string></string>
					<key>key</key>
					<string></string>
					<key>name</key>
					<string>Separator</string>
				</dict>
				<dict>
					<key>content</key>
					<string>--AppleScript
-- Apply only to an already saved file
-- Claus Gerhardt, Nov. 2003

-- In the first dialog enter the number of pdf files you want to create.
-- In each of the following dialogs enter your selection of pages like
-- 3:4,6,8:12 This would be the selection for one output file
-- It would contain the pages 3-4, 6, and 8-12

set fileName to  #NAMEPATH#
set n to (number of characters of contents of fileName)
set fileNamequoted to quoted form of fileName
set baseName to do shell script "basename " &amp; fileNamequoted
set m to (number of characters of contents of baseName)
set dirName to quoted form of (characters 1 thru (n - m - 1) of fileName as string)

set dialogName to "The original file is " &amp; fileNamequoted &amp; ".pdf. How many files do you want?"
activate
set k to the text returned of (display dialog dialogName default answer "" buttons {"Cancel", "Next"} default button "Next") as number
set dialogSelection to "Your selection for  file # 1. The file will be saved as " &amp; baseName &amp; "-1.pdf."
set i to 1 as number

set input to the text returned of (display dialog dialogSelection default answer "" buttons {"Cancel", "Next"} default button "Next")

repeat while i ≤ k - 1
set j to i + 1 as number
set selectionName to "Selection for file #" &amp; j &amp; ". The file will be saved as " &amp; baseName &amp; "-" &amp; j &amp; ".pdf."
set input to input &amp; " " &amp; the text returned of (display dialog selectionName default answer "" buttons {"Cancel", "Next"} default button "Next")
set i to i + 1
end repeat

set input to input &amp; " " &amp; baseName

set shellScript to "cd " &amp; dirName &amp; ";"
set shellScript to shellScript &amp; "~/Library/TeXShop/bin/pdfselectc  " &amp; input
do shell script shellScript


</string>
					<key>key</key>
					<string></string>
					<key>name</key>
					<string>pdfselectc</string>
				</dict>
				<dict>
					<key>content</key>
					<string></string>
					<key>key</key>
					<string></string>
					<key>name</key>
					<string>Separator</string>
				</dict>
				<dict>
					<key>content</key>
					<string>--Applescript
-- Apply only to an already saved file.


set thePDF to  #PDFPATH#
set pdfFile to alias POSIX file thePDF
  tell application "TeXShop"
    activate
  open pdfFile
  end tell
</string>
					<key>key</key>
					<string></string>
					<key>name</key>
					<string>openpdf</string>
				</dict>
				<dict>
					<key>content</key>
					<string></string>
					<key>key</key>
					<string></string>
					<key>name</key>
					<string>Separator</string>
				</dict>
				<dict>
					<key>content</key>
					<string>--Applescript
-- Apply only to an already saved file
-- Claus Gerhardt, Nov. 2003


set scriptPath to (do shell script "dirname " &amp; "~/Library/TeXShop/Scripts/ex")
set scriptPath to scriptPath &amp; "/setname.scpt"
set scriptName to POSIX file scriptPath as alias
set scriptLiB to (load script scriptName)
tell scriptLib
set frontName to setname(#NAMEPATH#,#TEXPATH#)
end tell

set fileName to  #NAMEPATH#
set n to (number of characters of contents of fileName)
set fileNamequoted to quoted form of fileName
set baseName to do shell script "basename " &amp; fileNamequoted
set m to (number of characters of contents of baseName)
set dirName to quoted form of (characters 1 thru (n - m - 1) of fileName as string)
set texName to baseName &amp; ".tex"

set shellScript to "cd " &amp; dirName &amp; ";"
set shellScript to shellScript &amp; "~/Library/TeXShop/bin/pdflatexc  " &amp; texName
do shell script shellScript

set shellScript to "cd " &amp; dirName &amp; ";"
set shellScript to shellScript &amp; "~/Library/TeXShop/bin/makeindexk  " &amp; baseName
do shell script shellScript

set shellScript to "cd " &amp; dirName &amp; ";"
set shellScript to shellScript &amp; "~/Library/TeXShop/bin/mpostc  " &amp; baseName
do shell script shellScript

set fileLog to fileName &amp; ".log"
set theFile to alias (POSIX file fileLog)
set logName to baseName &amp;".log"

tell application "TeXShop"
open theFile
end tell

tell document logName of application "TeXShop"
refreshtext
end tell

set shellScript to "cd " &amp; dirName &amp; ";"
set shellScript to shellScript &amp; "~/Library/TeXShop/bin/pdflatexc  " &amp; texName
do shell script shellScript

tell document frontName of application "TeXShop"
refreshpdf
end tell


</string>
					<key>key</key>
					<string></string>
					<key>name</key>
					<string>latex-makeindex-mpost</string>
				</dict>
			</array>
		</dict>
		<dict>
			<key>content</key>
			<string></string>
			<key>key</key>
			<string></string>
			<key>name</key>
			<string>Separator</string>
		</dict>
		<dict>
			<key>content</key>
			<string></string>
			<key>key</key>
			<string></string>
			<key>name</key>
			<string>Headings</string>
			<key>submenu</key>
			<array>
				<dict>
					<key>content</key>
					<string></string>
					<key>key</key>
					<string></string>
					<key>name</key>
					<string>11pt</string>
					<key>submenu</key>
					<array>
						<dict>
							<key>content</key>
							<string>\documentclass[11pt]{article}
\begin{document}

\title{#INS#}
\author{}
\date{}
\maketitle


\end{document}
</string>
							<key>key</key>
							<string></string>
							<key>name</key>
							<string>article</string>
						</dict>
						<dict>
							<key>content</key>
							<string>\documentclass[11pt]{book}
\begin{document}

\title{#INS#}
\author{}
\date{}
\maketitle


\end{document}
</string>
							<key>key</key>
							<string></string>
							<key>name</key>
							<string>book</string>
						</dict>
						<dict>
							<key>content</key>
							<string>\documentclass[11pt]{report}
\begin{document}

\title{#INS#}
\author{}
\date{}
\maketitle


\end{document}
</string>
							<key>key</key>
							<string></string>
							<key>name</key>
							<string>report</string>
						</dict>
					</array>
				</dict>
				<dict>
					<key>content</key>
					<string></string>
					<key>key</key>
					<string></string>
					<key>name</key>
					<string>12pt</string>
					<key>submenu</key>
					<array>
						<dict>
							<key>content</key>
							<string>\documentclass[12pt]{article}
\begin{document}

\title{#INS#}
\author{}
\date{}
\maketitle


\end{document}
</string>
							<key>key</key>
							<string></string>
							<key>name</key>
							<string>article</string>
						</dict>
						<dict>
							<key>content</key>
							<string>\documentclass[12pt]{book}
\begin{document}

\title{#INS#}
\author{}
\date{}
\maketitle


\end{document}
</string>
							<key>key</key>
							<string></string>
							<key>name</key>
							<string>book</string>
						</dict>
						<dict>
							<key>content</key>
							<string>\documentclass[12pt]{report}
\begin{document}

\title{#INS#}
\author{}
\date{}
\maketitle


\end{document}
</string>
							<key>key</key>
							<string></string>
							<key>name</key>
							<string>report</string>
						</dict>
					</array>
				</dict>
			</array>
		</dict>
		<dict>
			<key>content</key>
			<string></string>
			<key>key</key>
			<string></string>
			<key>name</key>
			<string>Subdivisions</string>
			<key>submenu</key>
			<array>
				<dict>
					<key>content</key>
					<string>\chapter{#SEL##INS#}
</string>
					<key>key</key>
					<string></string>
					<key>name</key>
					<string>chapter</string>
				</dict>
				<dict>
					<key>content</key>
					<string>\paragraph{#SEL##INS#}
</string>
					<key>key</key>
					<string></string>
					<key>name</key>
					<string>paragraph</string>
				</dict>
				<dict>
					<key>content</key>
					<string>\subparagraph{#SEL##INS#}
</string>
					<key>key</key>
					<string></string>
					<key>name</key>
					<string>subparagraph</string>
				</dict>
				<dict>
					<key>content</key>
					<string>\section{#SEL##INS#}
</string>
					<key>key</key>
					<string></string>
					<key>name</key>
					<string>section</string>
				</dict>
				<dict>
					<key>content</key>
					<string>\subsection{#SEL##INS#}
</string>
					<key>key</key>
					<string></string>
					<key>name</key>
					<string>subsection</string>
				</dict>
				<dict>
					<key>content</key>
					<string>\subsubsection{#SEL##INS#}
</string>
					<key>key</key>
					<string></string>
					<key>name</key>
					<string>subsubsection</string>
				</dict>
			</array>
		</dict>
		<dict>
			<key>content</key>
			<string></string>
			<key>key</key>
			<string></string>
			<key>name</key>
			<string>Mathematics</string>
			<key>submenu</key>
			<array>
				<dict>
					<key>content</key>
					<string>\[
\left(
\begin{array}{ccc}
  &amp;   &amp;   \\
  &amp;   &amp;   \\
  &amp;   &amp;   
\end{array}
\right)
\]
</string>
					<key>key</key>
					<string></string>
					<key>name</key>
					<string>array</string>
				</dict>
				<dict>
					<key>content</key>
					<string>\begin{equation}
#INS#
\end{equation}
</string>
					<key>key</key>
					<string></string>
					<key>name</key>
					<string>equation</string>
				</dict>
				<dict>
					<key>content</key>
					<string>\begin{equation*}
#INS#
\end{equation*}
</string>
					<key>key</key>
					<string></string>
					<key>name</key>
					<string>equation*</string>
				</dict>
				<dict>
					<key>content</key>
					<string>\begin{eqnarray}
#INS#
\end{eqnarray}
</string>
					<key>key</key>
					<string></string>
					<key>name</key>
					<string>eqnarray</string>
				</dict>
				<dict>
					<key>content</key>
					<string>\begin{eqnarray*}
#INS#
\end{eqnarray*}
</string>
					<key>key</key>
					<string></string>
					<key>name</key>
					<string>eqnarray*</string>
				</dict>
			</array>
		</dict>
		<dict>
			<key>content</key>
			<string></string>
			<key>key</key>
			<string></string>
			<key>name</key>
			<string>Text Styles</string>
			<key>submenu</key>
			<array>
				<dict>
					<key>content</key>
					<string>\emph{#SEL##INS#}</string>
					<key>key</key>
					<string></string>
					<key>name</key>
					<string>emphasize</string>
				</dict>
				<dict>
					<key>content</key>
					<string></string>
					<key>key</key>
					<string></string>
					<key>name</key>
					<string>typeface</string>
					<key>submenu</key>
					<array>
						<dict>
							<key>content</key>
							<string>\mathbf{#SEL##INS#}</string>
							<key>key</key>
							<string></string>
							<key>name</key>
							<string>Bold</string>
						</dict>
						<dict>
							<key>content</key>
							<string>\mathcal{#SEL##INS#}</string>
							<key>key</key>
							<string></string>
							<key>name</key>
							<string>CAL</string>
						</dict>
						<dict>
							<key>content</key>
							<string>\mathit{#SEL##INS#}</string>
							<key>key</key>
							<string></string>
							<key>name</key>
							<string>Italic</string>
						</dict>
						<dict>
							<key>content</key>
							<string>\mathrm{#SEL##INS#}</string>
							<key>key</key>
							<string></string>
							<key>name</key>
							<string>Roman</string>
						</dict>
						<dict>
							<key>content</key>
							<string>\mathsf{#SEL##INS#}</string>
							<key>key</key>
							<string></string>
							<key>name</key>
							<string>Sans Serif</string>
						</dict>
						<dict>
							<key>content</key>
							<string>\mathtt{#SEL##INS#}</string>
							<key>key</key>
							<string></string>
							<key>name</key>
							<string>TypeWriter</string>
						</dict>
					</array>
				</dict>
				<dict>
					<key>content</key>
					<string></string>
					<key>key</key>
					<string></string>
					<key>name</key>
					<string>size</string>
					<key>submenu</key>
					<array>
						<dict>
							<key>content</key>
							<string>{\tiny #SEL##INS#}</string>
							<key>key</key>
							<string></string>
							<key>name</key>
							<string>tiny</string>
						</dict>
						<dict>
							<key>content</key>
							<string>{\scriptsize #SEL##INS#}</string>
							<key>key</key>
							<string></string>
							<key>name</key>
							<string>scriptsize</string>
						</dict>
						<dict>
							<key>content</key>
							<string>{\footnotesize #SEL##INS#}</string>
							<key>key</key>
							<string></string>
							<key>name</key>
							<string>footnotesize</string>
						</dict>
						<dict>
							<key>content</key>
							<string>{\small #SEL##INS#}</string>
							<key>key</key>
							<string></string>
							<key>name</key>
							<string>small</string>
						</dict>
						<dict>
							<key>content</key>
							<string>{\normalsize #SEL##INS#}</string>
							<key>key</key>
							<string></string>
							<key>name</key>
							<string>normalsize</string>
						</dict>
						<dict>
							<key>content</key>
							<string>{\large #SEL##INS#}</string>
							<key>key</key>
							<string></string>
							<key>name</key>
							<string>large</string>
						</dict>
						<dict>
							<key>content</key>
							<string>{\Large #SEL##INS#}</string>
							<key>key</key>
							<string></string>
							<key>name</key>
							<string>Large</string>
						</dict>
						<dict>
							<key>content</key>
							<string>{\LARGE #SEL##INS#}</string>
							<key>key</key>
							<string></string>
							<key>name</key>
							<string>LARGE</string>
						</dict>
						<dict>
							<key>content</key>
							<string>{\huge #SEL##INS#}</string>
							<key>key</key>
							<string></string>
							<key>name</key>
							<string>huge</string>
						</dict>
						<dict>
							<key>content</key>
							<string>{\Huge #SEL##INS#}</string>
							<key>key</key>
							<string></string>
							<key>name</key>
							<string>Huge</string>
						</dict>
					</array>
				</dict>
				<dict>
					<key>content</key>
					<string></string>
					<key>key</key>
					<string></string>
					<key>name</key>
					<string>style</string>
					<key>submenu</key>
					<array>
						<dict>
							<key>content</key>
							<string>\textbf{#SEL##INS#}</string>
							<key>key</key>
							<string></string>
							<key>name</key>
							<string>Bold</string>
						</dict>
						<dict>
							<key>content</key>
							<string>\textsc{#SEL##INS#}</string>
							<key>key</key>
							<string></string>
							<key>name</key>
							<string>Small Caps</string>
						</dict>
						<dict>
							<key>content</key>
							<string>\textmd{#SEL##INS#}</string>
							<key>key</key>
							<string></string>
							<key>name</key>
							<string>Medium</string>
						</dict>
						<dict>
							<key>content</key>
							<string>\textit{#SEL##INS#}</string>
							<key>key</key>
							<string></string>
							<key>name</key>
							<string>Italic</string>
						</dict>
						<dict>
							<key>content</key>
							<string>\textsl{#SEL##INS#}</string>
							<key>key</key>
							<string></string>
							<key>name</key>
							<string>Slanted</string>
						</dict>
						<dict>
							<key>content</key>
							<string>\textrm{#SEL##INS#}</string>
							<key>key</key>
							<string></string>
							<key>name</key>
							<string>Roman</string>
						</dict>
						<dict>
							<key>content</key>
							<string>\textsf{#SEL##INS#}</string>
							<key>key</key>
							<string></string>
							<key>name</key>
							<string>Sans Serif</string>
						</dict>
						<dict>
							<key>content</key>
							<string>\texttt{#SEL##INS#}</string>
							<key>key</key>
							<string></string>
							<key>name</key>
							<string>TypeWriter</string>
						</dict>
						<dict>
							<key>content</key>
							<string>\textup{#SEL##INS#}</string>
							<key>key</key>
							<string></string>
							<key>name</key>
							<string>Upright</string>
						</dict>
					</array>
				</dict>
				<dict>
					<key>content</key>
					<string>\underline{#SEL##INS#}</string>
					<key>key</key>
					<string></string>
					<key>name</key>
					<string>Underline</string>
				</dict>
			</array>
		</dict>
		<dict>
			<key>content</key>
			<string></string>
			<key>key</key>
			<string></string>
			<key>name</key>
			<string>Lists</string>
			<key>submenu</key>
			<array>
				<dict>
					<key>content</key>
					<string>\begin{description}
\item[ ] #SEL##INS#
\end{description}
</string>
					<key>key</key>
					<string></string>
					<key>name</key>
					<string>description</string>
				</dict>
				<dict>
					<key>content</key>
					<string>\begin{enumerate}
\item #SEL##INS#
\end{enumerate}
</string>
					<key>key</key>
					<string></string>
					<key>name</key>
					<string>enumerate</string>
				</dict>
				<dict>
					<key>content</key>
					<string>\begin{itemize}
\item #SEL##INS#
\end{itemize}
</string>
					<key>key</key>
					<string></string>
					<key>name</key>
					<string>itemize</string>
				</dict>
			</array>
		</dict>
		<dict>
			<key>content</key>
			<string></string>
			<key>key</key>
			<string></string>
			<key>name</key>
			<string>Offsets</string>
			<key>submenu</key>
			<array>
				<dict>
					<key>content</key>
					<string>\footnote{#SEL##INS#}</string>
					<key>key</key>
					<string></string>
					<key>name</key>
					<string>footnote</string>
				</dict>
				<dict>
					<key>content</key>
					<string>\marginpar{#SEL##INS#}</string>
					<key>key</key>
					<string></string>
					<key>name</key>
					<string>marginpar</string>
				</dict>
			</array>
		</dict>
		<dict>
			<key>content</key>
			<string></string>
			<key>key</key>
			<string></string>
			<key>name</key>
			<string>Insertions</string>
			<key>submenu</key>
			<array>
				<dict>
					<key>content</key>
					<string>\begin{quotation}
#SEL##INS#
\end{quotation}</string>
					<key>key</key>
					<string></string>
					<key>name</key>
					<string>quotation</string>
				</dict>
				<dict>
					<key>content</key>
					<string>\begin{quote}
#SEL##INS#
\end{quote}</string>
					<key>key</key>
					<string></string>
					<key>name</key>
					<string>quote</string>
				</dict>
				<dict>
					<key>content</key>
					<string>\begin{verbatim}
#SEL##INS#
\end{verbatim}
</string>
					<key>key</key>
					<string></string>
					<key>name</key>
					<string>verbatim</string>
				</dict>
				<dict>
					<key>content</key>
					<string>\begin{verse}
#SEL##INS#
\end{verse}</string>
					<key>key</key>
					<string></string>
					<key>name</key>
					<string>verse</string>
				</dict>
			</array>
		</dict>
		<dict>
			<key>content</key>
			<string></string>
			<key>key</key>
			<string></string>
			<key>name</key>
			<string>Tables</string>
			<key>submenu</key>
			<array>
				<dict>
					<key>content</key>
					<string>\hline</string>
					<key>key</key>
					<string></string>
					<key>name</key>
					<string>hline</string>
				</dict>
				<dict>
					<key>content</key>
					<string>\begin{table}[htdp]
\caption{default}
\begin{center}
\begin{tabular}{|c|c|}
#SEL##INS#
\end{tabular}
\end{center}
\label{default}
\end{table}%
</string>
					<key>key</key>
					<string></string>
					<key>name</key>
					<string>table</string>
				</dict>
			</array>
		</dict>
		<dict>
			<key>content</key>
			<string></string>
			<key>key</key>
			<string></string>
			<key>name</key>
			<string>Figures</string>
			<key>submenu</key>
			<array>
				<dict>
					<key>content</key>
					<string>\begin{figure}[htbp]
\begin{center}
#SEL##INS#
\caption{default}
\label{default}
\end{center}
\end{figure}
</string>
					<key>key</key>
					<string></string>
					<key>name</key>
					<string>regular</string>
				</dict>
				<dict>
					<key>content</key>
					<string>\begin{figure}[htbp]
\begin{center}
\epsfile{file=#SEL##INS#,scale=0.8}
\caption{{\bf default}}
\label{default}
\end{center}
\end{figure}
</string>
					<key>key</key>
					<string></string>
					<key>name</key>
					<string>epsfile</string>
				</dict>
			</array>
		</dict>
	</array>
</dict>
</plist>
