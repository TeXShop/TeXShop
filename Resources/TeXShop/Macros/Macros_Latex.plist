<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE plist PUBLIC "-//Apple//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd">
<plist version="1.0">
<dict>
	<key>name</key>
	<string>ROOT</string>
	<key>submenu</key>
	<array>
		<dict>
			<key>name</key>
			<string>Applescript</string>
			<key>submenu</key>
			<array>
				<dict>
					<key>content</key>
					<string>--AppleScript direct

tell application "Adobe Reader"
  activate
  open POSIX file #PDFPATH#
end tell
</string>
					<key>name</key>
					<string>View pdf with Acrobat</string>
				</dict>
				<dict>
					<key>content</key>
					<string>--AppleScript direct
-- #FILEPATH# in the text will be replaced by the path of the document
-- #DVIPATH#, #PSPATH#, #PDFPATH# are also replaced by the paths of .dvi, .ps, .dvi files.  
-- to use the path in Finder, use (alias POSIX file filepath)
-- example: show tex and pdf files in Finder

try
tell application "Finder"
  activate
  reveal {alias POSIX file #FILEPATH#, alias POSIX file #PDFPATH#}
end tell
on error
end try</string>
					<key>name</key>
					<string>Show files</string>
				</dict>
				<dict>
					<key>content</key>
					<string>--AppleScript direct
-- If the content field starts with "--AppleScript" then it will be interpreted as an AppleScript and will be executed.  
-- example: show TeXShop home page in a web browser

open location "http://darkwing.uoregon.edu/~koch/texshop/texshop.html"</string>
					<key>name</key>
					<string>TeXShop home page</string>
				</dict>
				<dict>
					<key>content</key>
					<string>--AppleScript direct
-- If the content field starts with "--AppleScript" then it will be interpreted as an AppleScript and will be executed.  

open location "http://tug.org/mactex/"</string>
					<key>name</key>
					<string>MacTeX home page</string>
				</dict>
				<dict>
					<key>content</key>
					<string>--Applescript direct

-- OPEN TeXLive FILE
-- Type the name of a file in the TeXLive tree, for example "geometry.sty". This macro will find it and open it.

set q1 to display dialog "Open TeX File" &amp; return &amp; return &amp; "Enter the name, including extension, of the TeX file you want to open." default answer "" buttons {"Cancel", "Open"} default button "Open"
set filename_to_open to the text returned of q1

try
	set file_path to do shell script "/usr/texbin/kpsewhich " &amp; filename_to_open
	set theFile to alias (POSIX file file_path)
	tell application "TeXShop"
		activate
		open theFile
	end tell
on error
	display dialog ("There don't seem to be any files in the teTeX tree with the filename: " &amp; filename_to_open) buttons {"OK"} default button "OK"
end try
</string>
					<key>name</key>
					<string>View TeX Live file</string>
				</dict>
				<dict>
					<key>content</key>
					<string>--Applescript direct
-- If front file is named "Test.tex", write a copy as "Test_Mac.tex", changing all line feeds to
-- Macintosh Classic line feeds

set fileName to  #NAMEPATH#
set n to (number of characters of contents of fileName)
set fileNamequoted to quoted form of fileName
set baseName to do shell script "basename " &amp; fileNamequoted
set m to (number of characters of contents of baseName)
set dirName to quoted form of (characters 1 thru (n - m - 1) of fileName as string)
set texName to baseName &amp; ".tex"
set backupTexName to baseName &amp; "_Mac.tex"

set shellScript to  "cd " &amp; dirName &amp; ";"
set shellScript to shellScript &amp; "cp  " &amp; texName &amp;" " &amp; backupTexName &amp;";"
set shellScript to shellScript &amp; "/bin/tcsh -c '~/Library/TeXShop/bin/flip -m  " &amp; backupTexName &amp; "'"
do shell script shellScript


</string>
					<key>name</key>
					<string>Convert to MAC</string>
				</dict>
				<dict>
					<key>content</key>
					<string>--Applescript direct
-- If front file is named "Test.tex", write a copy as "Test_Unix.tex", changing all line feeds to
-- Unix line feeds

set fileName to  #NAMEPATH#
set n to (number of characters of contents of fileName)
set fileNamequoted to quoted form of fileName
set baseName to do shell script "basename " &amp; fileNamequoted
set m to (number of characters of contents of baseName)
set dirName to quoted form of (characters 1 thru (n - m - 1) of fileName as string)
set texName to baseName &amp; ".tex"
set backupTexName to baseName &amp; "_Unix.tex"

set shellScript to  "cd " &amp; dirName &amp; ";"
set shellScript to shellScript &amp; "cp  " &amp; texName &amp;" " &amp; backupTexName &amp;";"
set shellScript to shellScript &amp; "/bin/tcsh -c '~/Library/TeXShop/bin/flip -u  " &amp; backupTexName &amp; "'"
do shell script shellScript
</string>
					<key>name</key>
					<string>Convert to Unix</string>
				</dict>
				<dict>
					<key>content</key>
					<string>--Applescript direct
-- If front file is named "Test.tex", write a copy as "Test_Windows.tex", changing all line feeds to
-- Windows line feeds

set fileName to  #NAMEPATH#
set n to (number of characters of contents of fileName)
set fileNamequoted to quoted form of fileName
set baseName to do shell script "basename " &amp; fileNamequoted
set m to (number of characters of contents of baseName)
set dirName to quoted form of (characters 1 thru (n - m - 1) of fileName as string)
set texName to baseName &amp; ".tex"
set backupTexName to baseName &amp; "_Windows.tex"

set shellScript to  "cd " &amp; dirName &amp; ";"
set shellScript to shellScript &amp; "cp  " &amp; texName &amp;" " &amp; backupTexName &amp;";"
set shellScript to shellScript &amp; "/bin/tcsh -c '~/Library/TeXShop/bin/flip -d  " &amp; backupTexName &amp; "'"
do shell script shellScript
</string>
					<key>name</key>
					<string>Convert to Windows</string>
				</dict>
				<dict>
					<key>content</key>
					<string>--Applescript

set fileName to #FILEPATH#
if fileName is equal to  ""
activate
display dialog "Please save the file first"  buttons {"OK"} default button "OK"
return
end if

set frontName to #DOCUMENTNAME#

tell document frontName of application "TeXShop"

	latexinteractive

	repeat
		delay 2
		if taskdone
			exit repeat
		end if
	end repeat

	bibtex

	repeat
		delay 2
		if taskdone
			exit repeat
		end if
	end repeat

	latex

	repeat
		delay 2
		if taskdone
			exit repeat
		end if
	end repeat

	latex

	repeat
		delay 2
		if taskdone
			exit repeat
		end if
	end repeat

end tell

</string>
					<key>name</key>
					<string>Bibliography</string>
				</dict>
				<dict>
					<key>content</key>
					<string>--Applescript direct

--TeXShop restart required for changes to take effect

do shell script "defaults write TeXShop background_R 0.3"
do shell script "defaults write TeXShop background_G 0.3"
do shell script "defaults write TeXShop background_B 0.3"
do shell script "defaults write TeXShop foreground_R 1.0"
do shell script "defaults write TeXShop foreground_G 1.0"
do shell script "defaults write TeXShop foreground_B 1.0"</string>
					<key>name</key>
					<string>Colored source</string>
				</dict>
				<dict>
					<key>content</key>
					<string>--Applescript direct

--TeXShop restart required for changes to take effect

do shell script "defaults write TeXShop background_R 1.00"
do shell script "defaults write TeXShop background_G 1.00"
do shell script "defaults write TeXShop background_B 1.00"
do shell script "defaults write TeXShop foreground_R .0"
do shell script "defaults write TeXShop foreground_G .0"
do shell script "defaults write TeXShop foreground_B .0"</string>
					<key>name</key>
					<string>Default Colored source</string>
				</dict>
			</array>
		</dict>
		<dict>
			<key>name</key>
			<string>Column macros</string>
			<key>submenu</key>
			<array>
				<dict>
					<key>content</key>
					<string>--Applescript direct

-- NEW TABULAR
-- This script inserts a new tabular environment with a user-specified number of rows and columns. You can choose to have a plain table or a booktabs table - for the latter case you need to be using either the Memoir class or the booktabs package. Finally you may choose whether to have the table floating with a caption or simply centred.

-- CUSTOMISE TO YOUR LIKING:

property indent : "  " -- edit this if you want other than 2 spaces for your indent
property cell_text : "• " -- edit this if you want a different text blob

property default_tabular_type: "Booktabs" -- or "Plain"
property default_table_type: "Floating" -- or "Centred"

-- THE SCRIPT:

property texapp : "TeXShop"
tell application texapp
	
	set q1 to display dialog "New tabular" &amp; return &amp; return &amp; "Enter the number of columns you'd like and then select the type of tabular you want." default answer "3" buttons {"Cancel", "Plain", "Booktabs"} default button default_tabular_type
	set NCOLS to the text returned of q1
	set tabtype to the button returned of q1
	
	set q2 to display dialog "Enter the number of rows you'd like (not including a header row) and select whether you'd like a floating or simply centred table." default answer "3" buttons {"Cancel", "Centred", "Floating"} default button default_table_type
	set NROWS to the text returned of q2
	set floattype to the button returned of q2
	
	if the tabtype = "Booktabs" then
		set the toprule to "\\toprule"
		set the midrule to "\\midrule"
		set the bottomrule to "\\bottomrule"
	else
		set the toprule to "\\hline"
		set the midrule to "\\hline"
		set the bottomrule to "\\hline"
	end if
	
	if the floattype = "Floating" then
		set the beforetext to ¬
			"\\begin{table}[htbp]" &amp; return &amp; ¬
			indent &amp; "\\centering" &amp; return &amp; ¬
			indent &amp; "\\begin{tabular}" -- note no carriage return to allow space for the column preamble
		set the aftertext to ¬
			indent &amp; indent &amp; bottomrule &amp; return &amp; ¬
			indent &amp; "\\end{tabular}" &amp; return &amp; ¬
			indent &amp; "\\caption{TableCaption}" &amp; return &amp; ¬
			indent &amp; "\\label{tab:label}" &amp; return &amp; ¬
			"\\end{table}"
	else
		set the beforetext to ¬
			"\\begin{center}" &amp; return &amp; ¬
			indent &amp; "\\begin{tabular}"
		set the aftertext to ¬
			indent &amp; indent &amp; bottomrule &amp; return &amp; ¬
			indent &amp; "\\end{tabular}" &amp; return &amp; ¬
			"\\end{center}"
	end if
	
	set the column_preamble to "{@{} c"
	set the one_row_text to indent &amp; indent &amp; cell_text
	
	if NCOLS &gt; 1 then
		repeat with c from 2 to NCOLS
			set the column_preamble to column_preamble &amp; "c"
			set the one_row_text to one_row_text &amp; "&amp; " &amp; cell_text
		end repeat
	end if
	
	set the column_preamble to column_preamble &amp; " @{}}" &amp; return
	set the one_row_text to one_row_text &amp; "\\\\ "
	
	-- start off with a header row between two rules:
	set the midtext to ¬
		indent &amp; indent &amp; toprule &amp; return &amp; ¬
		one_row_text &amp; return &amp; ¬
		indent &amp; indent &amp; midrule &amp; return
	
	repeat with r from 1 to NROWS
		set the midtext to midtext &amp; one_row_text &amp; return
	end repeat
	
	set alltext to beforetext &amp; column_preamble &amp; midtext &amp; aftertext
	
	if texapp = "TeXShop" then
		tell application "TeXShop" to set the content of the selection of the front document to alltext
	else if texapp = "iTeXMac" then
		--tell application "iTeXMac" to insert alltext in the text of the front document
	end if
	
end tell

-- 2004 Will Robertson
-- (You may do what you like with this script)</string>
					<key>key</key>
					<string>T+ControlKey</string>
					<key>name</key>
					<string>New tabular</string>
				</dict>
				<dict>
					<key>content</key>
					<string>--Applescript direct

-- NEW TABULAR
-- This script inserts a new array environment with a user-specified number of rows and columns. You may choose to indent the array, since you'll be inserting it into a maths environment.

-- CUSTOMISE TO YOUR LIKING:
property indent : "  " -- edit this if you want other than 2 spaces for your indent
property cell_text : "• " -- edit this if you want a different text blob

property default_array_location: "Indent" -- or "Flush left"

-- THE SCRIPT:

property texapp : "TeXShop"
tell application texapp
	
	set q1 to display dialog "New maths array." &amp; return &amp; return &amp; "Enter the number of rows you'd like." default answer "3"
	set NROWS to the text returned of q1
	
	set q2 to display dialog "How many columns would you like? Would you like me to indent the array?" default answer "3" buttons {"Cancel", "Flush left", "Indent"} default button default_array_location
	set NCOLS to the text returned of q2
	set indentyesno to the button returned of q2
	
	if the indentyesno = "Indent" then
		set the preindent to indent
	else
		set the preindent to ""
	end if
	
	set the column_preamble to "{c"
	set the one_row_text to preindent &amp; indent &amp; cell_text
	
	if NCOLS &gt; 1 then
		repeat with c from 2 to NCOLS
			set the column_preamble to column_preamble &amp; "c"
			set the one_row_text to one_row_text &amp; "&amp; " &amp; cell_text
		end repeat
	end if
	
	set the column_preamble to column_preamble &amp; "}" &amp; return
	set the one_row_text to one_row_text &amp; "\\\\ " &amp; return
	
	set midtext to ""
	repeat with r from 1 to NROWS
		set the midtext to midtext &amp; one_row_text
	end repeat
	
	set the beforetext to preindent &amp; "\\begin{array}"
	set the aftertext to preindent &amp; "\\end{array}"
	
	set alltext to beforetext &amp; column_preamble &amp; midtext &amp; aftertext
	
	if texapp = "TeXShop" then
		tell application "TeXShop" to set the content of the selection of the front document to alltext
	else if texapp = "iTeXMac" then
		--tell application "iTeXMac" to insert alltext in the text of the front document
	end if
	
end tell

-- 2004 Will Robertson
-- (You may do what you like with this script)</string>
					<key>key</key>
					<string>A+ControlKey</string>
					<key>name</key>
					<string>New array</string>
				</dict>
				<dict>
					<key>content</key>
					<string>--Applescript direct

-- ADD COLUMN
--Select the tabular/array rows you wish to edit and run the script. The script will insert a new column at the specified location in each row. You'll have to adjust multicolumn rows and the column preamble (eg, the {ccc} part) manually.

-- CUSTOMISE TO YOUR LIKING:
property indent : "  "
property default_button : "After" -- or "Before"
property cell_blob : "•"


--THE SCRIPT:

property texapp : "TeXShop"
tell application texapp
	set q to display dialog "Add column." &amp; return &amp; return &amp; "Please enter the column number before or after which you would like to add a new column." default answer "1" buttons {"Before", "After"} default button default_button
	set add_where to the button returned of q
	set col_num to the text returned of q
	
	if texapp = "TeXShop" then
		tell application "TeXShop" to set tabular to the content of the selection of the front document
	else if texapp = "iTeXMac" then
		--tell application "iTeXMac" to set tabular to (the selection of the text of the front document)
	end if
	
	set new_tabular to ""
	repeat with ii from 1 to the count of the paragraphs of tabular
		
		set this_line to paragraph ii of tabular

		if this_line contains "\\\\" and this_line does not contain "\\multicolumn" then
			
			--Transform "    a &amp; b &amp; c \\" to "a &amp; b &amp; c":
			set trim_line to do shell script ¬
				"echo " &amp; the quoted form of this_line &amp; ¬
				" | sed 's/^[ ^t]*//' | sed 's/\\\\\\\\//'"
			-- "\\\\\\\\" is a TeX newline escaped in both Applescript and the shell
			
			
			set new_col to "&amp; " &amp; cell_blob &amp; " &amp;"
			if add_where = "After" then
				set line_start to do shell script "echo " &amp; the quoted form of trim_line &amp; " | cut -f -" &amp; col_num &amp; " -d '&amp;'"
				set line_end to do shell script "echo " &amp; the quoted form of trim_line &amp; " | cut -f " &amp; col_num + 1 &amp; "- -d '&amp;'"
				if line_end = "" then
					set new_col to "&amp; " &amp; cell_blob &amp; " "
				end if
			else if add_where = "Before" then
				if col_num = "1" then
					set line_start to ""
					set new_col to cell_blob &amp; " &amp; "
					set line_end to trim_line
				else
					set line_start to do shell script "echo " &amp; the quoted form of trim_line &amp; " | cut -f -" &amp; col_num - 1 &amp; " -d '&amp;'"
					set line_end to do shell script "echo " &amp; the quoted form of trim_line &amp; " | cut -f " &amp; col_num &amp; "- -d '&amp;'"
					if line_end = "" then
						set new_col to "&amp; " &amp; cell_blob &amp; " "
					end if
				end if
			end if
			
			set new_line to indent &amp; indent &amp; line_start &amp; new_col &amp; line_end &amp; "\\\\"
			if new_tabular = "" then
				set new_tabular to new_line
			else
				set new_tabular to new_tabular &amp; return &amp; new_line
			end if
		else
			if new_tabular = "" then
				set new_tabular to this_line
			else
				set new_tabular to new_tabular &amp; return &amp; this_line
			end if
		end if
		
	end repeat
	
	if tabular contains "\\multicolumn" then
		display dialog "I cannot parse lines with “\\multicolumn” in them. You'll have to do them by hand. Sorry." buttons {"Cancel", "Proceed"} default button "Proceed" with icon caution
	end if
	
	if texapp = "TeXShop" then
		tell application "TeXShop" to set the selection of the front document to new_tabular
	else if texapp = "iTeXMac" then
		--tell application "iTeXMac" to insert new_tabular in the text of the front document
	end if
	
	display dialog "Don't forget to add a column to the column header!" buttons {"•"} giving up after 2
	
end tell

-- 2004 Will Robertson
-- (You may do what you like with this script)</string>
					<key>name</key>
					<string>Add column</string>
				</dict>
				<dict>
					<key>content</key>
					<string>--Applescript direct

-- DELETE COLUMN
--Select the tabular/array rows you wish to edit and run the script. The script will delete the specified column from each row (after a confirmation). You'll have to adjust multicolumn rows and the column preamble (eg, the {ccc} part) manually.

-- CUSTOMISE TO YOUR LIKING:
property indent : "  "
property warn_before_delete: true

-- THE SCRIPT:

property texapp : "TeXShop"
tell application texapp
	
	set q to display dialog "Delete column." &amp; return &amp; return &amp; "Please enter the number of the column you would like to delete." default answer "1" buttons {"Cancel", "Delete"} default button "Delete"
	set col_num to the text returned of q

	if texapp = "TeXShop" then
		tell application "TeXShop" to set tabular to the content of the selection of the front document
	else if texapp = "iTeXMac" then
		--tell application "iTeXMac" to set tabular to (the selection of the text of the front document)
	end if
	
	if tabular = "" then
		display dialog "Nothing selected. Please select the tabular/array rows you wish to edit." buttons "Cancel" default button 1
	end if
	
	set sample_value to ""
	set new_tabular to ""
	repeat with ii from 1 to the count of the paragraphs of tabular
		
		set this_line to paragraph ii of tabular
		
		if this_line contains "\\\\" and this_line does not contain "\\multicolumn" then
			-- note "\\\\" means \\ because the backslashes are escaped
			
			--Transform "    a &amp; b &amp; c \\" to "a &amp; b &amp; c":
			set trim_line to do shell script ¬
				"echo " &amp; the quoted form of this_line &amp; ¬
				" | sed 's/^[ ^t]*//' | sed 's/\\\\\\\\//'"
			-- "\\\\\\\\" is a TeX newline escaped in both Applescript and the shell
			
			set new_col to "&amp;"
			if sample_value = "" then
				set sample_value to do shell script "echo " &amp; the quoted form of trim_line &amp; " | cut -f " &amp; col_num &amp; "-" &amp; col_num &amp; " -d '&amp;'"
			end if
			if col_num = "1" then
				set line_start to ""
				set line_end to do shell script "echo " &amp; the quoted form of trim_line &amp; " | cut -f " &amp; col_num + 1 &amp; "- -d '&amp;'"
				set new_col to ""
			else
				set line_start to do shell script "echo " &amp; the quoted form of trim_line &amp; " | cut -f -" &amp; col_num - 1 &amp; " -d '&amp;'"
				set line_end to do shell script "echo " &amp; the quoted form of trim_line &amp; " | cut -f " &amp; col_num + 1 &amp; "- -d '&amp;'"
				if line_end = "" then
					set new_col to ""
				end if
			end if
			
			
			set new_line to indent &amp; indent &amp; line_start &amp; new_col &amp; line_end &amp; "\\\\"
			if new_tabular = "" then
				set new_tabular to new_line
			else
				set new_tabular to new_tabular &amp; return &amp; new_line
			end if
		else
			if new_tabular = "" then
				set new_tabular to this_line
			else
				set new_tabular to new_tabular &amp; return &amp; this_line
			end if
		end if
		
	end repeat
	
	if warn_before_delete then
		display dialog "Are you sure you want to delete the column that begins with “" &amp; sample_value &amp; "”?" buttons {"Cancel", "Delete"} default button "Delete"
	end if
	
	if tabular contains "\\multicolumn" then
		display dialog "I cannot parse lines with “\\multicolumn” in them. You'll have to do them by hand. Sorry." buttons {"Cancel", "Proceed"} default button "Proceed" with icon caution
	end if
	
	if texapp = "TeXShop" then
		tell application "TeXShop" to set the selection of the front document to new_tabular
	else if texapp = "iTeXMac" then
		--tell application "iTeXMac" to insert new_tabular in the text of the front document
	end if
	
	display dialog "Don't forget to remove a column from the column header!" buttons {"•"} giving up after 2
	
end tell

-- 2004 Will Robertson
-- (You may do what you like with this script)</string>
					<key>name</key>
					<string>Delete column</string>
				</dict>
			</array>
		</dict>
		<dict>
			<key>content</key>
			<string>--Applescript

-- "INSERT REFERENCE"
-- This script searches through the current file (or within every file in the current folder) for \label{...} commands, then pops up a list for you to choose from which you may insert one.
--The inserted reference label is wrapped in a (optional) customisable LaTeX command.
-- It will cut down the list to include only those entries that contain the current selection. So if you type "sec" and select it, then run this script, you will get a choice of only, e.g., "sec:intro","sec:conc","fig:secunia", but not other labels in your document e.g., "cha:monkey","equ:maxwell",etc. 

-- v2004-08-24


-- CUSTOMISE TO YOUR LIKING:

property ref_command : "ref" -- or "vref" or "fref" etc... N.B. no backslash!
-- Inserts e.g. "\ref{fig:ladle}" or "\vref{fig:ladle}" or ... based on this property
-- Put "" to insert the plain label: e.g. "fig:ladle" 

property only_scan_current_file : true
-- If false, the script will search through every .tex file in the folder containing the current file.
-- This is useful for projects with other \include{} -ed files in the same folder.
-- Otherwise, it will only look in the current file.

property sort_output : false
-- If false, displays labels in the order they're found in the document.
-- Otherwise, displays them in alphabetical order.

property save_before_run : true
-- The script only finds labels created in saved documents. If you don't want this script to save your document before it runs for whatever reason, set this to true.

--THE SCRIPT:


if save_before_run then
	tell application "TeXShop" to save the front document
end if

tell application "TeXShop" to set texpath to the path of the front document -- the current tex file: "/path/to/docu.tex"

if only_scan_current_file then
	set texfiles_tosearch to the quoted form of the texpath -- search the current file
else
	set texloc to POSIX file texpath -- Convert to applescript format: "path:to:docu.tex"
	tell application "Finder" to set texfolder to the container of (texloc as alias) -- Get the folder: "path:to:"
	set texdir to the POSIX path of (texfolder as alias) -- Convert to UNIX path: "/path/to"
	set texfiles_tosearch to the quoted form of texdir &amp; "*.tex" -- search all .tex files: "/path/to/*.tex"
end if

tell application "TeXShop"
	
	set current_selection to the content of the selection of the front document
	
	-- DO SHELL SCRIPT COMPONENTS:
	--set find_label_lines to ("grep -h '\\\\label' " &amp; texfiles_tosearch) as string
	set find_label_lines to ("cat " &amp; texfiles_tosearch &amp; " | tr '\\r' '\\n'  | grep '\\\\label{' " &amp; texfiles_tosearch) as string
	-- (Better commmand suggested by Matthew Hills which also converts the line-endings to UNIX form - thanks!)
	set trim_to_raw_labels to " | sed 's/.*\\\\label{//' | sed 's/}.*//'"
	set filter_selection to " | grep " &amp; quoted form of the current_selection
	if sort_output then
		set sort to " | sort -u"
	else
		set sort to ""
	end if
	
	-- glue the shell scripts together:
	set get_labels_shell_script to find_label_lines &amp; trim_to_raw_labels &amp; sort
	
	try
		-- filter choices with the current selection:
		set choose_labels to every paragraph of (do shell script get_labels_shell_script &amp; filter_selection)
	on error
		-- If it fails (e.g., nothing found) ask to diplay all labels:
		display dialog "No labels found that contain '" &amp; the current_selection &amp; "'. Would you like to view the whole list?" buttons {"Cancel", "View all"} default button "View all"
		if the button returned of the result is "View all" then
			set choose_labels to every paragraph of (do shell script get_labels_shell_script)
		else
			return -- exit script
		end if
	end try
	
	-- In case the document doesn't contain any labels:
	if choose_labels = {""} then
		display dialog "Sorry, no \\label{} items have been found." buttons {"No worries"} default button "No worries"
		return
	end if
	
	set label_insert to choose from list choose_labels with prompt "Please choose the label of the reference to insert:"
	if label_insert ≠ false then
		if ref_command = "" then
			set ref_insert to label_insert
		else
			set ref_insert to "\\" &amp; ref_command &amp; "{" &amp; label_insert &amp; "}"
		end if
		set the selection of the front document to ref_insert as string
	end if
	
end tell</string>
			<key>key</key>
			<string>R+ShiftKey</string>
			<key>name</key>
			<string>Insert reference</string>
		</dict>
		<dict>
			<key>content</key>
			<string>-- Applescript direct

-- OPEN QUICKLY...
-- The idea for this script was stolen from iTeXMac.
-- This script pops up a dialog box with a list of  files in the current directory.
-- The selection (multiple allowed) is opened.

-- CUSTOMISE TO YOUR LIKING:
property extensions_to_open : {"tex", "sty", "pdf"}


-- THE SCRIPT:

--get the path to the current tex file - "/path/to/docu.tex":
tell application "TeXShop" to set texpath to the path of the front document

-- Convert to applescript format - "path:to:docu.tex"
set texloc to POSIX file texpath
-- Get the folder it's in - "path:to:"
tell application "Finder" to set texfolder to the container of (texloc as alias)
-- Get the path to the folder - "/path/to/"
set texdir to the POSIX path of (texfolder as alias)
-- Get a list of all the filenames to open:
set texfiles to the name of every file of texfolder whose name extension is in extensions_to_open

tell application "TeXShop" to set openfiles to choose from list texfiles with prompt "Which file(s) do you wish to open?" with multiple selections allowed
if openfiles is not false then
	repeat with this_filename in openfiles
		set file_to_open to POSIX file (texdir &amp; this_filename)
		tell application "TeXShop" to open file_to_open
	end repeat
end if</string>
			<key>key</key>
			<string>O+ShiftKey</string>
			<key>name</key>
			<string>Open quickly…</string>
		</dict>
		<dict>
			<key>name</key>
			<string>Claus Gerhardt Macros</string>
			<key>submenu</key>
			<array>
				<dict>
					<key>content</key>
					<string>--Applescript
-- Apply only to an already saved file
-- Claus Gerhardt, Nov. 2003

set scriptPath to (do shell script "dirname " &amp; "~/Library/TeXShop/Scripts/ex")
set scriptPath to scriptPath &amp; "/setname.scpt"
set scriptName to POSIX file scriptPath as alias
set scriptLiB to (load script scriptName)
tell scriptLib
set frontName to setname(#NAMEPATH#,#TEXPATH#)
end tell

set fileName to  #NAMEPATH#
set n to (number of characters of contents of fileName)
set fileNamequoted to quoted form of fileName
set baseName to do shell script "basename " &amp; fileNamequoted
set m to (number of characters of contents of baseName)
set dirName to quoted form of (characters 1 thru (n - m - 1) of fileName as string)
set texName to baseName &amp; ".tex"

set shellScript to "cd " &amp; dirName &amp; ";"
set shellScript to shellScript &amp; "~/Library/TeXShop/bin/bibtexc  " &amp; baseName
do shell script shellScript

set shellScript to "cd " &amp; dirName &amp; ";"
set shellScript to shellScript &amp; "~/Library/TeXShop/bin/pdflatexc  " &amp; texName
do shell script shellScript

set shellScript to "cd " &amp; dirName &amp; ";"
set shellScript to shellScript &amp; "~/Library/TeXShop/bin/pdflatexc  " &amp; texName
do shell script shellScript


set fileLog to fileName &amp; ".blg"
set theFile to alias (POSIX file fileLog)
set logName to baseName &amp;".blg"

tell document frontName of application "TeXShop"
refreshpdf
end tell

tell application "TeXShop"
open theFile
end tell

tell document logName of application "TeXShop"
refreshtext
end tell




</string>
					<key>name</key>
					<string>bibtexc</string>
				</dict>
				<dict>
					<key>content</key>
					<string>--Applescript
-- Apply only to an already saved file
-- Claus Gerhardt, Nov. 2003

set scriptPath to (do shell script "dirname " &amp; "~/Library/TeXShop/Scripts/ex")
set scriptPath to scriptPath &amp; "/setname.scpt"
set scriptName to POSIX file scriptPath as alias
set scriptLiB to (load script scriptName)
tell scriptLib
set frontName to setname(#NAMEPATH#,#TEXPATH#)
end tell

set fileName to  #NAMEPATH#
set n to (number of characters of contents of fileName)
set fileNamequoted to quoted form of fileName
set baseName to do shell script "basename " &amp; fileNamequoted
set m to (number of characters of contents of baseName)
set dirName to quoted form of (characters 1 thru (n - m - 1) of fileName as string)
set texName to baseName &amp; ".tex"

set shellScript to "cd " &amp; dirName &amp; ";"
set shellScript to shellScript &amp; "~/Library/TeXShop/bin/pdflatexc  " &amp; texName
do shell script shellScript


set shellScript to "cd " &amp; dirName &amp; ";"
set shellScript to shellScript &amp; "~/Library/TeXShop/bin/bibtexc  " &amp; baseName
do shell script shellScript

set shellScript to "cd " &amp; dirName &amp; ";"
set shellScript to shellScript &amp; "~/Library/TeXShop/bin/pdflatexc  " &amp; texName
do shell script shellScript

set shellScript to "cd " &amp; dirName &amp; ";"
set shellScript to shellScript &amp; "~/Library/TeXShop/bin/pdflatexc  " &amp; texName
do shell script shellScript


set fileLog to fileName &amp; ".blg"
set theFile to alias (POSIX file fileLog)
set logName to baseName &amp;".blg"

tell document frontName of application "TeXShop"
refreshpdf
end tell

tell application "TeXShop"
open theFile
end tell

tell document logName of application "TeXShop"
refreshtext
end tell




</string>
					<key>name</key>
					<string>bibtexcpl</string>
				</dict>
				<dict>
					<key>name</key>
					<string>Separator</string>
				</dict>
				<dict>
					<key>content</key>
					<string>--Applescript
-- Apply only to an already saved file
-- Claus Gerhardt, Nov. 2003

set scriptPath to (do shell script "dirname " &amp; "~/Library/TeXShop/Scripts/ex")
set scriptPath to scriptPath &amp; "/setname.scpt"
set scriptName to POSIX file scriptPath as alias
set scriptLiB to (load script scriptName)
tell scriptLib
set frontName to setname(#NAMEPATH#,#TEXPATH#)
end tell

set fileName to  #NAMEPATH#
set n to (number of characters of contents of fileName)
set fileNamequoted to quoted form of fileName
set baseName to do shell script "basename " &amp; fileNamequoted
set m to (number of characters of contents of baseName)
set dirName to quoted form of (characters 1 thru (n - m - 1) of fileName as string)
set texName to baseName &amp; ".tex"

set shellScript to "cd " &amp; dirName &amp; ";"
set shellScript to shellScript &amp; "~/Library/TeXShop/bin/mpostc  " &amp; baseName
do shell script shellScript

set fileLog to fileName &amp; ".log"
set theFile to alias (POSIX file fileLog)
set logName to baseName &amp;".log"

tell application "TeXShop"
open theFile
end tell

tell document logName of application "TeXShop"
refreshtext
end tell


set shellScript to "cd " &amp; dirName &amp; ";"
set shellScript to shellScript &amp; "~/Library/TeXShop/bin/pdflatexc  " &amp; texName
do shell script shellScript


tell document frontName of application "TeXShop"
refreshpdf
end tell

 </string>
					<key>name</key>
					<string>mpostc</string>
				</dict>
				<dict>
					<key>content</key>
					<string>--Applescript
-- Apply only to an already saved file
-- Claus Gerhardt, Nov. 2003

set scriptPath to (do shell script "dirname " &amp; "~/Library/TeXShop/Scripts/ex")
set scriptPath to scriptPath &amp; "/setname.scpt"
set scriptName to POSIX file scriptPath as alias
set scriptLiB to (load script scriptName)
tell scriptLib
set frontName to setname(#NAMEPATH#,#TEXPATH#)
end tell

set fileName to  #NAMEPATH#
set n to (number of characters of contents of fileName)
set fileNamequoted to quoted form of fileName
set baseName to do shell script "basename " &amp; fileNamequoted
set m to (number of characters of contents of baseName)
set dirName to quoted form of (characters 1 thru (n - m - 1) of fileName as string)
set texName to baseName &amp; ".tex"

set shellScript to "cd " &amp; dirName &amp; ";"
set shellScript to shellScript &amp; "~/Library/TeXShop/bin/pdflatexc  " &amp; texName
do shell script shellScript

set shellScript to "cd " &amp; dirName &amp; ";"
set shellScript to shellScript &amp; "~/Library/TeXShop/bin/mpostc  " &amp; baseName
do shell script shellScript

set fileLog to fileName &amp; ".log"
set theFile to alias (POSIX file fileLog)
set logName to baseName &amp;".log"

tell application "TeXShop"
open theFile
end tell

tell document logName of application "TeXShop"
refreshtext
end tell


set shellScript to "cd " &amp; dirName &amp; ";"
set shellScript to shellScript &amp; "~/Library/TeXShop/bin/pdflatexc  " &amp; texName
do shell script shellScript


tell document frontName of application "TeXShop"
refreshpdf
end tell

 </string>
					<key>name</key>
					<string>mpostcpl</string>
				</dict>
				<dict>
					<key>name</key>
					<string>Separator</string>
				</dict>
				<dict>
					<key>content</key>
					<string>--Applescript
-- Apply only to an already saved file
-- Claus Gerhardt, Nov. 2003

set scriptPath to (do shell script "dirname " &amp; "~/Library/TeXShop/Scripts/ex")
set scriptPath to scriptPath &amp; "/setname.scpt"
set scriptName to POSIX file scriptPath as alias
set scriptLiB to (load script scriptName)
tell scriptLib
set frontName to setname(#NAMEPATH#,#TEXPATH#)
end tell

set fileName to  #NAMEPATH#
set n to (number of characters of contents of fileName)
set fileNamequoted to quoted form of fileName
set baseName to do shell script "basename " &amp; fileNamequoted
set m to (number of characters of contents of baseName)
set dirName to quoted form of (characters 1 thru (n - m - 1) of fileName as string)
set texName to baseName &amp; ".tex"

set shellScript to "cd " &amp; dirName &amp; ";"
set shellScript to shellScript &amp; "~/Library/TeXShop/bin/htlatexc  " &amp; baseName
do shell script shellScript

set theHTML to #HTMLPATH#
set htmlFile to alias POSIX file theHTML

tell application "Safari"
  activate
  open htmlFile
end tell
</string>
					<key>key</key>
					<string></string>
					<key>name</key>
					<string>htlatexc</string>
				</dict>
				<dict>
					<key>content</key>
					<string>--Applescript
-- Apply only to an already saved file
-- Claus Gerhardt, Nov. 2003

set scriptPath to (do shell script "dirname " &amp; "~/Library/TeXShop/Scripts/ex")
set scriptPath to scriptPath &amp; "/setname.scpt"
set scriptName to POSIX file scriptPath as alias
set scriptLiB to (load script scriptName)
tell scriptLib
set frontName to setname(#NAMEPATH#,#TEXPATH#)
end tell

set fileName to  #NAMEPATH#
set n to (number of characters of contents of fileName)
set fileNamequoted to quoted form of fileName
set baseName to do shell script "basename " &amp; fileNamequoted
set m to (number of characters of contents of baseName)
set dirName to quoted form of (characters 1 thru (n - m - 1) of fileName as string)
set texName to baseName &amp; ".tex"

set shellScript to "cd " &amp; dirName &amp; ";"
set shellScript to shellScript &amp; "~/Library/TeXShop/bin/htlatexr  " &amp; baseName
do shell script shellScript

set theHTML to #HTMLPATH#
set htmlFile to alias POSIX file theHTML

tell application "Safari"
  activate
  open htmlFile
end tell
</string>
					<key>name</key>
					<string>htlatexr</string>
				</dict>
				<dict>
					<key>name</key>
					<string>Separator</string>
				</dict>
				<dict>
					<key>content</key>
					<string>--Applescript
-- Apply only to an already saved file.
-- Claus Gerhardt, Nov. 2003

set scriptPath to (do shell script "dirname " &amp; "~/Library/TeXShop/Scripts/ex")
set scriptPath to scriptPath &amp; "/setname.scpt"
set scriptName to POSIX file scriptPath as alias
set scriptLiB to (load script scriptName)
tell scriptLib
set frontName to setname(#NAMEPATH#,#TEXPATH#)
end tell

set fileName to  #TEXPATH#
set n to (number of characters of contents of fileName)
set fileNamequoted to quoted form of fileName
set baseName to do shell script "basename " &amp; fileNamequoted
set m to (number of characters of contents of baseName)
set dirName to quoted form of (characters 1 thru (n - m - 1) of fileName as string)

set shellScript to "cd " &amp; dirName &amp; ";"
set shellScript to shellScript &amp; "~/Library/TeXShop/bin/altpdflatexc  " &amp; baseName
do shell script shellScript

tell document frontName of application "TeXShop"
refreshpdf
end tell
</string>
					<key>key</key>
					<string></string>
					<key>name</key>
					<string>altpdflatexc</string>
				</dict>
				<dict>
					<key>content</key>
					<string>--Applescript
-- Apply only to an already saved file.
-- Claus Gerhardt, Nov. 2003

set scriptPath to (do shell script "dirname " &amp; "~/Library/TeXShop/Scripts/ex")
set scriptPath to scriptPath &amp; "/setname.scpt"
set scriptName to POSIX file scriptPath as alias
set scriptLiB to (load script scriptName)
tell scriptLib
set frontName to setname(#NAMEPATH#,#TEXPATH#)
end tell

set fileName to  #TEXPATH#
set n to (number of characters of contents of fileName)
set fileNamequoted to quoted form of fileName
set baseName to do shell script "basename " &amp; fileNamequoted
set m to (number of characters of contents of baseName)
set dirName to quoted form of (characters 1 thru (n - m - 1) of fileName as string)

set shellScript to "cd " &amp; dirName &amp; ";"
set shellScript to shellScript &amp; "~/Library/TeXShop/bin/pdflatexc  " &amp; baseName
do shell script shellScript

tell document frontName of application "TeXShop"
	refreshpdf
end tell
</string>
					<key>name</key>
					<string>pdflatexc</string>
				</dict>
				<dict>
					<key>name</key>
					<string>Separator</string>
				</dict>
				<dict>
					<key>content</key>
					<string>--AppleScript
-- Apply only to an already saved file
-- Claus Gerhardt, Nov. 2003

-- In the first dialog enter the number of pdf files you want to create.
-- In each of the following dialogs enter your selection of pages like
-- 3:4,6,8:12 This would be the selection for one output file
-- It would contain the pages 3-4, 6, and 8-12

set fileName to  #NAMEPATH#
set n to (number of characters of contents of fileName)
set fileNamequoted to quoted form of fileName
set baseName to do shell script "basename " &amp; fileNamequoted
set m to (number of characters of contents of baseName)
set dirName to quoted form of (characters 1 thru (n - m - 1) of fileName as string)

set dialogName to "The original file is " &amp; fileNamequoted &amp; ".pdf. How many files do you want?"
activate
set k to the text returned of (display dialog dialogName default answer "" buttons {"Cancel", "Next"} default button "Next") as number
set dialogSelection to "Your selection for  file # 1. The file will be saved as " &amp; baseName &amp; "-1.pdf."
set i to 1 as number

set input to the text returned of (display dialog dialogSelection default answer "" buttons {"Cancel", "Next"} default button "Next")

repeat while i ≤ k - 1
set j to i + 1 as number
set selectionName to "Selection for file #" &amp; j &amp; ". The file will be saved as " &amp; baseName &amp; "-" &amp; j &amp; ".pdf."
set input to input &amp; " " &amp; the text returned of (display dialog selectionName default answer "" buttons {"Cancel", "Next"} default button "Next")
set i to i + 1
end repeat

set input to input &amp; " " &amp; baseName

set shellScript to "cd " &amp; dirName &amp; ";"
set shellScript to shellScript &amp; "~/Library/TeXShop/bin/pdfselectc  " &amp; input
do shell script shellScript


</string>
					<key>name</key>
					<string>pdfselectc</string>
				</dict>
				<dict>
					<key>name</key>
					<string>Separator</string>
				</dict>
				<dict>
					<key>content</key>
					<string>--Applescript
-- Apply only to an already saved file.


set thePDF to  #PDFPATH#
set pdfFile to alias POSIX file thePDF
  tell application "TeXShop"
    activate
  open pdfFile
  end tell
</string>
					<key>key</key>
					<string></string>
					<key>name</key>
					<string>openpdf</string>
				</dict>
				<dict>
					<key>name</key>
					<string>Separator</string>
				</dict>
				<dict>
					<key>content</key>
					<string>--Applescript
-- Apply only to an already saved file
-- Claus Gerhardt, Nov. 2003


set scriptPath to (do shell script "dirname " &amp; "~/Library/TeXShop/Scripts/ex")
set scriptPath to scriptPath &amp; "/setname.scpt"
set scriptName to POSIX file scriptPath as alias
set scriptLiB to (load script scriptName)
tell scriptLib
set frontName to setname(#NAMEPATH#,#TEXPATH#)
end tell

set fileName to  #NAMEPATH#
set n to (number of characters of contents of fileName)
set fileNamequoted to quoted form of fileName
set baseName to do shell script "basename " &amp; fileNamequoted
set m to (number of characters of contents of baseName)
set dirName to quoted form of (characters 1 thru (n - m - 1) of fileName as string)
set texName to baseName &amp; ".tex"

set shellScript to "cd " &amp; dirName &amp; ";"
set shellScript to shellScript &amp; "~/Library/TeXShop/bin/pdflatexc  " &amp; texName
do shell script shellScript

set shellScript to "cd " &amp; dirName &amp; ";"
set shellScript to shellScript &amp; "~/Library/TeXShop/bin/makeindexk  " &amp; baseName
do shell script shellScript

set shellScript to "cd " &amp; dirName &amp; ";"
set shellScript to shellScript &amp; "~/Library/TeXShop/bin/mpostc  " &amp; baseName
do shell script shellScript

set fileLog to fileName &amp; ".log"
set theFile to alias (POSIX file fileLog)
set logName to baseName &amp;".log"

tell application "TeXShop"
open theFile
end tell

tell document logName of application "TeXShop"
refreshtext
end tell

set shellScript to "cd " &amp; dirName &amp; ";"
set shellScript to shellScript &amp; "~/Library/TeXShop/bin/pdflatexc  " &amp; texName
do shell script shellScript

tell document frontName of application "TeXShop"
refreshpdf
end tell


</string>
					<key>name</key>
					<string>latex-makeindex-mpost</string>
				</dict>
			</array>
		</dict>
		<dict>
			<key>name</key>
			<string>Separator</string>
		</dict>
		<dict>
			<key>content</key>
			<string>\begin{#SEL#}
#INS#
\end{#SEL#}</string>
			<key>name</key>
			<string>Begin/End</string>
		</dict>
		<dict>
			<key>name</key>
			<string>Encoding</string>
			<key>submenu</key>
			<array>
				<dict>
					<key>content</key>
					<string>%!TEX encoding = MacOSRoman
#INS#</string>
					<key>name</key>
					<string>MacOSRoman</string>
				</dict>
				<dict>
					<key>content</key>
					<string>%!TEX encoding = IsoLatin
#INS#</string>
					<key>name</key>
					<string>IsoLatin</string>
				</dict>
				<dict>
					<key>content</key>
					<string>%!TEX encoding = IsoLatin2
#INS#</string>
					<key>name</key>
					<string>IsoLatin2</string>
				</dict>
				<dict>
					<key>content</key>
					<string>%!TEX encoding = IsoLatin5
#INS#</string>
					<key>name</key>
					<string>IsoLatin5</string>
				</dict>
				<dict>
					<key>content</key>
					<string>%!TEX encoding = IsoLatin9
#INS#</string>
					<key>name</key>
					<string>IsoLatin9</string>
				</dict>
				<dict>
					<key>content</key>
					<string>%!TEX encoding = IsoLatinGreek
#INS#</string>
					<key>name</key>
					<string>IsoLatinGreek</string>
				</dict>
				<dict>
					<key>content</key>
					<string>%!TEX encoding = Mac Central European Roman
#INS#</string>
					<key>name</key>
					<string>Mac Central European Roman</string>
				</dict>
				<dict>
					<key>content</key>
					<string>%!TEX encoding = MacJapanese
#INS#</string>
					<key>name</key>
					<string>MacJapanese</string>
				</dict>
				<dict>
					<key>content</key>
					<string>%!TEX encoding = DOSJapanese
#INS#</string>
					<key>name</key>
					<string>DOSJapanese</string>
				</dict>
				<dict>
					<key>content</key>
					<string>%!TEX encoding = SJIS_X0213
#INS#</string>
					<key>name</key>
					<string>SJIS_X0213</string>
				</dict>
				<dict>
					<key>content</key>
					<string>%!TEX encoding = EUC_JP
#INS#</string>
					<key>name</key>
					<string>EUC_JP</string>
				</dict>
				<dict>
					<key>content</key>
					<string>%!TEX encoding = JISJapanese
#INS#</string>
					<key>name</key>
					<string>JISJapanese</string>
				</dict>
				<dict>
					<key>content</key>
					<string>%!TEX encoding = MacKorean
#INS#</string>
					<key>name</key>
					<string>MacKorean</string>
				</dict>
				<dict>
					<key>content</key>
					<string>%!TEX encoding = UTF-8 Unicode
#INS#</string>
					<key>name</key>
					<string>UTF-8 Unicode</string>
				</dict>
				<dict>
					<key>content</key>
					<string>%!TEX encoding = Standard Unicode
#INS#</string>
					<key>name</key>
					<string>Standard Unicode</string>
				</dict>
				<dict>
					<key>content</key>
					<string>%!TEX encoding = Mac Cyrillic
#INS#</string>
					<key>name</key>
					<string>Mac Cyrillic</string>
				</dict>
				<dict>
					<key>content</key>
					<string>%!TEX encoding = DOS Cyrillic
#INS#</string>
					<key>name</key>
					<string>DOS Cyrillic</string>
				</dict>
				<dict>
					<key>content</key>
					<string>%!TEX encoding = DOS Russian
#INS#</string>
					<key>name</key>
					<string>DOS Russian</string>
				</dict>
				<dict>
					<key>content</key>
					<string>%!TEX encoding = WindowsCentralEurRoman
#INS#</string>
					<key>name</key>
					<string>WindowsCentralEurRoman</string>
				</dict>
				<dict>
					<key>content</key>
					<string>%!TEX encoding = Windows Cyrillic
#INS#</string>
					<key>name</key>
					<string>Windows Cyrillic</string>
				</dict>
				<dict>
					<key>content</key>
					<string>%!TEX encoding = KOI8_R
#INS#</string>
					<key>name</key>
					<string>KOI8_R</string>
				</dict>
				<dict>
					<key>content</key>
					<string>%!TEX encoding = Mac Chinese Traditional
#INS#</string>
					<key>name</key>
					<string>Mac Chinese Traditional</string>
				</dict>
				<dict>
					<key>content</key>
					<string>%!TEX encoding = Mac Chinese Simplified
#INS#</string>
					<key>name</key>
					<string>Mac Chinese Simplified</string>
				</dict>
				<dict>
					<key>content</key>
					<string>%!TEX encoding = DOS Chinese Traditional
#INS#</string>
					<key>name</key>
					<string>DOS Chinese Traditional</string>
				</dict>
				<dict>
					<key>content</key>
					<string>%!TEX encoding = DOS Chinese Simplified
#INS#</string>
					<key>name</key>
					<string>DOS Chinese Simplified</string>
				</dict>
				<dict>
					<key>content</key>
					<string>%!TEX encoding = GBK
#INS#</string>
					<key>name</key>
					<string>GBK</string>
				</dict>
				<dict>
					<key>content</key>
					<string>%!TEX encoding = GB 2312
#INS#</string>
					<key>name</key>
					<string>GB 2312</string>
				</dict>
				<dict>
					<key>content</key>
					<string>%!TEX encoding = GB 18030
#INS#</string>
					<key>name</key>
					<string>GB 18030</string>
				</dict>
			</array>
		</dict>
		<dict>
			<key>name</key>
			<string>Program</string>
			<key>submenu</key>
			<array>
				<dict>
					<key>content</key>
					<string>%!TEX TS-program = tex
#INS#</string>
					<key>name</key>
					<string>tex</string>
				</dict>
				<dict>
					<key>content</key>
					<string>%!TEX TS-program = pdftex
#INS#</string>
					<key>name</key>
					<string>pdftex</string>
				</dict>
				<dict>
					<key>content</key>
					<string>%!TEX TS-program = latex
#INS#</string>
					<key>name</key>
					<string>latex</string>
				</dict>
				<dict>
					<key>content</key>
					<string>%!TEX TS-program = pdflatex
#INS#</string>
					<key>name</key>
					<string>pdflatex</string>
				</dict>
				<dict>
					<key>content</key>
					<string>%!TEX TS-program = bibtex
#INS#</string>
					<key>name</key>
					<string>bibtex</string>
				</dict>
				<dict>
					<key>content</key>
					<string>%!TEX TS-program = makeindex
#INS#</string>
					<key>name</key>
					<string>makeindex</string>
				</dict>
				<dict>
					<key>content</key>
					<string>%!TEX TS-program = metapost
#INS#</string>
					<key>name</key>
					<string>metapost</string>
				</dict>
				<dict>
					<key>content</key>
					<string>%!TEX TS-program = context
#INS#</string>
					<key>name</key>
					<string>context</string>
				</dict>
				<dict>
					<key>content</key>
					<string>%!TEX TS-program = metafont
#INS#</string>
					<key>name</key>
					<string>metafont</string>
				</dict>
				<dict>
					<key>content</key>
					<string>%!TEX TS-program = #INS#</string>
					<key>name</key>
					<string>user defined engine</string>
				</dict>
			</array>
		</dict>
		<dict>
			<key>content</key>
			<string>%!TEX root =  #INS#</string>
			<key>name</key>
			<string>Root</string>
		</dict>
		<dict>
			<key>name</key>
			<string>Separator</string>
		</dict>
		<dict>
			<key>name</key>
			<string>Headings</string>
			<key>submenu</key>
			<array>
				<dict>
					<key>name</key>
					<string>11pt</string>
					<key>submenu</key>
					<array>
						<dict>
							<key>content</key>
							<string>\documentclass[11pt]{article}
\begin{document}

\title{#INS#}
\author{}
\date{}
\maketitle


\end{document}
</string>
							<key>key</key>
							<string></string>
							<key>name</key>
							<string>article</string>
						</dict>
						<dict>
							<key>content</key>
							<string>\documentclass[11pt]{book}
\begin{document}

\title{#INS#}
\author{}
\date{}
\maketitle


\end{document}
</string>
							<key>name</key>
							<string>book</string>
						</dict>
						<dict>
							<key>content</key>
							<string>\documentclass[11pt]{report}
\begin{document}

\title{#INS#}
\author{}
\date{}
\maketitle


\end{document}
</string>
							<key>name</key>
							<string>report</string>
						</dict>
					</array>
				</dict>
				<dict>
					<key>name</key>
					<string>12pt</string>
					<key>submenu</key>
					<array>
						<dict>
							<key>content</key>
							<string>\documentclass[12pt]{article}
\begin{document}

\title{#INS#}
\author{}
\date{}
\maketitle


\end{document}
</string>
							<key>name</key>
							<string>article</string>
						</dict>
						<dict>
							<key>content</key>
							<string>\documentclass[12pt]{book}
\begin{document}

\title{#INS#}
\author{}
\date{}
\maketitle


\end{document}
</string>
							<key>name</key>
							<string>book</string>
						</dict>
						<dict>
							<key>content</key>
							<string>\documentclass[12pt]{report}
\begin{document}

\title{#INS#}
\author{}
\date{}
\maketitle


\end{document}
</string>
							<key>name</key>
							<string>report</string>
						</dict>
					</array>
				</dict>
			</array>
		</dict>
		<dict>
			<key>name</key>
			<string>Subdivisions</string>
			<key>submenu</key>
			<array>
				<dict>
					<key>content</key>
					<string>\chapter{#SEL##INS#}
</string>
					<key>name</key>
					<string>chapter</string>
				</dict>
				<dict>
					<key>content</key>
					<string>\paragraph{#SEL##INS#}
</string>
					<key>name</key>
					<string>paragraph</string>
				</dict>
				<dict>
					<key>content</key>
					<string>\subparagraph{#SEL##INS#}
</string>
					<key>name</key>
					<string>subparagraph</string>
				</dict>
				<dict>
					<key>content</key>
					<string>\section{#SEL##INS#}
</string>
					<key>name</key>
					<string>section</string>
				</dict>
				<dict>
					<key>content</key>
					<string>\subsection{#SEL##INS#}
</string>
					<key>name</key>
					<string>subsection</string>
				</dict>
				<dict>
					<key>content</key>
					<string>\subsubsection{#SEL##INS#}
</string>
					<key>name</key>
					<string>subsubsection</string>
				</dict>
			</array>
		</dict>
		<dict>
			<key>name</key>
			<string>Mathematics</string>
			<key>submenu</key>
			<array>
				<dict>
					<key>content</key>
					<string>\[
\left(
\begin{array}{ccc}
  &amp;   &amp;   \\
  &amp;   &amp;   \\
  &amp;   &amp;   
\end{array}
\right)
\]
</string>
					<key>name</key>
					<string>array</string>
				</dict>
				<dict>
					<key>content</key>
					<string>\begin{equation}
#INS#
\end{equation}
</string>
					<key>name</key>
					<string>equation</string>
				</dict>
				<dict>
					<key>content</key>
					<string>\begin{equation*}
#INS#
\end{equation*}
</string>
					<key>name</key>
					<string>equation*</string>
				</dict>
				<dict>
					<key>content</key>
					<string>\begin{eqnarray}
#INS#
\end{eqnarray}
</string>
					<key>name</key>
					<string>eqnarray</string>
				</dict>
				<dict>
					<key>content</key>
					<string>\begin{eqnarray*}
#INS#
\end{eqnarray*}
</string>
					<key>name</key>
					<string>eqnarray*</string>
				</dict>
			</array>
		</dict>
		<dict>
			<key>name</key>
			<string>Text Styles</string>
			<key>submenu</key>
			<array>
				<dict>
					<key>content</key>
					<string>\emph{#SEL##INS#}</string>
					<key>name</key>
					<string>emphasize</string>
				</dict>
				<dict>
					<key>name</key>
					<string>typeface</string>
					<key>submenu</key>
					<array>
						<dict>
							<key>content</key>
							<string>\mathbf{#SEL##INS#}</string>
							<key>name</key>
							<string>Bold</string>
						</dict>
						<dict>
							<key>content</key>
							<string>\mathcal{#SEL##INS#}</string>
							<key>name</key>
							<string>CAL</string>
						</dict>
						<dict>
							<key>content</key>
							<string>\mathit{#SEL##INS#}</string>
							<key>name</key>
							<string>Italic</string>
						</dict>
						<dict>
							<key>content</key>
							<string>\mathrm{#SEL##INS#}</string>
							<key>name</key>
							<string>Roman</string>
						</dict>
						<dict>
							<key>content</key>
							<string>\mathsf{#SEL##INS#}</string>
							<key>name</key>
							<string>Sans Serif</string>
						</dict>
						<dict>
							<key>content</key>
							<string>\mathtt{#SEL##INS#}</string>
							<key>name</key>
							<string>TypeWriter</string>
						</dict>
					</array>
				</dict>
				<dict>
					<key>name</key>
					<string>size</string>
					<key>submenu</key>
					<array>
						<dict>
							<key>content</key>
							<string>{\tiny #SEL##INS#}</string>
							<key>name</key>
							<string>tiny</string>
						</dict>
						<dict>
							<key>content</key>
							<string>{\scriptsize #SEL##INS#}</string>
							<key>name</key>
							<string>scriptsize</string>
						</dict>
						<dict>
							<key>content</key>
							<string>{\footnotesize #SEL##INS#}</string>
							<key>name</key>
							<string>footnotesize</string>
						</dict>
						<dict>
							<key>content</key>
							<string>{\small #SEL##INS#}</string>
							<key>name</key>
							<string>small</string>
						</dict>
						<dict>
							<key>content</key>
							<string>{\normalsize #SEL##INS#}</string>
							<key>name</key>
							<string>normalsize</string>
						</dict>
						<dict>
							<key>content</key>
							<string>{\large #SEL##INS#}</string>
							<key>name</key>
							<string>large</string>
						</dict>
						<dict>
							<key>content</key>
							<string>{\Large #SEL##INS#}</string>
							<key>name</key>
							<string>Large</string>
						</dict>
						<dict>
							<key>content</key>
							<string>{\LARGE #SEL##INS#}</string>
							<key>name</key>
							<string>LARGE</string>
						</dict>
						<dict>
							<key>content</key>
							<string>{\huge #SEL##INS#}</string>
							<key>name</key>
							<string>huge</string>
						</dict>
						<dict>
							<key>content</key>
							<string>{\Huge #SEL##INS#}</string>
							<key>name</key>
							<string>Huge</string>
						</dict>
					</array>
				</dict>
				<dict>
					<key>name</key>
					<string>style</string>
					<key>submenu</key>
					<array>
						<dict>
							<key>content</key>
							<string>\textbf{#SEL##INS#}</string>
							<key>name</key>
							<string>Bold</string>
						</dict>
						<dict>
							<key>content</key>
							<string>\textsc{#SEL##INS#}</string>
							<key>name</key>
							<string>Small Caps</string>
						</dict>
						<dict>
							<key>content</key>
							<string>\textmd{#SEL##INS#}</string>
							<key>name</key>
							<string>Medium</string>
						</dict>
						<dict>
							<key>content</key>
							<string>\textit{#SEL##INS#}</string>
							<key>name</key>
							<string>Italic</string>
						</dict>
						<dict>
							<key>content</key>
							<string>\textsl{#SEL##INS#}</string>
							<key>name</key>
							<string>Slanted</string>
						</dict>
						<dict>
							<key>content</key>
							<string>\textrm{#SEL##INS#}</string>
							<key>name</key>
							<string>Roman</string>
						</dict>
						<dict>
							<key>content</key>
							<string>\textsf{#SEL##INS#}</string>
							<key>name</key>
							<string>Sans Serif</string>
						</dict>
						<dict>
							<key>content</key>
							<string>\texttt{#SEL##INS#}</string>
							<key>name</key>
							<string>TypeWriter</string>
						</dict>
						<dict>
							<key>content</key>
							<string>\textup{#SEL##INS#}</string>
							<key>name</key>
							<string>Upright</string>
						</dict>
					</array>
				</dict>
				<dict>
					<key>content</key>
					<string>\underline{#SEL##INS#}</string>
					<key>name</key>
					<string>Underline</string>
				</dict>
			</array>
		</dict>
		<dict>
			<key>name</key>
			<string>Lists</string>
			<key>submenu</key>
			<array>
				<dict>
					<key>content</key>
					<string>\begin{description}
\item[ ] #SEL##INS#
\end{description}
</string>
					<key>name</key>
					<string>description</string>
				</dict>
				<dict>
					<key>content</key>
					<string>\begin{enumerate}
\item #SEL##INS#
\end{enumerate}
</string>
					<key>name</key>
					<string>enumerate</string>
				</dict>
				<dict>
					<key>content</key>
					<string>\begin{itemize}
\item #SEL##INS#
\end{itemize}
</string>
					<key>name</key>
					<string>itemize</string>
				</dict>
			</array>
		</dict>
		<dict>
			<key>name</key>
			<string>Offsets</string>
			<key>submenu</key>
			<array>
				<dict>
					<key>content</key>
					<string>\footnote{#SEL##INS#}</string>
					<key>name</key>
					<string>footnote</string>
				</dict>
				<dict>
					<key>content</key>
					<string>\marginpar{#SEL##INS#}</string>
					<key>name</key>
					<string>marginpar</string>
				</dict>
			</array>
		</dict>
		<dict>
			<key>name</key>
			<string>Insertions</string>
			<key>submenu</key>
			<array>
				<dict>
					<key>content</key>
					<string>\begin{quotation}
#SEL##INS#
\end{quotation}</string>
					<key>name</key>
					<string>quotation</string>
				</dict>
				<dict>
					<key>content</key>
					<string>\begin{quote}
#SEL##INS#
\end{quote}</string>
					<key>name</key>
					<string>quote</string>
				</dict>
				<dict>
					<key>content</key>
					<string>\begin{verbatim}
#SEL##INS#
\end{verbatim}
</string>
					<key>name</key>
					<string>verbatim</string>
				</dict>
				<dict>
					<key>content</key>
					<string>\begin{verse}
#SEL##INS#
\end{verse}</string>
					<key>name</key>
					<string>verse</string>
				</dict>
			</array>
		</dict>
		<dict>
			<key>name</key>
			<string>Tables</string>
			<key>submenu</key>
			<array>
				<dict>
					<key>content</key>
					<string>\hline</string>
					<key>name</key>
					<string>hline</string>
				</dict>
				<dict>
					<key>content</key>
					<string>\begin{table}[htdp]
\caption{default}
\begin{center}
\begin{tabular}{|c|c|}
#SEL##INS#
\end{tabular}
\end{center}
\label{default}
\end{table}%
</string>
					<key>name</key>
					<string>table</string>
				</dict>
			</array>
		</dict>
		<dict>
			<key>name</key>
			<string>Figures</string>
			<key>submenu</key>
			<array>
				<dict>
					<key>content</key>
					<string>\begin{figure}[htbp]
\begin{center}
#SEL##INS#
\caption{default}
\label{default}
\end{center}
\end{figure}
</string>
					<key>name</key>
					<string>regular</string>
				</dict>
				<dict>
					<key>content</key>
					<string>\begin{figure}[htbp]
\begin{center}
\epsfile{file=#SEL##INS#,scale=0.8}
\caption{{\bf default}}
\label{default}
\end{center}
\end{figure}
</string>
					<key>name</key>
					<string>epsfile</string>
				</dict>
			</array>
		</dict>
	</array>
</dict>
</plist>
