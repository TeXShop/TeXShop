<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE plist PUBLIC "-//Apple//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd">
<plist version="1.0">
<dict>
	<key>content</key>
	<string></string>
	<key>key</key>
	<string></string>
	<key>name</key>
	<string>ROOT</string>
	<key>submenu</key>
	<array>
		<dict>
			<key>content</key>
			<string>--Applescript direct

-- Script that improves on the TeXShop default macro called "Program",
-- i.e., %!TEX TS-program =  #INS#
-- by letting the user choose which engine she/he wants to use,
-- deleting the first old (if any) engine command,
-- inserting the command at the beginning of the document, and
-- restoring the original selection.
-- It assumes that engines are installed in ~/Library/TeXShop/Engines/
-- Ramon Figueroa-Centeno (March 10, 2009)
-- http://www2.hawaii.edu/~ramonf

-- History:
-- 1.1: March 19, 2008
-- Added missing default engines: metapost, metafont, and context.
-- 1.2: March 28, 2009
-- Added code to respect first lines that start with "%&amp;"


-- If you wish you can change this so that your favorite engine is the default choice
property default_engine : "pdflatexmk"

tell application "TeXShop"
	
	-- Get a sorted list of the default and installed TeXShop engines
	tell me
		-- Shell script to get the names of the engines installed in ~/Library/TeXShop/Engines/
		set command to "ls ~/Library/TeXShop/Engines/ | egrep -e '^.*\\.engine$' | sed 's/\\.engine//'"
		set engines to paragraphs of (do shell script command)
		set engines to sort({"tex", "latex", "pdflatex", "pdftex", "personaltex", "personallatex", "metapost", "metafont", "context"} &amp; engines)
	end tell
	
	-- Figure out which is the index of the "default_engine" in the "engines" list
	if default_engine is in engines then
		repeat with i from 1 to count of engines
			if item i of engines is default_engine then
				exit repeat
			end if
		end repeat
	else
		-- if the "default_engine" is not among the engines then choose the alphabetically first available engine name
		set i to 1
	end if
	
	set the engine to choose from list engines with prompt "Pick an engine:" default items item i of engines OK button name "OK" cancel button name "Cancel" without multiple selections allowed and empty selection allowed
	if the result is false then
		return
	end if
	
	-- The linefeed character
	set linefeed to ASCII character 10
	
	-- The whole text of the document
	set whole_document to (the text of the front document) as string
	
	-- The offset of the selection
	set selection_offset to offset of the selection of the front document
	
	-- The length of the selection
	set selection_length to length of the selection of the front document
	
	-- Find and delete a previous engine specification
	-- (it will not handle more than one specification)
	set searchString1 to "%!TEX TS-program ="
	set search1 to (search for searchString1 starting from 0) of front document
	set searchString2 to "% !TEX TS-program ="
	set search2 to (search for searchString2 starting from 0) of front document
	
	if search1 * search2 &gt; 0 then
		if search1 &lt; search2 then
			set first_occurrence to search1
		else
			set first_occurrence to search2
		end if
	else if search1 &gt; 0 then
		set first_occurrence to search1
	else
		set first_occurrence to search2
	end if
	if first_occurrence &gt; 0 then
		set offset of selection of front document to (first_occurrence - 1)
		
		-- Get the offset of the line feed (or eof) ending the line containing "%!TEX TS-program ="
		-- (here we use a "try" statement to avoid  needing to have a saved file
		-- from which we could get the "eof") 
		set i to first_occurrence
		set end_of_file to false
		set char to character i of whole_document
		repeat while char is not in {linefeed, return}
			set i to i + 1
			try
				set char to character i of whole_document
			on error
				set end_of_file to true
				exit repeat
			end try
		end repeat
		
		-- Detect if the line starts with "% !TEX TS-program =" and it is not the last line,
		-- if so we will delete not only "% !TEX TS-program =..." but the whole line
		if ((first_occurrence = 1) or (character (first_occurrence - 1) of whole_document is in {linefeed, return})) and not end_of_file then
			set i to i + 1
		end if
		
		set length of selection of front document to (i - first_occurrence)
		-- Delete the line
		set the content of the selection of the front document to ""
		
		-- We will try to restore the selection the user had before invoking this script
		-- so we compute what the new selection_offset should be.
		if (selection_offset ≥ first_occurrence - 1) and (selection_offset &lt; i - 1) then
			set selection_offset to first_occurrence - 1
			set selection_length to 0
		else if selection_offset ≥ i - 1 then
			set selection_offset to selection_offset - (i - first_occurrence)
		end if
	end if
	
	set program to "% !TEX TS-program = " &amp; engine &amp; linefeed
	set selection_offset to selection_offset + (count of program)
	
	-- If the first line starts with "%&amp;" set the insertion offset
	-- to the beginning of the second line.
	try
		set first_line to paragraph 1 of the text of the front document as string
		if the first_line starts with "%&amp;" then
			set insertion_offset to count the characters of the first_line
			try
				get paragraph 2 of the text of the front document
			on error -- There is only one line?
				set selection_offset to selection_offset + 1
				set program to linefeed &amp; program
			end try
		else
			set insertion_offset to 0
		end if
	on error -- The document was empty?
		set insertion_offset to 0
	end try
	
	-- Insert Engine
	set offset of the selection of the front document to insertion_offset
	set length of the selection of the front document to 0
	set content of the selection of the front document to program
	
	-- Restore the offset of the selection
	set offset of the selection of the front document to selection_offset
	
	-- Restore the length of the selection
	set length of the selection of the front document to selection_length
	
end tell

(* 
http://www.macosxhints.com/article.php?story=20040513173003941
Sort lists in AppleScript using the Unix sort command
Mon, May 17 '04 at 09:13AM • from: erickaterman *)
on sort(the_list)
	set old_delims to AppleScript's text item delimiters
	set AppleScript's text item delimiters to {ASCII character 10} -- always a linefeed
	set list_string to (the_list as string)
	set new_string to do shell script "echo " &amp; quoted form of list_string &amp; " | sort -f -u"
	set new_list to (paragraphs of new_string)
	set AppleScript's text item delimiters to old_delims
	return new_list
end sort</string>
			<key>key</key>
			<string></string>
			<key>name</key>
			<string>Program</string>
		</dict>
		<dict>
			<key>content</key>
			<string>--Applescript direct

-- Script that improves on the TeXShop default macro called "Encoding",
-- i.e., %!TEX encoding =  #INS#
-- by letting the user choose which encoding she/he wants to use,
-- deleting the first old (if any) encoding command,
-- inserting the command at the beginning of the document, and
-- restoring the original selection.
-- Ramon Figueroa-Centeno (March 10, 2009)
-- http://www2.hawaii.edu/~ramonf

-- History: 
-- 1.1: March 18, 2009
-- Added missing encodings.
-- 1.2: March 28, 2009
-- Added code to respect first lines that start with "%&amp;"

-- If you wish you can change this so that your favorite encoding is the default choice
property default_encoding : "IsoLatin9"

tell application "TeXShop"
	
	-- Get a sorted list of the TeXShop encodings
	tell me
		set encodings to {"MacOSRoman", "IsoLatin", "IsoLatin2", "IsoLatin5", "IsoLatin9", "IsoLatinGreek", "Mac Central European Roman", "MacJapanese", "DOSJapanese", "SJIS_X0213", "EUC_JP", "JISJapanese", "MacKorean", "UTF-8 Unicode", "Standard Unicode", "Mac Cyrillic", "DOS Cyrillic", "DOS Russian", "Windows Latin 1", "WindowsCentralEurRoman", "Windows Cyrillic", "KOI8_R", "Mac Chinese Traditional", "Mac Chinese Simplified", "DOS Chinese Traditional", "DOS Chinese Simplified", "GBK", "GB 2312", "GB 18030"}
		set encodings to sort(encodings)
	end tell
	
	-- Figure out which is the index of the "default_encoding" in the "encodings" list
	if default_encoding is in encodings then
		repeat with i from 1 to count of encodings
			if item i of encodings is default_encoding then
				exit repeat
			end if
		end repeat
	else
		-- if the "default_encoding" is not among the encodings then choose the alphabetically first available encoding name
		set i to 1
	end if
	
	set the encoding to choose from list encodings with prompt "Pick an encoding:" default items item i of encodings OK button name "OK" cancel button name "Cancel" without multiple selections allowed and empty selection allowed
	if the result is false then
		return
	end if
	
	-- The linefeed character
	set linefeed to ASCII character 10
	
	-- The whole text of the document
	set whole_document to (the text of the front document) as string
	
	-- The offset of the selection
	set selection_offset to offset of the selection of the front document
	
	-- The length of the selection
	set selection_length to length of the selection of the front document
	
	-- Find and delete a previous encoding specification
	-- (it will not handle more than one specification)
	set searchString1 to "%!TEX encoding ="
	set search1 to (search for searchString1 starting from 0) of front document
	set searchString2 to "% !TEX encoding ="
	set search2 to (search for searchString2 starting from 0) of front document
	
	if search1 * search2 &gt; 0 then
		if search1 &lt; search2 then
			set first_occurrence to search1
		else
			set first_occurrence to search2
		end if
	else if search1 &gt; 0 then
		set first_occurrence to search1
	else
		set first_occurrence to search2
	end if
	if first_occurrence &gt; 0 then
		set offset of selection of front document to (first_occurrence - 1)
		
		-- Get the offset of the line feed (or eof) ending the line containing "% !TEX encoding ="
		-- (here we use a "try" statement to avoid  needing to have a saved file
		-- from which we could get the "eof") 
		set i to first_occurrence
		set end_of_file to false
		set char to character i of whole_document
		repeat while char is not in {linefeed, return}
			set i to i + 1
			try
				set char to character i of whole_document
			on error
				set end_of_file to true
				exit repeat
			end try
		end repeat
		
		-- Detect if the line starts with "% !TEX encoding =" and it is not the last line,
		-- if so we will delete not only "% !TEX encoding =..." but the whole line
		if ((first_occurrence = 1) or (character (first_occurrence - 1) of whole_document is in {linefeed, return})) and not end_of_file then
			set i to i + 1
		end if
		
		set length of selection of front document to (i - first_occurrence)
		-- Delete the line
		set the content of the selection of the front document to ""
		
		-- We will try to restore the selection the user had before invoking this script
		-- so we compute what the new selection_offset should be.
		if (selection_offset ≥ first_occurrence - 1) and (selection_offset &lt; i - 1) then
			set selection_offset to first_occurrence - 1
			set selection_length to 0
		else if selection_offset ≥ i - 1 then
			set selection_offset to selection_offset - (i - first_occurrence)
		end if
	end if
	
	set program to "% !TEX encoding = " &amp; encoding &amp; linefeed
	set selection_offset to selection_offset + (count of program)
	
	-- If the first line starts with "%&amp;" set the insertion offset
	-- to the beginning of the second line.
	try
		set first_line to paragraph 1 of the text of the front document as string
		if the first_line starts with "%&amp;" then
			set insertion_offset to count the characters of the first_line
			try
				get paragraph 2 of the text of the front document
			on error -- There is only one line?
				set selection_offset to selection_offset + 1
				set program to linefeed &amp; program
			end try
		else
			set insertion_offset to 0
		end if
	on error -- The document was empty?
		set insertion_offset to 0
	end try
	
	-- Insert Encoding
	set offset of the selection of the front document to insertion_offset
	set length of the selection of the front document to 0
	set content of the selection of the front document to program
	
	-- Restore the offset of the selection
	set offset of the selection of the front document to selection_offset
	
	-- Restore the length of the selection
	set length of the selection of the front document to selection_length
	
end tell

(* 
http://www.macosxhints.com/article.php?story=20040513173003941
Sort lists in AppleScript using the Unix sort command
Mon, May 17 '04 at 09:13AM • from: erickaterman *)
on sort(the_list)
	set old_delims to AppleScript's text item delimiters
	set AppleScript's text item delimiters to {ASCII character 10} -- always a linefeed
	set list_string to (the_list as string)
	set new_string to do shell script "echo " &amp; quoted form of list_string &amp; " | sort -f -u"
	set new_list to (paragraphs of new_string)
	set AppleScript's text item delimiters to old_delims
	return new_list
end sort</string>
			<key>key</key>
			<string></string>
			<key>name</key>
			<string>Encoding</string>
		</dict>
		<dict>
			<key>content</key>
			<string>--Applescript direct

-- Script that improves on the TeXShop default macro called "Root",
-- i.e., %!TEX root =  #INS#
-- by letting the user choose which root document she/he wants to use
-- (as a relative or absolute path),
-- deleting the first old (if any) root command,
-- inserting the command at the beginning of the document, and
-- restoring the original selection.
-- Ramon Figueroa-Centeno (March 10, 2009)
-- http://www2.hawaii.edu/~ramonf

-- History: 
-- 1.1: March 18, 2009
-- Added code to respect first lines that start with "%&amp;"


-- What is the default choice: relative or not relative (i.e. absolute)
property relative : true

tell application "TeXShop"
	
	try
		path of the front document
		set TeX_path to the result
	on error -- there is no front document  or it has not ever been saved
		beep
		display dialog "there is no front document" &amp; return &amp; "or it has not been saved ever!" buttons {"Ok"} default button "Ok" with icon caution giving up after 5
		return
	end try
	
	set TeX_path to do shell script "dirname " &amp; quoted form of TeX_path
	
	-- Get the absolute path to the Root document
	try
		set Root_abs_path to POSIX path of (choose file with prompt "Pick the Root document:")
	on error
		return
	end try
	
	-- Use perl to convert the absolute path to the Root document 
	-- to a relative path to it.
	set command to "perl -e 'use File::Spec; "
	set command to command &amp; "$rel_path = File::Spec-&gt;abs2rel"
	set command to command &amp; "( \"" &amp; Root_abs_path &amp; "\","
	set command to command &amp; "\"" &amp; TeX_path &amp; "\" ) ; "
	set command to command &amp; "print $rel_path'"
	tell me to set Root_rel_path to do shell script command
	
	if relative then
		set i to 1
	else
		set i to 2
	end if
	
	set roots to {Root_rel_path, Root_abs_path}
	set the root to choose from list roots with prompt "Choose between a relative and absolute path:" default items item i of roots OK button name "OK" cancel button name "Cancel" without multiple selections allowed and empty selection allowed
	if the result is false then
		return
	end if
	
	-- The linefeed character
	set linefeed to ASCII character 10
	
	-- The whole text of the document
	set whole_document to (the text of the front document) as string
	
	-- The offset of the selection
	set selection_offset to offset of the selection of the front document
	
	-- The length of the selection
	set selection_length to length of the selection of the front document
	
	-- Find and delete a previous encoding specification
	-- (it will not handle more than one specification)
	set searchString1 to "%!TEX root ="
	set search1 to (search for searchString1 starting from 0) of front document
	set searchString2 to "% !TEX root ="
	set search2 to (search for searchString2 starting from 0) of front document
	
	if search1 * search2 &gt; 0 then
		if search1 &lt; search2 then
			set first_occurrence to search1
		else
			set first_occurrence to search2
		end if
	else if search1 &gt; 0 then
		set first_occurrence to search1
	else
		set first_occurrence to search2
	end if
	
	if first_occurrence &gt; 0 then
		set offset of selection of front document to (first_occurrence - 1)
		
		-- Get the offset of the line feed (or eof) ending the line containing "%!TEX root ="
		-- (here we use a "try" statement to avoid  needing to have a saved file
		-- from which we could get the "eof") 
		set i to first_occurrence
		set end_of_file to false
		set char to character i of whole_document
		repeat while char is not in {linefeed, return}
			set i to i + 1
			try
				set char to character i of whole_document
			on error
				set end_of_file to true
				exit repeat
			end try
		end repeat
		
		-- Detect if the line starts with "% !TEX root =" and it is not the last line,
		-- if so we will delete not only "% !TEX root =..." but the whole line
		if ((first_occurrence = 1) or (character (first_occurrence - 1) of whole_document is in {linefeed, return})) and not end_of_file then
			set i to i + 1
		end if
		
		set length of selection of front document to (i - first_occurrence)
		-- Delete the line
		set the content of the selection of the front document to ""
		
		-- We restore the selection the user had before invoking this script
		-- so we compute what the new selection_offset should be.
		if (selection_offset ≥ first_occurrence - 1) and (selection_offset &lt; i - 1) then
			set selection_offset to first_occurrence - 1
			set selection_length to 0
		else if selection_offset ≥ i - 1 then
			set selection_offset to selection_offset - (i - first_occurrence)
		end if
	end if
	
	set program to "% !TEX root = " &amp; root &amp; linefeed
	set selection_offset to selection_offset + (count of program)
	
	-- If the first line starts with "%&amp;" set the insertion offset
	-- to the beginning of the second line.
	try
		set first_line to paragraph 1 of the text of the front document as string
		if the first_line starts with "%&amp;" then
			set insertion_offset to count the characters of the first_line
			try
				get paragraph 2 of the text of the front document
			on error -- There is only one line?
				set selection_offset to selection_offset + 1
				set program to linefeed &amp; program
			end try
		else
			set insertion_offset to 0
		end if
	on error -- The document was empty?
		set insertion_offset to 0
	end try
	
	-- Insert Root
	set offset of the selection of the front document to insertion_offset
	set length of the selection of the front document to 0
	set content of the selection of the front document to program
	
	-- Restore the offset of the selection
	set offset of the selection of the front document to selection_offset
	
	-- Restore the length of the selection
	set length of the selection of the front document to selection_length
end tell</string>
			<key>key</key>
			<string></string>
			<key>name</key>
			<string>Root</string>
		</dict>
		<dict>
			<key>content</key>
			<string>&lt;!--
% !TEX TS-program = PreTeXt-LaTeX
--&gt;</string>
			<key>key</key>
			<string></string>
			<key>name</key>
			<string>PreTeXt Header</string>
		</dict>
		<dict>
			<key>content</key>
			<string>&lt;!--! xxxx --&gt;</string>
			<key>key</key>
			<string></string>
			<key>name</key>
			<string>PreText Personal Mark</string>
		</dict>
		<dict>
			<key>content</key>
			<string></string>
			<key>key</key>
			<string></string>
			<key>name</key>
			<string>Special Comments</string>
			<key>submenu</key>
			<array>
				<dict>
					<key>content</key>
					<string>% !TEX useTabs</string>
					<key>key</key>
					<string></string>
					<key>name</key>
					<string>Use Tabs</string>
				</dict>
				<dict>
					<key>content</key>
					<string>% !TEX useTabsWithFiles
</string>
					<key>key</key>
					<string></string>
					<key>name</key>
					<string>Use Tabs with Files</string>
				</dict>
				<dict>
					<key>content</key>
					<string>% !TEX tabbedFile{ #SEL##INS#}(optional short name )</string>
					<key>key</key>
					<string></string>
					<key>name</key>
					<string>Tabbed File</string>
				</dict>
				<dict>
					<key>content</key>
					<string>% !TEX pdfSinglePage</string>
					<key>key</key>
					<string></string>
					<key>name</key>
					<string>PDF Single Page</string>
				</dict>
				<dict>
					<key>content</key>
					<string>% !TEX spellcheck = #SEL##INS#</string>
					<key>key</key>
					<string></string>
					<key>name</key>
					<string>Spell Check</string>
				</dict>
				<dict>
					<key>content</key>
					<string>% !BIB program = #SEL##INS#</string>
					<key>key</key>
					<string></string>
					<key>name</key>
					<string>BIB Program</string>
				</dict>
				<dict>
					<key>content</key>
					<string>% !TEX parameter = #SEL##INS#
</string>
					<key>key</key>
					<string></string>
					<key>name</key>
					<string>Extra Parameter for Engine Call</string>
				</dict>
				<dict>
					<key>content</key>
					<string>% !TEX useOldSyncParser
</string>
					<key>key</key>
					<string></string>
					<key>name</key>
					<string>Use Old Sync Parser</string>
				</dict>
			</array>
		</dict>
		<dict>
			<key>content</key>
			<string>% !TEX root =  #INS#</string>
			<key>key</key>
			<string></string>
			<key>name</key>
			<string>Root (Short Version)</string>
		</dict>
		<dict>
			<key>content</key>
			<string></string>
			<key>key</key>
			<string></string>
			<key>name</key>
			<string>Separator</string>
		</dict>
		<dict>
			<key>content</key>
			<string>--Applescript direct
-- Script to insert a begin/end block
-- Ramon Figueroa-Centeno March 10, 2009

tell application "TeXShop"
	
	-- The linefeed character.
	set linefeed to ASCII character 10
	
	set TeX_delimiters to {linefeed, return, tab} &amp; characters of ¬
		" {}[](),:;.\\|/?!&lt;&gt;`'\"@#$%^~&amp;-+=" as list
	
	set the front_document to the front document
	-- set the front_document to document #DOCUMENTNAME#
	
	-- The whole text of the document
	set whole_document to (the text of the front_document) as string
	
	-- The offset of the selection
	set selection_offset to offset of the selection of the front_document
	
	repeat until (selection_offset = 0) or (character selection_offset of ¬
		the whole_document is in TeX_delimiters)
		set selection_offset to selection_offset - 1
	end repeat
	set the offset of the selection of the front_document to selection_offset
	
	set selection_length to 0
	
	try
		set next_character to character (selection_offset + selection_length + 1) of ¬
			the whole_document
		repeat until (next_character is in TeX_delimiters)
			set selection_length to selection_length + 1
			try
				set next_character to character (selection_offset + selection_length + 1) of ¬
					the whole_document
			on error
				-- reached the end of the document
				exit repeat
			end try
		end repeat
	end try
	set the length of the selection of the front_document to selection_length
	
	-- The selection is empty, so stop
	if selection_length = 0 then
		beep
		return
	end if
	
	set environment_name to the content of the selection of the front_document
	set begin_environment to "\\begin{" &amp; environment_name &amp; "}"
	set end_environment to "\\end{" &amp; environment_name &amp; "}"
	set environment to begin_environment &amp; linefeed &amp; " " &amp; linefeed &amp; end_environment
	set insertion_point to (count of begin_environment) + selection_offset + 3
	
	-- determine if we are the beginning of a line
	set at_the_beginning to ((selection_offset = 0) or (character selection_offset of ¬
		the whole_document is in {linefeed, return}))
	
	-- determine if we are at the end of a line
	-- (since we do not know if we are at the end of the document
	-- we use a "try" to avoid having to count the characters of the document)
	set at_the_end to false
	try
		if character (selection_offset + selection_length + 1) of ¬
			the whole_document is in {linefeed, return} then
			set at_the_end to true
		end if
	on error
		set at_the_end to true
	end try
	
	if at_the_beginning and at_the_end then
		-- say "at the beginning and the end"
		set the content of the selection of the front_document to ¬
			environment
		set the offset of the selection of the front_document to ¬
			insertion_point - 1
	else if at_the_beginning then
		-- say "at the beginning"
		set the content of the selection of the front_document to ¬
			environment &amp; linefeed
		set the offset of the selection of the front_document to ¬
			insertion_point
	else if at_the_end then
		-- say "at the end"
		set the content of the selection of the front_document to ¬
			linefeed &amp; environment
		set the offset of the selection of the front_document to ¬
			insertion_point
	else
		-- say "at the middle"
		set the content of the selection of the front_document to ¬
			linefeed &amp; environment &amp; linefeed
		set the offset of the selection of the front_document to ¬
			insertion_point
	end if
end tell</string>
			<key>key</key>
			<string></string>
			<key>name</key>
			<string>Insert Begin/End</string>
		</dict>
		<dict>
			<key>content</key>
			<string>--Applescript direct
-- Script to close a begin/end block
-- Ramon Figueroa-Centeno March 10, 2009

tell application "TeXShop"
	
	-- The linefeed character.
	set linefeed to ASCII character 10
	
	set the front_document to the front document
	-- set the front_document to document #DOCUMENTNAME#
	
	-- The whole text of the document
	set whole_document to (the text of the front_document) as string
	
	-- If the front document is not saved dump its 
	-- content to a temporary file and use that
	if the front_document is modified then
		tell me
			set texpath to do shell script "mktemp /tmp/XXXXXXXX"
			set TMP to POSIX file texpath
			open for access TMP with write permission
			write whole_document to TMP
			close access TMP
		end tell
	else
		set texpath to the path of the front_document
		-- set texpath to the #FILEPATH#
	end if
	
	-- The offset of the selection
	set selection_offset to offset of the selection of the front_document
	
	-- Move the insertion point to the beginning of the selected word.
	-- Unless we are at the end of a line.
	-- If one removes " " (space) from the list  the insertion point moves to the
	-- beginning of the line. 
	
	try
		if the character (selection_offset + 1) of the whole_document is not in {linefeed, return} then
			repeat until (selection_offset = 0) or ¬
				(character selection_offset of the whole_document is in {linefeed, return, " "})
				set selection_offset to selection_offset - 1
			end repeat
			set the offset of the selection of the front_document to selection_offset
		end if
	on error
		-- It appears that we are at the end of the file!
	end try
	
	-- Stop if the insertion point is at the beginning of the document
	if selection_offset = 0 then
		return
	end if
	
	-- The document up to the selection
	set partial_document to ¬
		(characters 1 thru (selection_offset) of the whole_document) as string
	
	-- Let selection_line_number be the number of the line of the start of the current selection
	set selection_line_number to count paragraphs of the partial_document
	
	set report to "selection line: " &amp; selection_line_number &amp; return
	
	-- The total number of lines
	set total_lines to count paragraphs of the whole_document
	
	set report to report &amp; "total # of lines: " &amp; total_lines &amp; return
	
	-- The "command" is a shell script that does this: 
	-- delete all comments:
	-- sed 's/%.*$//'  (or sed '/%.*$/ s/%.*$//' for speed)
	set command to " | sed '/%.*$/ s/%.*$//'"
	-- replace all "\" with a linefeed character:
	-- tr -s "\\" "\n" 
	set command to command &amp; " | tr -s \"\\\\\" \"\\n\""
	-- delete everything after and including the first "}":
	-- sed 's/}.*//'  (or sed '/}.*/ s/}.*//'  for speed)
	set command to command &amp; " | sed '/}.*/ s/}.*//'"
	-- keep only the lines that start with "begin{" or "end{":
	-- egrep -e '^begin{|^end{' 
	set command to command &amp; " | egrep -e '^begin{|^end{'"
	-- replace all "{" by spaces:
	-- tr -s "{" " " 
	set command to command &amp; " | tr -s \"{\" \" \""
	
	-- shell command to convert returns (\r) to line feeds (\n)
	set mac2unix to "tr \\\\r \\\\n"
	
	--select insertion point before the selection
	set length of the selection of the front_document to 0
	
	-- Divide the line of the selection into two chunks
	-- one before and another after the beginning of the selection
	try
		set firstLineChunk to the last paragraph of the partial_document
	on error
		set firstLineChunk to ""
	end try
	set the_line to paragraph selection_line_number of the whole_document
	try
		set secondLineChunk to characters ((count of the firstLineChunk) + 1) ¬
			thru (count of the_line) of the_line as string
	on error
		set secondLineChunk to ""
	end try
	
	-- Set list_1 to a list that contains strings, each with two words
	-- the first word is "begin" or "end" and the second is the 
	-- name of the corresponding environment
	
	set list_1 to {}
	
	set command_2 to ¬
		mac2unix &amp; " &lt; " &amp; (quoted form of texpath) ¬
		&amp; " | head -n " &amp; (selection_line_number - 1) &amp; command
	tell me to set parsed to do shell script command_2
	if parsed is not "" then
		set list_1 to list_1 &amp; (paragraphs of parsed)
	end if
	
	set command_2 to ¬
		"echo " &amp; (quoted form of firstLineChunk) &amp; " | " &amp; mac2unix &amp; command
	tell me to set parsed to do shell script command_2
	if parsed is not "" then
		set list_1 to list_1 &amp; (paragraphs of parsed)
	end if
	
	-- If list_1 is empty then there is no environment to close
	if (count of list_1) = 0 then
		beep
		say "There are no environments before this point."
		--display dialog "There are no environments before this point." buttons {"OK"} default button 1 with icon caution
		return
	end if
	
	set flips to 0
	repeat with i from (count list_1) to 1 by -1
		if word 1 of item i of list_1 is "end" then
			set flips to flips + 1
		else
			set flips to flips - 1
		end if
		
		if flips = -1 -- The next line does this:			-- The next line does this:
			-- but handles starred commands correctly
			tell me to  to set environment_name to do shell script ¬
				"echo \"" &amp; (item i of list_1) &amp; "\" |  sed '/.* / s/.* //'"
			exit repeat
		end if
		
	end repeat
	if not (flips = -1) then
		beep
		say "I did not find an open environment!"
		--display dialog "I did not find an open environment!" buttons {"OK"} default button 1 with icon caution
		return
	end if
	
	-- Now we check to see if the environment we are in is already closed
	
	set list_2 to {}
	
	set command_2 to ¬
		"echo " &amp; (quoted form of secondLineChunk) &amp; " | " &amp; mac2unix &amp; command
	tell me to set parsed to do shell script command_2
	if parsed is not "" then
		set list_2 to paragraphs of parsed
	end if
	
	set command_2 to ¬
		mac2unix &amp; " &lt; " &amp; (quoted form of texpath) ¬
		&amp; " | tail -n +" &amp; (selection_line_number + 1) &amp; command
	tell me to set parsed to do shell script command_2
	if parsed is not "" then
		set list_2 to list_2 &amp; (paragraphs of parsed)
	end if
	
	set close_environment to true
	
	if (count of list_2) &gt; 0 then
		set flips to 0
		repeat with i from 1 to (count list_2)
			if word 1 of item i of list_2 is "begin" then
				set flips to flips + 1
			else
				set flips to flips - 1
			end if
			if flips = -1 then
				-- The next line does this:
				-- set environment_name_2 to word 2 of item i of list_2
				-- but handles starred commands correctly
				set environment_name_2 to do shell script ¬
					"echo \"" &amp; (item i of list_2) &amp; "\" |  sed '/.* / s/.* //'"
				if environment_name_2 = environment_name then
					beep
					activate
					display dialog "The environment \"" &amp; environment_name ¬
						&amp; "\"" &amp; return &amp; "you are working on is already closed." &amp; return ¬
						&amp; "Do you still want to close it?" buttons {"No", "Yes"} ¬
						default button "No" with icon note
					set close_environment to (button returned of the result is not "No")
				end if
				exit repeat
			end if
		end repeat
	end if
	
	-- Close the environment
	if close_environment then
		if the_line = "" then
			set the content of the selection of the front_document to ¬
				"\\end{" &amp; environment_name &amp; "}"
		else
			-- If we are at the beginning of a line then close the environment
			-- and then enter a return. Otherwise, enter a return before doing so.
			if (character selection_offset of the whole_document is in {linefeed, return}) then
				set the content of the selection of the front_document to ¬
					"\\end{" &amp; environment_name &amp; "}" &amp; linefeed
			else
				set the content of the selection of the front_document to ¬
					linefeed &amp; "\\end{" &amp; environment_name &amp; "}" &amp; linefeed
			end if
		end if
	end if
	
	-- If a temporary file was created delete it.
	try
		do shell script "rm " &amp; POSIX path of TMP
	end try
	
end tell</string>
			<key>key</key>
			<string></string>
			<key>name</key>
			<string>Close Begin/End</string>
		</dict>
		<dict>
			<key>content</key>
			<string>--Applescript

-- "INSERT REFERENCE"
-- This script searches through the current file (or within every file in the current folder) for \label{...} commands, then pops up a list for you to choose from which you may insert one.
--The inserted reference label is wrapped in a (optional) customisable LaTeX command.
-- It will cut down the list to include only those entries that contain the current selection. So if you type "sec" and select it, then run this script, you will get a choice of only, e.g., "sec:intro","sec:conc","fig:secunia", but not other labels in your document e.g., "cha:monkey","equ:maxwell",etc. 

-- v2004-08-24


-- CUSTOMISE TO YOUR LIKING:

property ref_command : "ref" -- or "vref" or "fref" etc... N.B. no backslash!
-- Inserts e.g. "\ref{fig:ladle}" or "\vref{fig:ladle}" or ... based on this property
-- Put "" to insert the plain label: e.g. "fig:ladle" 

property only_scan_current_file : true
-- If false, the script will search through every .tex file in the folder containing the current file.
-- This is useful for projects with other \include{} -ed files in the same folder.
-- Otherwise, it will only look in the current file.

property sort_output : false
-- If false, displays labels in the order they're found in the document.
-- Otherwise, displays them in alphabetical order.

property save_before_run : true
-- The script only finds labels created in saved documents. If you don't want this script to save your document before it runs for whatever reason, set this to true.

--THE SCRIPT:


if save_before_run then
	tell application "TeXShop" to save the front document
end if

tell application "TeXShop" to set texpath to the path of the front document -- the current tex file: "/path/to/docu.tex"

if only_scan_current_file then
	set texfiles_tosearch to the quoted form of the texpath -- search the current file
else
	set texloc to POSIX file texpath -- Convert to applescript format: "path:to:docu.tex"
	tell application "Finder" to set texfolder to the container of (texloc as alias) -- Get the folder: "path:to:"
	set texdir to the POSIX path of (texfolder as alias) -- Convert to UNIX path: "/path/to"
	set texfiles_tosearch to the quoted form of texdir &amp; "*.tex" -- search all .tex files: "/path/to/*.tex"
end if

tell application "TeXShop"
	
	set current_selection to the content of the selection of the front document
	
	-- DO SHELL SCRIPT COMPONENTS:
	--set find_label_lines to ("grep -h '\\\\label' " &amp; texfiles_tosearch) as string
	set find_label_lines to ("cat " &amp; texfiles_tosearch &amp; " | tr '\\r' '\\n'  | grep '\\\\label{' " &amp; texfiles_tosearch) as string
	-- (Better commmand suggested by Matthew Hills which also converts the line-endings to UNIX form - thanks!)
	set trim_to_raw_labels to " | sed 's/.*\\\\label{//' | sed 's/}.*//'"
	set filter_selection to " | grep " &amp; quoted form of the current_selection
	if sort_output then
		set sort to " | sort -u"
	else
		set sort to ""
	end if
	
	-- glue the shell scripts together:
	set get_labels_shell_script to find_label_lines &amp; trim_to_raw_labels &amp; sort
	
	try
		-- filter choices with the current selection:
		set choose_labels to every paragraph of (do shell script get_labels_shell_script &amp; filter_selection)
	on error
		-- If it fails (e.g., nothing found) ask to diplay all labels:
		display dialog "No labels found that contain '" &amp; the current_selection &amp; "'. Would you like to view the whole list?" buttons {"Cancel", "View all"} default button "View all"
		if the button returned of the result is "View all" then
			set choose_labels to every paragraph of (do shell script get_labels_shell_script)
		else
			return -- exit script
		end if
	end try
	
	-- In case the document doesn't contain any labels:
	if choose_labels = {""} then
		display dialog "Sorry, no \\label{} items have been found." buttons {"No worries"} default button "No worries"
		return
	end if
	
	set label_insert to choose from list choose_labels with prompt "Please choose the label of the reference to insert:"
	if label_insert ≠ false then
		if ref_command = "" then
			set ref_insert to label_insert
		else
			set ref_insert to "\\" &amp; ref_command &amp; "{" &amp; label_insert &amp; "}"
		end if
		set the selection of the front document to ref_insert as string
	end if
	
end tell</string>
			<key>key</key>
			<string>R+ShiftKey</string>
			<key>name</key>
			<string>Insert reference</string>
		</dict>
		<dict>
			<key>content</key>
			<string>--applescript direct

property sort_output : false
-- If false, displays labels in the order they're found in the document.
-- Otherwise, displays them in alphabetical order.

property save_before_run : true
-- The script only finds labels created in saved documents. If you don't want this script to save your document before it runs for whatever reason, set this to true.

--Adapted from Will Robertson's Insert Reference by Michael Sharpe, 2012
--THE SCRIPT:


set tid to Applescript's text item delimiters
set docname to #DOCUMENTNAME#
if docname is equal to "" then
	display dialog "No document---bailing out."
	return
end if

if save_before_run then
	tell application "TeXShop" to save docname
end if

set texpath to #FILEPATH#

set texfiles_tosearch to the quoted form of the texpath -- search the current file

set q1 to display dialog "Choose from labels containing text:" default answer "" buttons {"Cancel", "Go"} default button "Go"
if the button returned of q1 is "Go" then
	set current_selection to text returned of q1
else
	return -- exit script
end if

-- DO SHELL SCRIPT COMPONENTS:
set find_label_lines to ("/bin/cat " &amp; texfiles_tosearch &amp; " | /usr/bin/tr '\\r' '\\n'  | /usr/bin/grep '\\\\label{' ") as string
set trim_to_raw_labels to " | /usr/bin/sed 's/.*\\\\label{//' | /usr/bin/sed 's/}.*//'"
set filter_selection to ""
if (count of current_selection) &gt; 0 then
	set filter_selection to " | /usr/bin/grep -i " &amp; quoted form of the current_selection
end if
if sort_output then
	set sort to " | /usr/bin/sort -u"
else
	set sort to ""
end if
-- glue the shell scripts together:
set get_labels_shell_script to find_label_lines &amp; trim_to_raw_labels &amp; sort

try
	-- filter choices with the current selection:
	set s to (do shell script get_labels_shell_script &amp; filter_selection)
	set choose_labels to every paragraph of s
on error
	-- If it fails (e.g., nothing found) ask to diplay all labels:
          if (count of current_selection) &gt; 0 then
	    display dialog "No labels found that contain '" &amp; the current_selection &amp; "'. Would you like to view the whole list?" buttons {"Cancel", "View all"} default button "View all"
	    if the button returned of the result is "View all" then
	   	set s to (do shell script get_labels_shell_script)
		set choose_labels to every paragraph of s
	    else
		return -- exit script
	    end if
        end if
end try

-- In case the document doesn't contain any labels:
if (count of choose_labels) is 0 then
	display dialog "Sorry, no \\label{} items have been found." buttons {"OK"} default button "OK"
	return
end if

set label_chosen to choose from list choose_labels with prompt "Please choose from names of matching labels:"
if label_chosen ≠ false then
   --set find_label_line to ("/bin/cat " &amp; texfiles_tosearch &amp; " | /usr/bin/tr '\\r' '\\n'  | /usr/bin/grep -n '\\\\label{" &amp; label_chosen &amp;"}'") as string
   --set s to (do shell script find_label_line)
   --set Applescript's text item delimiters to ":"
   --set j to item 1 of (s as list)
   --set Applescript's text item delimiters to tid
   set j to 7+(count of (item 1 of label_chosen))

   tell application "TeXShop" --to tell document docname to goto line j
            set i to search document docname for "\\label{" &amp; label_chosen &amp; "}" starting from 1
            set offset of selection of document docname to i
            set length of selection of document docname to j
            tell application "System Events" to tell process "TeXShop" to keystroke (ASCII character 28) using {shift down}
    end tell
end if

</string>
			<key>key</key>
			<string></string>
			<key>name</key>
			<string>Goto label</string>
		</dict>
		<dict>
			<key>content</key>
			<string>-- Applescript direct

-- OPEN QUICKLY...
-- The idea for this script was stolen from iTeXMac.
-- This script pops up a dialog box with a list of  files in the current directory.
-- The selection (multiple allowed) is opened.

-- CUSTOMISE TO YOUR LIKING:
property extensions_to_open : {"tex", "sty", "pdf"}


-- THE SCRIPT:

--get the path to the current tex file - "/path/to/docu.tex":
tell application "TeXShop" to set texpath to the path of the front document

-- Convert to applescript format - "path:to:docu.tex"
set texloc to POSIX file texpath
-- Get the folder it's in - "path:to:"
tell application "Finder" to set texfolder to the container of (texloc as alias)
-- Get the path to the folder - "/path/to/"
set texdir to the POSIX path of (texfolder as alias)
-- Get a list of all the filenames to open:
set texfiles to the name of every file of texfolder whose name extension is in extensions_to_open

tell application "TeXShop" to set openfiles to choose from list texfiles with prompt "Which file(s) do you wish to open?" with multiple selections allowed
if openfiles is not false then
	repeat with this_filename in openfiles
		set file_to_open to POSIX file (texdir &amp; this_filename)
		tell application "TeXShop" to open file_to_open
	end repeat
end if</string>
			<key>key</key>
			<string>O+ShiftKey</string>
			<key>name</key>
			<string>Open quickly…</string>
		</dict>
		<dict>
			<key>content</key>
			<string>--Applescript direct

-- Choose a font set defined in ~/Library/TeXShop/Templates/SetFonts.tex
-- The companion script SaveFontSet allows you to save your font set to that file.
-- Font set commands are inserted between an existing pair of %SetFonts lines.
-- In none are found, they are created following the documentclass line.
-- Michael Sharpe, msharpe@ucsd.edu
--Last revision: 8/11/2014

property lf: linefeed
set path_to_setfonts to (POSIX path of (((path to home folder) as string) &amp; "Library:TeXShop:bin:SetFonts.tex"))
set msg to 0
tell application "Finder" to if exists path_to_setfonts as POSIX file then set msg to 1
set thefile to POSIX file path_to_setfonts
if msg = 0 then
	set ref_num to open for access thefile with write permission
	set eof of ref_num to 0
	write lf &amp; "%SetFonts" &amp; lf to ref_num
	write "% Latin Modern" &amp; lf to ref_num
	write "% Extension of CM text+math" &amp; lf to ref_num
	write "\\usepackage{lmodern} % math, rm, ss, tt" &amp; lf to ref_num
	write "\\usepackage[T1]{fontenc}" &amp; lf to ref_num
	write "\\usepackage{textcomp}" &amp; lf to ref_num
	write "\\usepackage[bb=boondox,frak=boondox,cal=rsfso]{mathalfa}" &amp; lf to ref_num
	close access thefile
end if
open for access thefile
set file_contents to (read thefile)
close access (thefile)
set oldtid to AppleScript's text item delimiters
set AppleScript's text item delimiters to lf &amp; "%SetFonts"
set fontlist to the text items of file_contents
--check for DEFAULT setting in item 1
set dflt to ""
try
	set AppleScript's text item delimiters to lf
	set defline to last paragraph of (item 1 of fontlist)
	--display dialog "defline=" &amp; defline
	if (count of defline) &gt; 8 then
		if (text 1 thru 8 of defline) = "DEFAULT=" then
			set dflt to trim(true, text 9 thru (count of defline) of defline)
		end if
	end if
on error
	
end try

--display dialog "Dflt=" &amp; dflt
set namelist to {}
set fcnt to count (fontlist)
--display dialog "fcnt=" &amp; fcnt as string
if fcnt &gt; 1 then
	repeat with i from 2 to fcnt
		try
			set s to trim(true, item i of fontlist)
			set end of namelist to trim(true, text 2 thru -1 of first paragraph of s)
		on error
			set end of namelist to "---"
		end try
	end repeat
end if
set sortednamelist to {"&lt;none&gt;"} &amp; sort(namelist)
set dfltndx to 1
if (count of dflt) &gt; 0 then set dfltndx to getidx(dflt, sortednamelist)
if dfltndx = 0 then set dfltndx to 1
choose from list sortednamelist with prompt "Pick a font set:" default items item dfltndx of sortednamelist OK button name "OK" cancel button name "Cancel" without multiple selections allowed and empty selection allowed
if the result is false then
	return
else
	set fs to result as string
end if
set fsidx to getidx(fs, namelist) + 1
if fsidx = 1 then
	set newfs to lf
else
	set newfs to lf &amp; (item fsidx of fontlist)
	repeat while item -1 of newfs is lf
		set newfs to text 1 thru -2 of newfs
	end repeat
end if
--break the document into 3 pieces--part before 1st %SetFonts,between and after 2nd
tell application "TeXShop"
	set whole_document to (the text of the front document) as string
end tell
set AppleScript's text item delimiters to lf &amp; "\\begin{document}"
set prepost to text items of whole_document
set preamble to (item 1 of prepost)
set AppleScript's text item delimiters to lf &amp; "%SetFonts"
set doc_items to the text items of preamble
set AppleScript's text item delimiters to oldtid
set n to count of doc_items
if n &gt; 3 then
	display dialog "Your preamble contains more than two %SetFonts lines. Bailing out." buttons "OK" default button "OK"
	return
else
	if n = 2 then
		display dialog "Your preamble contains only one %SetFonts line. Bailing out." buttons "OK" default button "OK"
		return
	end if
end if
if n = 3 then
	set item 2 of doc_items to lf &amp; trim(true, newfs)
	set AppleScript's text item delimiters to lf &amp; "%SetFonts"
	set preamble to doc_items as string
	set whole_document to preamble &amp; lf &amp; "\\begin{document}" &amp; (item 2 of prepost)
	set AppleScript's text item delimiters to oldtid	
else
	if n = 1 then
		--set shortdoc to text 1 thru 1000 of whole_document
		set AppleScript's text item delimiters to lf
		set doclines to text items of whole_document
		set k to count of doclines
		if k&gt;20 then set k to 20
		set j to 0
		repeat with i from 1 to k
			set j to stroffset("documentclass",item i of doclines)
			if j &gt; 0 then exit repeat
		end repeat
		if i = k then
			display dialog "Your document contains no \\documentclass line. Bailing out." buttons "OK" default button "OK"
		else
			set i to (i + 1)
			--set doclines to text items of whole_document
			set item i of doclines to "%SetFonts" &amp; lf &amp; trim(true,newfs) &amp; lf &amp; "%SetFonts" &amp; lf &amp; (item i of doclines)
			set whole_document to doclines as string
		end if
	end if
end if
tell application "TeXShop"
	set (the text of the front document) to whole_document
	-- save front document using its current location
        set cdate to (current date) + 30 -- allow 30 seconds for timeout
	try
		tell application "TeXShop" to save front document
	on error number errnum
		if (errnum = -1712) and ((current date) &lt; cdate) then
			set Liberrmsg to ""
		end if
	end try
end tell
set AppleScript's text item delimiters to oldtid

do shell script "~/Library/TeXShop/bin/refreshfront &amp;&gt; /dev/null &amp;"

on getidx(this_item, this_list)
	if this_item = "&lt;none&gt;" then
		return 0
	else
		set n to the count of this_list
		repeat with i from 1 to n
			if item i of this_list is this_item then return i
		end repeat
		return 0
	end if
end getidx

on sort(the_list)
	set old_delims to AppleScript's text item delimiters
	set AppleScript's text item delimiters to {ASCII character 10}
	set list_string to (the_list as string)
	set new_string to do shell script "echo " &amp; quoted form of list_string &amp; " | sort -f -u"
	set new_list to (paragraphs of new_string)
	set AppleScript's text item delimiters to old_delims
	return new_list
end sort

on trim(theseCharacters, someText)
	-- Lazy default (AppleScript doesn't support default values)
	if theseCharacters is true then set theseCharacters to ¬
		{space, tab, lf, return}
	
	try
		repeat until first character of someText is not in theseCharacters
			if (count someText) &gt; 1 then
				set someText to text 2 thru -1 of someText
			else
				set someText to ""
				exit repeat
			end if
		end repeat
	on error
		set someText to ""
	end try
	try
		repeat until last character of someText is not in theseCharacters
			set someText to text 1 thru -2 of someText
		end repeat
	on error
		set someText to ""
	end try
	return someText
end trim

on stroffset(find_str,whole_str) 
--replacement for offset, which fails in late 2011 TeXShop applescript direct
--note that length fails too, but may be replaced by count
	if (count of whole_str)=0 then return 0
	if (count of find_str)=0 then return 0
	set tid to Applescript's text item delimiters
	set Applescript's text item delimiters to {find_str}
	set lst to text items of whole_str
	set Applescript's text item delimiters to tid
	if (count of lst)=1 then
		return 0
	else
		return (count of (item 1 of lst)+1)
	end if
end stroffset</string>
			<key>key</key>
			<string></string>
			<key>name</key>
			<string>GetFontSet</string>
		</dict>
		<dict>
			<key>content</key>
			<string>--Applescript direct

-- Save a font set to ~/Library/TeXShop/bin/SetFonts.tex
-- The companion script setfonts allows you to choose a font set from that file.
-- Font set commands are delimited by %SetFonts lines.
-- In none are found, the script fails.
-- If you add DELETE after the first %SetFonts (same line), SaveFontSet deletes the item.
-- The line following the first %SetFonts must be %&lt;title&gt;, where &lt;title&gt; is the ID for the set..
-- If you add DEFAULT after the first %SetFonts (same line), 
-- SaveFontSet makes it the default selection when using setfonts.
--Last revised 01/11/2011
-- Michael Sharpe, msharpe@ucsd.edu
global lf
set lf to (ASCII character 10)
set path_to_setfonts to (POSIX path of (((path to home folder) as string) &amp; "Library:TeXShop:bin:SetFonts.tex"))
set msg to 0
tell application "Finder" to if exists path_to_setfonts as POSIX file then set msg to 1
set thefile to POSIX file path_to_setfonts
if msg = 0 then
	set ref_num to open for access thefile with write permission
	set eof of ref_num to 0
	write lf &amp; "%SetFonts" &amp; lf to ref_num
	write "% Latin Modern" &amp; lf to ref_num
	write "% Extension of CM text+math" &amp; lf to ref_num
	write "\\usepackage{lmodern} % math, rm, ss, tt" &amp; lf to ref_num
	write "\\usepackage[T1]{fontenc}" &amp; lf to ref_num
	write "\\usepackage{textcomp}" &amp; lf to ref_num
	write "\\usepackage[bb=boondox,frak=boondox,cal=rsfso]{mathalfa}" &amp; lf to ref_num
	close access thefile
end if
open for access thefile
set file_contents to (read thefile)
close access (thefile)
set oldtid to AppleScript's text item delimiters
set AppleScript's text item delimiters to lf&amp;"%SetFonts"
set fontlist to the text items of file_contents
set namelist to {}
set fcnt to count (fontlist)
if fcnt &gt; 1 then
	repeat with i from 2 to fcnt
		try
			set s to trim(true, item i of fontlist)
			set end of namelist to trim(true, text 2 thru -1 of first paragraph of s)
		on error
			set end of namelist to "---"
		end try
		--set end of namelist to trim(true, text 2 thru -1 of first paragraph of item i of fontlist)
	end repeat
end if

--break the document into 3 pieces--part before 1st %SetFonts,between and after 2nd
tell application "TeXShop"
	set whole_document to (the text of the front document) as string
end tell
set AppleScript's text item delimiters to lf &amp; "\\begin{document}"
set prepost to text items of whole_document
set preamble to (item 1 of prepost)
set AppleScript's text item delimiters to lf &amp; "%SetFonts"
set doc_items to the text items of preamble
set AppleScript's text item delimiters to oldtid
set n to count of doc_items

if not (n = 3) then
	display dialog "Your preamble does not contains exactly two %SetFonts lines. Bailing out." buttons "OK" default button "OK"
	return
end if
set s to item 2 of doc_items
set L to stroffset(lf,s) - 1
set flag to 0 --1 for DELETE, 2 for DEFAULT
if L &gt; 5 then
	set t to trim(true, text 1 thru L of s)
	if t = "DELETE" then
		set flag to 1
	else
		if t = "DEFAULT" then
			set flag to 2
		end if
	end if
end if

set newfs to trim(true, text (L + 2) thru (count of s) of s)
if first character of newfs is not "%" then
	display dialog "Your %SetFonts block lacks a title beginning with %. Bailing out." buttons "OK" default button "OK"
	return
end if
set fs to trim(true, text 2 thru -1 of first paragraph of newfs)
if count of fs is 0 then
	display dialog "Your %SetFonts block lacks a non-empty title. Bailing out." buttons "OK" default button "OK"
	return
end if
set fsidx to getidx(fs, namelist) + 1
--check for existing DEFAULT
set dfltflag to false
try
	set AppleScript's text item delimiters to lf
	set defline to last paragraph of (trim(true, item 1 of fontlist))
	--display dialog "defline=" &amp; defline
	if (count of defline) &gt; 8 then
		if (text 1 thru 8 of defline) = "DEFAULT=" then
			set dfltflag to true
		end if
	end if
on error
	
end try
if flag = 2 then
	if dfltflag then --there is an existing DEFAULT
		set deflines to text items of trim(true, item 1 of fontlist)
		--display dialog "deflines(-1)=" &amp; item -1 of deflines
		set item -1 of deflines to "DEFAULT=" &amp; fs
		set (item 1 of fontlist) to deflines as string
	else
		set (item 1 of fontlist) to (item 1 of fontlist) &amp; lf &amp; "DEFAULT=" &amp; fs
	end if
end if
if fsidx = 1 then --not in current list
	if flag = 0 then
		set end of fontlist to lf &amp; trim(true, newfs)
	else
		if flag = 1 then --DELETE
			display dialog "Cannot delete--name not found. Bailing out." buttons "OK" default button "OK"
			return
		end if
	end if
else
	if flag = 0 then
		set item fsidx of fontlist to lf &amp; trim(true, newfs)
	else
		if flag = 1 then --DELETE
			if fsidx = (count of fontlist) then
				set fontlist to items 1 thru -2 of fontlist
			else
				set fontlist to items 1 thru (fsidx - 1) of fontlist &amp; items (fsidx + 1) thru -1 of fontlist
			end if
		end if
	end if
end if
set ref_num to open for access thefile with write permission
set eof of ref_num to 0
set AppleScript's text item delimiters to lf &amp; "%SetFonts"
write (fontlist as string) to ref_num
close access thefile
display dialog "Your %SetFonts block was saved to SetFonts.tex." buttons "OK" default button "OK"
--whole_document

on getidx(this_item, this_list)
	if this_item = "&lt;none&gt;" then
		return 0
	else
		set n to the count of this_list
		repeat with i from 1 to n
			if item i of this_list is this_item then return i
		end repeat
		return 0
	end if
end getidx

on sort(the_list)
	set old_delims to AppleScript's text item delimiters
	set AppleScript's text item delimiters to {ASCII character 10}
	set list_string to (the_list as string)
	set new_string to do shell script "echo " &amp; quoted form of list_string &amp; " | sort -f -u"
	set new_list to (paragraphs of new_string)
	set AppleScript's text item delimiters to old_delims
	return new_list
end sort

on trim(theseCharacters, someText)
	-- Lazy default (AppleScript doesn't support default values)
	if theseCharacters is true then set theseCharacters to ¬
		{" ", tab, ASCII character 10}
	
	repeat until first character of someText is not in theseCharacters
		set someText to text 2 thru -1 of someText
	end repeat
	
	repeat until last character of someText is not in theseCharacters
		set someText to text 1 thru -2 of someText
	end repeat
	
	return someText
end trim

on stroffset(find_str,whole_str) 
--replacement for offset, which fails in late 2011 TeXShop applescript direct
--note that length fails too, but may be replaced by count
	if (count of whole_str)=0 then return 0
	if (count of find_str)=0 then return 0
	set tid to Applescript's text item delimiters
	set Applescript's text item delimiters to {find_str}
	set lst to text items of whole_str
	set Applescript's text item delimiters to tid
	if (count of lst)=1 then
		return 0
	else
		return (count of (item 1 of lst)+1)
	end if
end stroffset</string>
			<key>key</key>
			<string></string>
			<key>name</key>
			<string>SaveFontSet</string>
		</dict>
		<dict>
			<key>content</key>
			<string>--AppleScript direct

--- Test a font set.
-- Font set commands are delimited by %SetFonts lines.
-- In none are found, the script fails.
--Prepares a report showing relative sizes of fonts in the set.
--Useful for fine-tuning the scale factors to better match your fonts.

--Last revised 01/12/2011
-- Michael Sharpe, msharpe@ucsd.edu
global lf
set lf to (ASCII character 10)

--break the document into 3 pieces--part before 1st %SetFonts,between and after 2nd
tell application "TeXShop"
	set whole_document to (the text of the front document) as string
end tell
set oldtid to AppleScript's text item delimiters
set AppleScript's text item delimiters to lf &amp; "\\begin{document}"
set prepost to text items of whole_document
set preamble to (item 1 of prepost)
set AppleScript's text item delimiters to lf &amp; "%SetFonts"
set doc_items to the text items of preamble
set AppleScript's text item delimiters to oldtid
set n to count of doc_items

if not (n = 3) then
	display dialog "Your preamble does not contains exactly two %SetFonts lines. Bailing out." buttons "OK" default button "OK"
	return
end if
set fontblock to trim(true,item 2 of doc_items)
set pre to "\\documentclass{article}" &amp; lf ¬
	&amp; "%\\batchmode" &amp; lf ¬
	&amp; "\\setlength\\parindent{0pt}" &amp; lf ¬
	&amp; "\\usepackage[papersize={3in,2.5in},margin=0in]{geometry}" &amp; lf ¬
	&amp; "\\usepackage{lmodern,amsfonts,mathrsfs}" &amp; lf ¬
	&amp; "\\usepackage{graphicx}" &amp; lf ¬
	&amp; "\\pagestyle{empty}" &amp; lf ¬
	&amp; "\\setlength\\unitlength{1in}"&amp; lf¬
	&amp; fontblock &amp; lf ¬
	&amp; "\\begin{document}" &amp; lf ¬
	&amp; "\\begin{picture}(3,2.5)" &amp; lf¬
	&amp; "\\put(.25,0){\\scalebox{20}{"
set post to "}}\\end{picture}" &amp;lf &amp; "\\end{document}"&amp;lf

set cmds to {"X", "\\textsf{X}", "\\texttt{X}", "$X$", ¬
	"$\\mathcal{X}$", "$\\mathbb{X}$", "$\\mathfrak{X}$", "$\\mathscr{X}$","x", "\\textsf{x}", "\\texttt{x}", "$x$"}
set sizes to {"", "", "", "", "", "", "", "","","","",""}
set glyphsource to {"", "", "", "", "", "", "", "","","","",""}

repeat with i from 1 to 12
	set t to ((path to temporary items) as string &amp; "tempfn" &amp; (i as string) &amp; ".tex")
	set thefile to (POSIX path of t)
	set ref_num to open for access thefile with write permission
	set eof of ref_num to 0
	write pre to ref_num
	write (item i of cmds) &amp; post to ref_num
--	write "\\setbox0=\\hbox{"&amp;(item i of cmds)&amp;"}"&amp;lf to ref_num
--	write "\\newwrite\\foo \\immediate\\openout\\foo=tempfn"&amp;(i as string)&amp;".txt \\immediate\\write\\foo{\\the\\dp0}" to ref_num
--	write "\\closeout\\foo"&amp;lf to ref_num
--	write "\\end{document}" &amp; lf to ref_num
	close access thefile

	try
		set s to (do shell script ("cd \"${TMPDIR}/TemporaryItems\"&amp;&amp;/Library/TeX/texbin/pdflatex tempfn" &amp; (i as string)))
	on error errmsg number errnum
		set AppleScript's text item delimiters to oldtid
		display dialog "pdflatex returned error :"&amp; (errnum as string)&amp;": "&amp;errmsg &amp;" while processing tempfn"&amp;(i as string)&amp;".tex --bailing out."
		return
	end try
	set logfile to (POSIX path of ((path to temporary items) as string &amp; "tempfn" &amp; (i as string) &amp; ".log"))
	open for access logfile
	set file_contents to (read logfile)
	close access (logfile)
	set AppleScript's text item delimiters to "you used:"
	set lst to the text items of file_contents
	if (count of lst) is not equal to 2 then
		set AppleScript's text item delimiters to oldtid
		display dialog "Pdflatex log error--bailing out"
		return
	end if
	set s to (item 2 of lst)
	set AppleScript's text item delimiters to {"&lt;", "&gt;"}
	set lst to the text items of s
	if (count of lst)&lt;2 then
		set AppleScript's text item delimiters to oldtid
		display dialog "Unexpected log contents---bailing out."
		return
	end if
	set AppleScript's text item delimiters to "/"
	set fpath to text items of (item 2 of lst)
	set (item i of glyphsource) to clean(item -1 of fpath)
	try
		set s to (do shell script (¬
			"cd \"${TMPDIR}/TemporaryItems\"&amp;&amp;" &amp; ¬
			"/usr/local/bin/gs  -dSAFER -dBATCH -dNOPAUSE -q -r3600 -sDEVICE=bbox -sOutputFile=- " &amp; "-c \"/setpagedevice {pop} def\" -f tempfn" &amp; (i as string) &amp; ¬
			".pdf -c quit 2&gt;&amp;1 | " &amp; "/usr/bin/awk '/HiRes/ { printf \"%4u\", ($5 - $3)*5.01875+0.5 }'"))
		--set k to (s as integer)
		--set t to ((path to temporary items) as string &amp; "tempfn" &amp; (i as string) &amp; ".txt")
		--set thefile to (POSIX path of t)
		--open for access thefile
		--set dp to (read thefile)
		--close access (thefile)
		--set dp to (text 1 thru -3 of trim(true,dp))
		--set k to k-(((dp as number)*100+.5) as integer)
		--set s to (k as string)
	on error
		set s to "0"
	end try
	set (item i of sizes) to trim(true,s)
end repeat

--finally, create report--bg8.pdf must be available somewhere in the texmf (tex/latex) trees
--must first close file if open in texshop
try
	tell application "TeXShop"
		if (exists  document "tempfnrep.tex") then
			close document "tempfnrep.tex"
		else
			if  (exists  document "tempfnrep") then close document "tempfnrep"
		end if
	end tell
on error --catch errors like timeout errors
end try
set repcontent to "\\documentclass{article}"&amp;lf¬
&amp;"%\\batchmode"&amp;lf¬
&amp;"\\setlength\\parindent{0pt}"&amp;lf¬
&amp;"\\usepackage[landscape,margin=.5in]{geometry}"&amp;lf¬
&amp; "\\usepackage{lmodern,amsfonts,mathrsfs}" &amp; lf ¬
&amp;"\\usepackage{xcolor,graphicx}"&amp;lf¬
&amp;"\\usepackage{multido}"&amp;lf¬
&amp;"\\setlength\\unitlength{80pt}"&amp;lf¬
&amp;"\\def\\myr{\\color{red!50}}"&amp;lf¬
&amp;fontblock&amp;lf¬
&amp;"\\pagestyle{empty}"&amp;lf¬
&amp;"\\def\\wid{8.89pt}"&amp;lf¬
&amp;"\\begin{document}"&amp;lf¬
&amp;"\\begin{picture}(8,1.1)"&amp;lf¬
&amp;"\\put(0,0){\\includegraphics{bg8.pdf}}"&amp;lf¬
&amp;"\\put(0,.16){\\scalebox{9}{\\hbox to \\wid{X\\hfil}}}"&amp;lf¬
&amp;"\\put(0,.16){\\scalebox{9}{\\myr\\hbox to \\wid{\\hfil x}}}"&amp;lf¬
&amp;"\\put(1,.16){\\scalebox{9}{\\hbox to \\wid{\\textsf{X}\\hfil}}}"&amp;lf¬
&amp;"\\put(1,.16){\\scalebox{9}{\\myr\\hbox to \\wid{\\hfil\\textsf{x}}}}"&amp;lf¬
&amp;"\\put(2,.16){\\scalebox{9}{\\hbox to \\wid{\\texttt{X}\\hfil}}}"&amp;lf¬
&amp;"\\put(2,.16){\\scalebox{9}{\\myr\\hbox to \\wid{\\hfil\\texttt{x}}}}"&amp;lf¬
&amp;"\\put(3,.16){\\scalebox{9}{\\hbox to \\wid{$X$\\hfil}}}"&amp;lf¬
&amp;"\\put(3,.16){\\scalebox{9}{\\myr\\hbox to \\wid{\\hfil$x$}}}"&amp;lf¬
&amp;"\\put(4,.16){\\scalebox{9}{\\hbox to \\wid{{\\hfil$\\mathcal{X}$\\hfil}}}}"&amp;lf¬
&amp;"\\put(5,.16){\\scalebox{9}{\\hbox to \\wid{\\hfil$\\mathbb{X}$\\hfil}}}"&amp;lf¬
&amp;"\\put(6,.16){\\scalebox{9}{\\hbox to \\wid{\\hfil$\\mathfrak{X}$\\hfil}}}"&amp;lf¬
&amp;"\\put(7,.16){\\scalebox{9}{\\hbox to \\wid{\\hfil$\\mathscr{X}$\\hfil}}}"&amp;lf¬
&amp;"\\multido{\\i=0+1,\\ia=1+1}{8}"&amp;lf¬
&amp;"{\\put (\\i,-.2){\\hbox to 80pt{\\hfil\\ia\\hfil}}}"&amp;lf¬
&amp;"\\end{picture}"&amp;lf¬
&amp;"\\vspace{2pc}"&amp;lf¬
&amp;"\\begin{tabbing}"&amp;lf¬
&amp;"Key \\= Height----- \\= Type\\hspace{7pc} \\= \\verb|$\\mathfrak{XXX}$| \\= \\kill"&amp;lf¬
&amp;"Key \\&gt; Height \\&gt; Type\\&gt; Command \\&gt; Glyph source file\\\\"&amp;lf¬
&amp;"1 \\&gt; "&amp;(item 1 of sizes)&amp;"/"&amp;(item 9 of sizes)&amp;" \\&gt; Roman \\&gt;X/x \\&gt; \\texttt{"&amp;(item 1 of glyphsource)&amp;"}\\\\"&amp;lf¬
&amp;"2 \\&gt; "&amp;(item 2 of sizes)&amp;"/"&amp;(item 10 of sizes)&amp;" \\&gt; Sans Serif \\&gt; \\verb|\\textsf{X/x}| \\&gt; \\texttt{"&amp;(item 2 of glyphsource)&amp;"}\\\\"&amp;lf¬
&amp;"3 \\&gt; "&amp;(item 3 of sizes)&amp;"/"&amp;(item 11 of sizes)&amp;" \\&gt; Typewriter \\&gt; \\verb|\\texttt{X/x}| \\&gt; \\texttt{"&amp;(item 3 of glyphsource)&amp;"}\\\\"&amp;lf¬
&amp;"4 \\&gt; "&amp;(item 4 of sizes)&amp;"/"&amp;(item 12 of sizes)&amp;" \\&gt; Math Italic \\&gt; \\verb|$X/x$| \\&gt; \\texttt{"&amp;(item 4 of glyphsource)&amp;"}\\\\"&amp;lf¬
&amp;"5 \\&gt; "&amp;(item 5 of sizes)&amp;" \\&gt; Math Calligraphic \\&gt;\\verb|$\\mathcal{X}$| \\&gt; \\texttt{"&amp;(item 5 of glyphsource)&amp;"}\\\\" &amp;lf¬
&amp;"6 \\&gt; "&amp;(item 6 of sizes)&amp;" \\&gt; Math Blackboard Bold \\&gt; \\verb|$\\mathbb{X}$| \\&gt; \\texttt{"&amp;(item 6 of glyphsource)&amp;"}\\\\"&amp;lf¬
&amp;"7 \\&gt; "&amp;(item 7 of sizes)&amp;" \\&gt; Math Fraktur \\&gt; \\verb|$\\mathfrak{X}$| \\&gt; \\texttt{"&amp;(item 7 of glyphsource)&amp;"}\\\\"&amp;lf¬
&amp;"8 \\&gt; "&amp;(item 8 of sizes)&amp;" \\&gt; Math Script \\&gt; \\verb|$\\mathscr{X}$| \\&gt; \\texttt{"&amp;(item 8 of glyphsource)&amp;"}\\\\"&amp;lf¬
&amp;"\\end{tabbing}"&amp;lf¬
&amp;"\\vspace{1pc}"&amp;lf¬
&amp;"\\textbf{Font commands:}"&amp;lf¬
&amp;"\\begin{verbatim}"&amp;lf¬
&amp;fontblock&amp;lf¬
&amp;"\\end{verbatim}"&amp;lf¬
&amp;"\\end{document}"

set t to ((path to temporary items) as string &amp; "tempfnrep.tex")
set thefile to (POSIX path of t)
set ref_num to open for access thefile with write permission
set eof of ref_num to 0
write repcontent to ref_num
close access thefile
try
	set s to (do shell script ("cd \"${TMPDIR}/TemporaryItems\"&amp;&amp;/Library/TeX/texbin/pdflatex tempfnrep"))
on error errmsg
	set AppleScript's text item delimiters to oldtid
	display dialog "pdflatex returned error: "&amp;errmsg&amp;lf&amp;"while processing tempfnref.tex --bailing out."
	return
end try
set s to do shell script "open -a TeXShop.app " &amp; quoted form of (POSIX path of t)

on trim(theseCharacters, someText)
	-- Lazy default (AppleScript doesn't support default values)
	if theseCharacters is true then set theseCharacters to ¬
		{" ", tab, ASCII character 10}
	
	repeat until first character of someText is not in theseCharacters
		set someText to text 2 thru -1 of someText
	end repeat
	
	repeat until last character of someText is not in theseCharacters
		set someText to text 1 thru -2 of someText
	end repeat
	
	return someText
end trim

on clean(someText)
	--get rid of all internal lf
	set thetid to Applescript's text item delimiters
	set Applescript's text item delimiters to lf
	set fields to text items of someText
	set Applescript's text item delimiters to ""
	set someText to (fields as string)
	set Applescript's text item delimiters to thetid
	return someText
end clean</string>
			<key>key</key>
			<string></string>
			<key>name</key>
			<string>TestFontSet</string>
		</dict>
		<dict>
			<key>content</key>
			<string>--Applescript direct
--Michael Sharpe, 2015/02/05

--select rows of a table, then run macro to align vertically along &amp; and \\
--no spaces are added around &amp; and \\ --for that, use Tabularize +space

property myrawlia : {}
property myrawlib : {}
property myrawlic : {}
property myrawsi : {}
property myrawstrt : {}

set myrawlia to {}
set myrawlib to {}
set myrawlic to {}
set myrawsi to {}
set myrawstrt to {}
set lia to a reference to myrawlia
set lib to a reference to myrawlib
set lic to a reference to myrawlic
set si to a reference to myrawsi
set strt to a reference to myrawstrt

set tid to AppleScript's text item delimiters
tell application "TeXShop" to set s to (content of selection of document 1)
if (count of s) = 0 then
	display dialog "No text selected!"
	return
end if
global longs, longl
set longs to "                                                                                                    " --100 space characters
set longl to {"", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", ""} --list of 100 empty strings
--used in makestr and makelst
set dblnull to (character id 0) &amp; (character id 0)
set nullone to (character id 0) &amp; (character id 1)

set AppleScript's text item delimiters to {"\\&amp;"}
set ss to (text items of s)
set AppleScript's text item delimiters to {dblnull}
set s to (ss as text) -- each \&amp; now replaced by a pair of nulls
set AppleScript's text item delimiters to {"\\\\%"}
set ss to (text items of s)
set AppleScript's text item delimiters to {"\\\\ %"}
set s to (ss as text) -- each \\% now replaced by a \\ %
set AppleScript's text item delimiters to {"\\%"}
set ss to (text items of s)
set AppleScript's text item delimiters to {nullone}
set s to (ss as text) -- each \% now replaced by a nullone
set li to (paragraphs of s) --lines, separated by cr or lf
set n to count of li

set lia to makelst(n)
copy lia to lib
copy lia to lic
copy lia to strt --starting offset for next row, usually 0
copy lia to si
set colwidth to 0 --max number of columns in selected rows
set offs to 0 --initial offset for first row
set cont to false --true indicates next line is continued from current
repeat with i from 1 to n
	set t to removeWS(item i of li)
	set AppleScript's text item delimiters to {"%"}
	set lst to (text items of t)
	if (count of lst) &gt; 0 then set t to (item 1 of lst)
	set tt to ""
	if (count of lst) &gt; 1 then set tt to "%" &amp; ((rest of lst) as string)
	set AppleScript's text item delimiters to {"\\\\"}
	set lst to (text items of t)
	set nnn to (count of lst)
	if nnn &gt; 1 then --contains a \\
		if (last item of lst) contains "}" then set nnn to 0 ---\\ is contained in cell
	end if
	if nnn &lt; 2 then --no \\ in line
		set (item i of lia) to t
		set (item i of lib) to tt
		set cont to true
	else
		set (item i of lia) to ((items 1 thru -2 of lst) as string)
		set (item i of lib) to "\\\\" &amp; (last item of lst) &amp; tt --version without spaces
		set cont to false
	end if
	set AppleScript's text item delimiters to {"&amp;"}
	set lst to (text items of (item i of lia))
	set m to (count of lst)
	if m = 0 then set m to 1
	set m to (m + offs - 1)
	if cont then
		set offs to m
		copy offs to (item i of strt)
	else
		set offs to 0
		set (item i of strt) to 0
	end if
	if m + 1 &gt; colwidth then set colwidth to m + 1
	copy lst to (item i of lic)
end repeat
set colmax to makelst(colwidth) --max number of characters in the columns
--set si to makelst(n) --the output lines
set offs to 0
set lastlen to 0 --length of last entry in prior row, if not ended by \\
repeat with i from 1 to n
	copy (item i of lic) to lst --row i, parsed columns
	if (count of lst) &gt; 0 then
		repeat with j from 1 to (count of lst)
			set m to (count of (item j of lst))
			if (j = (count of lst)) and not ((item i of lib) begins with "\\\\") then
				set m to 1
			else
				if j = 1 then
					if m &lt; lastlen then set m to lastlen
				end if
			end if
			if m &gt; (item (j + offs) of colmax) then set item (j + offs) of colmax to m
		end repeat
		set offs to (item i of strt)
		lastlen = 0
		if offs &gt; 0 then set lastlen to m
		--else --blank line after removing commented material and \\
		--if not ((item i of lib) begins with "\\\\") then
		--set offs to (item i of strt)
		--if offs = 0 then set lastlen to 0
	end if
end repeat
set s to ""
set offs to 0
repeat with i from 1 to n
	copy (item i of lic) to lst --row i, parsed columns
	set ti to makelst((count of lst))
	set AppleScript's text item delimiters to {"&amp;"} --version without spaces
	if (count of ti) &gt; 0 then
		repeat with j from 1 to (count of ti)
			set (item j of ti) to (item j of lst) &amp; makestr((item (j + offs) of colmax) - (count of (item j of lst)))
		end repeat
	end if
	set (item i of si) to (ti as string) &amp; (item i of lib)
	if (count of (item i of si)) &gt; 0 then
		if offs &gt; 0 then
			set ss to ""
			repeat with j from 1 to offs
				set ss to ss &amp; makestr((item j of colmax) + 1)
			end repeat
			--set ss to (text 1 thru -2 of ss) &amp; "&amp;"
			set (item i of si) to ss &amp; (item i of si)
		end if
	end if
	set offs to (item i of strt)
end repeat
set AppleScript's text item delimiters to {linefeed}
set s to (si as string)
set AppleScript's text item delimiters to {dblnull}
set ti to (text items of s)
set AppleScript's text item delimiters to {"\\&amp;"}
set s to (ti as string)
set AppleScript's text item delimiters to {nullone}
set ti to (text items of s)
set AppleScript's text item delimiters to {"\\%"}
set s to (ti as string)
tell application "TeXShop" to set content of selection of document 1 to s
set AppleScript's text item delimiters to tid

on removeWS(str)
	local str, oldTID, removeStrRef, removeStr, lst
	set oldTID to AppleScript's text item delimiters
	if str contains tab then
		set AppleScript's text item delimiters to {tab}
		set lst to (text items of str)
		set AppleScript's text item delimiters to {space}
		set str to (lst as string)
	end if
	try
		repeat with rmstr in {"        ", "  "}
			repeat
				set AppleScript's text item delimiters to rmstr
				set lst to (text items of str)
				if (count of lst) &lt; 2 then exit repeat
				set AppleScript's text item delimiters to space
				set str to (lst as string)
			end repeat
		end repeat
		set AppleScript's text item delimiters to oldTID
		if str = " " then
			set str to ""
		else
			if ((count of str) &gt; 1) and (str begins with space) then set str to (text 2 thru -1 of str)
			if ((count of str) &gt; 1) and (str ends with space) then set str to (text 1 thru -2 of str)
		end if
		return str
		
	on error
		set AppleScript's text item delimiters to oldTID
	end try
end removeWS

on makestr(nnn)
	if nnn &lt; 1 then
		return ""
	else
		return (text 1 thru nnn of longs)
	end if
end makestr

on makelst(nnn)
	local thest, ii, h, rem
	if nnn &lt; 1 then
		return {}
	else
		if nnn &lt; 101 then
			return (items 1 thru nnn of longl)
		else
			set h to (nnn div 100)
			set rem to (nnn mod 100)
			set thest to {}
			if rem &gt; 0 then set thest to (items 1 thru rem of longl)
			repeat with ii from 1 to h
				set thest to longl &amp; thest
			end repeat
			return thest
		end if
	end if
end makelst</string>
			<key>key</key>
			<string></string>
			<key>name</key>
			<string>Tabularize</string>
		</dict>
		<dict>
			<key>content</key>
			<string>--Applescript direct
--Michael Sharpe, 2015/02/05

--act on selected lines of a table, align vertically on &amp; and \\, adding spaces around them

property myrawlia : {}
property myrawlib : {}
property myrawlic : {}
property myrawsi : {}
property myrawstrt : {}

set myrawlia to {}
set myrawlib to {}
set myrawlic to {}
set myrawsi to {}
set myrawstrt to {}
set lia to a reference to myrawlia
set lib to a reference to myrawlib
set lic to a reference to myrawlic
set si to a reference to myrawsi
set strt to a reference to myrawstrt

set tid to AppleScript's text item delimiters
tell application "TeXShop" to set s to (content of selection of document 1)
if (count of s) = 0 then
	display dialog "No text selected!"
	return
end if
global longs, longl
set longs to "                                                                                                    " --100 space characters
set longl to {"", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", ""} --list of 100 empty strings
--used in makestr and makelst
set dblnull to (character id 0) &amp; (character id 0)
set nullone to (character id 0) &amp; (character id 1)

set AppleScript's text item delimiters to {"\\&amp;"}
set ss to (text items of s)
set AppleScript's text item delimiters to {dblnull}
set s to (ss as text) -- each \&amp; now replaced by a pair of nulls
set AppleScript's text item delimiters to {"\\\\%"}
set ss to (text items of s)
set AppleScript's text item delimiters to {"\\\\ %"}
set s to (ss as text) -- each \\% now replaced by a \\ %
set AppleScript's text item delimiters to {"\\%"}
set ss to (text items of s)
set AppleScript's text item delimiters to {nullone}
set s to (ss as text) -- each \% now replaced by a nullone
set li to (paragraphs of s) --lines, separated by cr or lf
set n to count of li
set lia to makelst(n)
copy lia to lib
copy lia to lic
copy lia to strt --starting offset for next row, usually 0
copy lia to si
set colwidth to 0 --max number of columns in selected rows
set offs to 0 --initial offset for first row
set cont to false --true indicates next line is continued from current
repeat with i from 1 to n
	set t to removeWS(item i of li)
	set AppleScript's text item delimiters to {"%"}
	set lst to (text items of t)
	if (count of lst) &gt; 0 then set t to (item 1 of lst)
	set tt to ""
	if (count of lst) &gt; 1 then set tt to "%" &amp; ((rest of lst) as string)
	set AppleScript's text item delimiters to {"\\\\"}
	set lst to (text items of t)
	set nnn to (count of lst)
	if nnn &gt; 1 then --contains a \\
		if (last item of lst) contains "}" then set nnn to 0 ---\\ is contained in cell
	end if
	if nnn &lt; 2 then --no \\ in line
		set (item i of lia) to t
		set (item i of lib) to tt
		set cont to true
	else
		set (item i of lia) to ((items 1 thru -2 of lst) as string)
		set (item i of lib) to " \\\\" &amp; (last item of lst) &amp; tt --version with spaces
		set cont to false
	end if
	set AppleScript's text item delimiters to {"&amp;"}
	set lst to (text items of (item i of lia))
	set m to (count of lst)
	if m = 0 then set m to 1
	set m to (m + offs - 1)
	if cont then
		set offs to m
		copy offs to (item i of strt)
	else
		set offs to 0
		set (item i of strt) to 0
	end if
	if m + 1 &gt; colwidth then set colwidth to m + 1
	copy lst to (item i of lic)
end repeat

set colmax to makelst(colwidth) --max number of characters in the columns
--set si to makelst(n) --the output lines
set offs to 0
set lastlen to 0 --length of last entry in prior row, if not ended by \\
repeat with i from 1 to n
	copy (item i of lic) to lst --row i, parsed columns
	if (count of lst) &gt; 0 then
		repeat with j from 1 to (count of lst)
			set m to (count of (item j of lst))
			if (j = (count of lst))  and not ((item i of lib) begins with " \\\\") then
				set m to 1
			else
				if j = 1 then
					if m &lt; lastlen then set m to lastlen
				end if
			end if
			if m &gt; (item (j + offs) of colmax) then set item (j + offs) of colmax to m
		end repeat
		set offs to (item i of strt)
		lastlen = 0
		if offs &gt; 0 then set lastlen to m
	end if
end repeat
set s to ""
set offs to 0
repeat with i from 1 to n
	copy (item i of lic) to lst --row i, parsed columns
	set ti to makelst((count of lst))
	set AppleScript's text item delimiters to {" &amp; "} --version with spaces
	if (count of ti) &gt; 0 then
		repeat with j from 1 to (count of ti)
			set (item j of ti) to (item j of lst) &amp; makestr((item (j + offs) of colmax) - (count of (item j of lst)))
		end repeat
	end if
	set (item i of si) to (ti as string) &amp; (item i of lib)
	if (count of (item i of si)) &gt; 0 then
		if offs &gt; 0 then
			set ss to ""
			repeat with j from 1 to offs
				set ss to ss &amp; makestr((item j of colmax) + 3)
			end repeat
			--set ss to (text 1 thru -2 of ss) &amp; "&amp;"
			set (item i of si) to ss &amp; (item i of si)
		end if
	end if
	set offs to (item i of strt)
end repeat
set AppleScript's text item delimiters to {linefeed}
set s to (si as string)
set AppleScript's text item delimiters to {dblnull}
set ti to (text items of s)
set AppleScript's text item delimiters to {"\\&amp;"}
set s to (ti as string)
set AppleScript's text item delimiters to {nullone}
set ti to (text items of s)
set AppleScript's text item delimiters to {"\\%"}
set s to (ti as string)
tell application "TeXShop" to set content of selection of document 1 to s
set AppleScript's text item delimiters to tid

on removeWS(str)
	local str, oldTID, removeStrRef, removeStr, lst
	set oldTID to AppleScript's text item delimiters
	if str contains tab then
		set AppleScript's text item delimiters to {tab}
		set lst to (text items of str)
		set AppleScript's text item delimiters to {space}
		set str to (lst as string)
	end if
	--include this block only if spaces added
	set AppleScript's text item delimiters to {" \\\\"}
	set lst to (text items of str)
	set AppleScript's text item delimiters to {"\\\\"}
	set str to (lst as string)
	set AppleScript's text item delimiters to {" &amp;"}
	set lst to (text items of str)
	set AppleScript's text item delimiters to {"&amp;"}
	set str to (lst as string)
	set AppleScript's text item delimiters to {"&amp; "}
	set lst to (text items of str)
	set AppleScript's text item delimiters to {"&amp;"}
	set str to (lst as string)
	try
		repeat with rmstr in {"        ", "  "}
			repeat
				set AppleScript's text item delimiters to rmstr
				set lst to (text items of str)
				if (count of lst) &lt; 2 then exit repeat
				set AppleScript's text item delimiters to space
				set str to (lst as string)
			end repeat
		end repeat
		set AppleScript's text item delimiters to oldTID
		if str = " " then
			set str to ""
		else
			if ((count of str) &gt; 1) and (str begins with space) then set str to (text 2 thru -1 of str)
			if ((count of str) &gt; 1) and (str ends with space) then set str to (text 1 thru -2 of str)
		end if
		return str
		
	on error
		set AppleScript's text item delimiters to oldTID
	end try
end removeWS

on makestr(nnn)
	if nnn &lt; 1 then
		return ""
	else
		return (text 1 thru nnn of longs)
	end if
end makestr

on makelst(nnn)
	local thest, ii, h, rem
	if nnn &lt; 1 then
		return {}
	else
		if nnn &lt; 101 then
			return (items 1 thru nnn of longl)
		else
			set h to (nnn div 100)
			set rem to (nnn mod 100)
			set thest to {}
			if rem &gt; 0 then set thest to (items 1 thru rem of longl)
			repeat with ii from 1 to h
				set thest to longl &amp; thest
			end repeat
			return thest
		end if
	end if
end makelst</string>
			<key>key</key>
			<string></string>
			<key>name</key>
			<string>Tabularize +space</string>
		</dict>
		<dict>
			<key>content</key>
			<string></string>
			<key>key</key>
			<string></string>
			<key>name</key>
			<string>Applescript</string>
			<key>submenu</key>
			<array>
				<dict>
					<key>content</key>
					<string>--AppleScript direct

tell application "Adobe Reader"
  activate
  open POSIX file #PDFPATH#
end tell
</string>
					<key>key</key>
					<string></string>
					<key>name</key>
					<string>View pdf with Acrobat</string>
				</dict>
				<dict>
					<key>content</key>
					<string>--AppleScript direct

tell application "Adobe Acrobat Reader DC"
  activate
  open POSIX file #PDFPATH#
end tell
</string>
					<key>key</key>
					<string></string>
					<key>name</key>
					<string>View pdf with Adobe Acrobat Reader DC</string>
				</dict>
				<dict>
					<key>content</key>
					<string>--AppleScript direct

tell application "Preview"
  activate
  open POSIX file #PDFPATH#
end tell
</string>
					<key>key</key>
					<string></string>
					<key>name</key>
					<string>View pdf with Preview</string>
				</dict>
				<dict>
					<key>content</key>
					<string>--AppleScript direct
-- #FILEPATH# in the text will be replaced by the path of the document
-- #DVIPATH#, #PSPATH#, #PDFPATH# are also replaced by the paths of .dvi, .ps, .dvi files.  
-- to use the path in Finder, use (alias POSIX file filepath)
-- example: show tex and pdf files in Finder

try
tell application "Finder"
  activate
  reveal {alias POSIX file #FILEPATH#, alias POSIX file #PDFPATH#}
end tell
on error
end try</string>
					<key>key</key>
					<string></string>
					<key>name</key>
					<string>Show files</string>
				</dict>
				<dict>
					<key>content</key>
					<string>--AppleScript direct
-- If the content field starts with "--AppleScript" then it will be interpreted as an AppleScript and will be executed.  
-- example: show TeXShop home page in a web browser

open location "http://darkwing.uoregon.edu/~koch/texshop/texshop.html"</string>
					<key>key</key>
					<string></string>
					<key>name</key>
					<string>TeXShop home page</string>
				</dict>
				<dict>
					<key>content</key>
					<string>--AppleScript direct
-- If the content field starts with "--AppleScript" then it will be interpreted as an AppleScript and will be executed.  

open location "http://tug.org/mactex/"</string>
					<key>key</key>
					<string></string>
					<key>name</key>
					<string>MacTeX home page</string>
				</dict>
				<dict>
					<key>content</key>
					<string>--Applescript direct

-- OPEN TeXLive FILE
-- Type the name of a file in the TeXLive tree, for example "geometry.sty". This macro will find it and open it.

set q1 to display dialog "Open TeX File" &amp; return &amp; return &amp; "Enter the name, including extension, of the TeX file you want to open." default answer "" buttons {"Cancel", "Open"} default button "Open"
set filename_to_open to the text returned of q1

try
	set file_path to do shell script "/Library/TeX/texbin/kpsewhich " &amp; filename_to_open
	set theFile to alias (POSIX file file_path)
	tell application "TeXShop"
		activate
		open theFile
	end tell
on error
	display dialog ("There don't seem to be any files in the teTeX tree with the filename: " &amp; filename_to_open) buttons {"OK"} default button "OK"
end try
</string>
					<key>key</key>
					<string></string>
					<key>name</key>
					<string>View TeX Live file</string>
				</dict>
				<dict>
					<key>content</key>
					<string>--Applescript direct
-- If front file is named "Test.tex", write a copy as "Test_Mac.tex", changing all line feeds to
-- Macintosh Classic line feeds

set fileName to  #NAMEPATH#
set n to (number of characters of contents of fileName)
set fileNamequoted to quoted form of fileName
set baseName to do shell script "basename " &amp; fileNamequoted
set m to (number of characters of contents of baseName)
set dirName to quoted form of (characters 1 thru (n - m - 1) of fileName as string)
set texName to baseName &amp; ".tex"
set backupTexName to baseName &amp; "_Mac.tex"

set shellScript to  "cd " &amp; dirName &amp; ";"
set shellScript to shellScript &amp; "cp  " &amp; texName &amp;" " &amp; backupTexName &amp;";"
set shellScript to shellScript &amp; "/bin/tcsh -c '~/Library/TeXShop/bin/flip -m  " &amp; backupTexName &amp; "'"
do shell script shellScript


</string>
					<key>key</key>
					<string></string>
					<key>name</key>
					<string>Convert to MAC</string>
				</dict>
				<dict>
					<key>content</key>
					<string>--Applescript direct
-- If front file is named "Test.tex", write a copy as "Test_Unix.tex", changing all line feeds to
-- Unix line feeds

set fileName to  #NAMEPATH#
set n to (number of characters of contents of fileName)
set fileNamequoted to quoted form of fileName
set baseName to do shell script "basename " &amp; fileNamequoted
set m to (number of characters of contents of baseName)
set dirName to quoted form of (characters 1 thru (n - m - 1) of fileName as string)
set texName to baseName &amp; ".tex"
set backupTexName to baseName &amp; "_Unix.tex"

set shellScript to  "cd " &amp; dirName &amp; ";"
set shellScript to shellScript &amp; "cp  " &amp; texName &amp;" " &amp; backupTexName &amp;";"
set shellScript to shellScript &amp; "/bin/tcsh -c '~/Library/TeXShop/bin/flip -u  " &amp; backupTexName &amp; "'"
do shell script shellScript
</string>
					<key>key</key>
					<string></string>
					<key>name</key>
					<string>Convert to Unix</string>
				</dict>
				<dict>
					<key>content</key>
					<string>--Applescript direct
-- If front file is named "Test.tex", write a copy as "Test_Windows.tex", changing all line feeds to
-- Windows line feeds

set fileName to  #NAMEPATH#
set n to (number of characters of contents of fileName)
set fileNamequoted to quoted form of fileName
set baseName to do shell script "basename " &amp; fileNamequoted
set m to (number of characters of contents of baseName)
set dirName to quoted form of (characters 1 thru (n - m - 1) of fileName as string)
set texName to baseName &amp; ".tex"
set backupTexName to baseName &amp; "_Windows.tex"

set shellScript to  "cd " &amp; dirName &amp; ";"
set shellScript to shellScript &amp; "cp  " &amp; texName &amp;" " &amp; backupTexName &amp;";"
set shellScript to shellScript &amp; "/bin/tcsh -c '~/Library/TeXShop/bin/flip -d  " &amp; backupTexName &amp; "'"
do shell script shellScript
</string>
					<key>key</key>
					<string></string>
					<key>name</key>
					<string>Convert to Windows</string>
				</dict>
				<dict>
					<key>content</key>
					<string>--Applescript

set fileName to #FILEPATH#
if fileName is equal to  ""
activate
display dialog "Please save the file first"  buttons {"OK"} default button "OK"
return
end if

set frontName to #DOCUMENTNAME#

tell document frontName of application "TeXShop"

	latexinteractive

	repeat
		delay 2
		if taskdone
			exit repeat
		end if
	end repeat

	bibtex

	repeat
		delay 2
		if taskdone
			exit repeat
		end if
	end repeat

	latex

	repeat
		delay 2
		if taskdone
			exit repeat
		end if
	end repeat

	latex

	repeat
		delay 2
		if taskdone
			exit repeat
		end if
	end repeat

end tell

</string>
					<key>key</key>
					<string></string>
					<key>name</key>
					<string>Bibliography</string>
				</dict>
				<dict>
					<key>content</key>
					<string>--Applescript direct

--TeXShop restart required for changes to take effect

do shell script "defaults write TeXShop background_R 0.3"
do shell script "defaults write TeXShop background_G 0.3"
do shell script "defaults write TeXShop background_B 0.3"
do shell script "defaults write TeXShop foreground_R 1.0"
do shell script "defaults write TeXShop foreground_G 1.0"
do shell script "defaults write TeXShop foreground_B 1.0"</string>
					<key>key</key>
					<string></string>
					<key>name</key>
					<string>Colored source</string>
				</dict>
				<dict>
					<key>content</key>
					<string>--Applescript direct

--TeXShop restart required for changes to take effect

do shell script "defaults write TeXShop background_R 1.00"
do shell script "defaults write TeXShop background_G 1.00"
do shell script "defaults write TeXShop background_B 1.00"
do shell script "defaults write TeXShop foreground_R .0"
do shell script "defaults write TeXShop foreground_G .0"
do shell script "defaults write TeXShop foreground_B .0"</string>
					<key>key</key>
					<string></string>
					<key>name</key>
					<string>Default Colored source</string>
				</dict>
			</array>
		</dict>
		<dict>
			<key>content</key>
			<string></string>
			<key>key</key>
			<string></string>
			<key>name</key>
			<string>Column macros</string>
			<key>submenu</key>
			<array>
				<dict>
					<key>content</key>
					<string>--Applescript direct

-- NEW TABULAR
-- This script inserts a new tabular environment with a user-specified number of rows and columns. You can choose to have a plain table or a booktabs table - for the latter case you need to be using either the Memoir class or the booktabs package. Finally you may choose whether to have the table floating with a caption or simply centred.

-- CUSTOMISE TO YOUR LIKING:

property indent : "  " -- edit this if you want other than 2 spaces for your indent
property cell_text : "• " -- edit this if you want a different text blob

property default_tabular_type: "Booktabs" -- or "Plain"
property default_table_type: "Floating" -- or "Centred"

-- THE SCRIPT:

property texapp : "TeXShop"
tell application texapp
	
	set q1 to display dialog "New tabular" &amp; return &amp; return &amp; "Enter the number of columns you'd like and then select the type of tabular you want." default answer "3" buttons {"Cancel", "Plain", "Booktabs"} default button default_tabular_type
	set NCOLS to the text returned of q1
	set tabtype to the button returned of q1
	
	set q2 to display dialog "Enter the number of rows you'd like (not including a header row) and select whether you'd like a floating or simply centred table." default answer "3" buttons {"Cancel", "Centred", "Floating"} default button default_table_type
	set NROWS to the text returned of q2
	set floattype to the button returned of q2
	
	if the tabtype = "Booktabs" then
		set the toprule to "\\toprule"
		set the midrule to "\\midrule"
		set the bottomrule to "\\bottomrule"
	else
		set the toprule to "\\hline"
		set the midrule to "\\hline"
		set the bottomrule to "\\hline"
	end if
	
	if the floattype = "Floating" then
		set the beforetext to ¬
			"\\begin{table}[htbp]" &amp; return &amp; ¬
			indent &amp; "\\centering" &amp; return &amp; ¬
			indent &amp; "\\begin{tabular}" -- note no carriage return to allow space for the column preamble
		set the aftertext to ¬
			indent &amp; indent &amp; bottomrule &amp; return &amp; ¬
			indent &amp; "\\end{tabular}" &amp; return &amp; ¬
			indent &amp; "\\caption{TableCaption}" &amp; return &amp; ¬
			indent &amp; "\\label{tab:label}" &amp; return &amp; ¬
			"\\end{table}"
	else
		set the beforetext to ¬
			"\\begin{center}" &amp; return &amp; ¬
			indent &amp; "\\begin{tabular}"
		set the aftertext to ¬
			indent &amp; indent &amp; bottomrule &amp; return &amp; ¬
			indent &amp; "\\end{tabular}" &amp; return &amp; ¬
			"\\end{center}"
	end if
	
	set the column_preamble to "{@{} c"
	set the one_row_text to indent &amp; indent &amp; cell_text
	
	if NCOLS &gt; 1 then
		repeat with c from 2 to NCOLS
			set the column_preamble to column_preamble &amp; "c"
			set the one_row_text to one_row_text &amp; "&amp; " &amp; cell_text
		end repeat
	end if
	
	set the column_preamble to column_preamble &amp; " @{}}" &amp; return
	set the one_row_text to one_row_text &amp; "\\\\ "
	
	-- start off with a header row between two rules:
	set the midtext to ¬
		indent &amp; indent &amp; toprule &amp; return &amp; ¬
		one_row_text &amp; return &amp; ¬
		indent &amp; indent &amp; midrule &amp; return
	
	repeat with r from 1 to NROWS
		set the midtext to midtext &amp; one_row_text &amp; return
	end repeat
	
	set alltext to beforetext &amp; column_preamble &amp; midtext &amp; aftertext
	
	if texapp = "TeXShop" then
		tell application "TeXShop" to set the content of the selection of the front document to alltext
	else if texapp = "iTeXMac" then
		--tell application "iTeXMac" to insert alltext in the text of the front document
	end if
	
end tell

-- 2004 Will Robertson
-- (You may do what you like with this script)</string>
					<key>key</key>
					<string>T+ControlKey</string>
					<key>name</key>
					<string>New tabular</string>
				</dict>
				<dict>
					<key>content</key>
					<string>--Applescript direct

-- NEW TABULAR
-- This script inserts a new array environment with a user-specified number of rows and columns. You may choose to indent the array, since you'll be inserting it into a maths environment.

-- CUSTOMISE TO YOUR LIKING:
property indent : "  " -- edit this if you want other than 2 spaces for your indent
property cell_text : "• " -- edit this if you want a different text blob

property default_array_location: "Indent" -- or "Flush left"

-- THE SCRIPT:

property texapp : "TeXShop"
tell application texapp
	
	set q1 to display dialog "New maths array." &amp; return &amp; return &amp; "Enter the number of rows you'd like." default answer "3"
	set NROWS to the text returned of q1
	
	set q2 to display dialog "How many columns would you like? Would you like me to indent the array?" default answer "3" buttons {"Cancel", "Flush left", "Indent"} default button default_array_location
	set NCOLS to the text returned of q2
	set indentyesno to the button returned of q2
	
	if the indentyesno = "Indent" then
		set the preindent to indent
	else
		set the preindent to ""
	end if
	
	set the column_preamble to "{c"
	set the one_row_text to preindent &amp; indent &amp; cell_text
	
	if NCOLS &gt; 1 then
		repeat with c from 2 to NCOLS
			set the column_preamble to column_preamble &amp; "c"
			set the one_row_text to one_row_text &amp; "&amp; " &amp; cell_text
		end repeat
	end if
	
	set the column_preamble to column_preamble &amp; "}" &amp; return
	set the one_row_text to one_row_text &amp; "\\\\ " &amp; return
	
	set midtext to ""
	repeat with r from 1 to NROWS
		set the midtext to midtext &amp; one_row_text
	end repeat
	
	set the beforetext to preindent &amp; "\\begin{array}"
	set the aftertext to preindent &amp; "\\end{array}"
	
	set alltext to beforetext &amp; column_preamble &amp; midtext &amp; aftertext
	
	if texapp = "TeXShop" then
		tell application "TeXShop" to set the content of the selection of the front document to alltext
	else if texapp = "iTeXMac" then
		--tell application "iTeXMac" to insert alltext in the text of the front document
	end if
	
end tell

-- 2004 Will Robertson
-- (You may do what you like with this script)</string>
					<key>key</key>
					<string>A+ControlKey</string>
					<key>name</key>
					<string>New array</string>
				</dict>
				<dict>
					<key>content</key>
					<string>--Applescript direct

-- ADD COLUMN
--Select the tabular/array rows you wish to edit and run the script. The script will insert a new column at the specified location in each row. You'll have to adjust multicolumn rows and the column preamble (eg, the {ccc} part) manually.

-- CUSTOMISE TO YOUR LIKING:
property indent : "  "
property default_button : "After" -- or "Before"
property cell_blob : "•"


--THE SCRIPT:

property texapp : "TeXShop"
tell application texapp
	set q to display dialog "Add column." &amp; return &amp; return &amp; "Please enter the column number before or after which you would like to add a new column." default answer "1" buttons {"Before", "After"} default button default_button
	set add_where to the button returned of q
	set col_num to the text returned of q
	
	if texapp = "TeXShop" then
		tell application "TeXShop" to set tabular to the content of the selection of the front document
	else if texapp = "iTeXMac" then
		--tell application "iTeXMac" to set tabular to (the selection of the text of the front document)
	end if
	
	set new_tabular to ""
	repeat with ii from 1 to the count of the paragraphs of tabular
		
		set this_line to paragraph ii of tabular

		if this_line contains "\\\\" and this_line does not contain "\\multicolumn" then
			
			--Transform "    a &amp; b &amp; c \\" to "a &amp; b &amp; c":
			set trim_line to do shell script ¬
				"echo " &amp; the quoted form of this_line &amp; ¬
				" | sed 's/^[ ^t]*//' | sed 's/\\\\\\\\//'"
			-- "\\\\\\\\" is a TeX newline escaped in both Applescript and the shell
			
			
			set new_col to "&amp; " &amp; cell_blob &amp; " &amp;"
			if add_where = "After" then
				set line_start to do shell script "echo " &amp; the quoted form of trim_line &amp; " | cut -f -" &amp; col_num &amp; " -d '&amp;'"
				set line_end to do shell script "echo " &amp; the quoted form of trim_line &amp; " | cut -f " &amp; col_num + 1 &amp; "- -d '&amp;'"
				if line_end = "" then
					set new_col to "&amp; " &amp; cell_blob &amp; " "
				end if
			else if add_where = "Before" then
				if col_num = "1" then
					set line_start to ""
					set new_col to cell_blob &amp; " &amp; "
					set line_end to trim_line
				else
					set line_start to do shell script "echo " &amp; the quoted form of trim_line &amp; " | cut -f -" &amp; col_num - 1 &amp; " -d '&amp;'"
					set line_end to do shell script "echo " &amp; the quoted form of trim_line &amp; " | cut -f " &amp; col_num &amp; "- -d '&amp;'"
					if line_end = "" then
						set new_col to "&amp; " &amp; cell_blob &amp; " "
					end if
				end if
			end if
			
			set new_line to indent &amp; indent &amp; line_start &amp; new_col &amp; line_end &amp; "\\\\"
			if new_tabular = "" then
				set new_tabular to new_line
			else
				set new_tabular to new_tabular &amp; return &amp; new_line
			end if
		else
			if new_tabular = "" then
				set new_tabular to this_line
			else
				set new_tabular to new_tabular &amp; return &amp; this_line
			end if
		end if
		
	end repeat
	
	if tabular contains "\\multicolumn" then
		display dialog "I cannot parse lines with “\\multicolumn” in them. You'll have to do them by hand. Sorry." buttons {"Cancel", "Proceed"} default button "Proceed" with icon caution
	end if
	
	if texapp = "TeXShop" then
		tell application "TeXShop" to set the selection of the front document to new_tabular
	else if texapp = "iTeXMac" then
		--tell application "iTeXMac" to insert new_tabular in the text of the front document
	end if
	
	display dialog "Don't forget to add a column to the column header!" buttons {"•"} giving up after 2
	
end tell

-- 2004 Will Robertson
-- (You may do what you like with this script)</string>
					<key>key</key>
					<string></string>
					<key>name</key>
					<string>Add column</string>
				</dict>
				<dict>
					<key>content</key>
					<string>--Applescript direct

-- DELETE COLUMN
--Select the tabular/array rows you wish to edit and run the script. The script will delete the specified column from each row (after a confirmation). You'll have to adjust multicolumn rows and the column preamble (eg, the {ccc} part) manually.

-- CUSTOMISE TO YOUR LIKING:
property indent : "  "
property warn_before_delete: true

-- THE SCRIPT:

property texapp : "TeXShop"
tell application texapp
	
	set q to display dialog "Delete column." &amp; return &amp; return &amp; "Please enter the number of the column you would like to delete." default answer "1" buttons {"Cancel", "Delete"} default button "Delete"
	set col_num to the text returned of q

	if texapp = "TeXShop" then
		tell application "TeXShop" to set tabular to the content of the selection of the front document
	else if texapp = "iTeXMac" then
		--tell application "iTeXMac" to set tabular to (the selection of the text of the front document)
	end if
	
	if tabular = "" then
		display dialog "Nothing selected. Please select the tabular/array rows you wish to edit." buttons "Cancel" default button 1
	end if
	
	set sample_value to ""
	set new_tabular to ""
	repeat with ii from 1 to the count of the paragraphs of tabular
		
		set this_line to paragraph ii of tabular
		
		if this_line contains "\\\\" and this_line does not contain "\\multicolumn" then
			-- note "\\\\" means \\ because the backslashes are escaped
			
			--Transform "    a &amp; b &amp; c \\" to "a &amp; b &amp; c":
			set trim_line to do shell script ¬
				"echo " &amp; the quoted form of this_line &amp; ¬
				" | sed 's/^[ ^t]*//' | sed 's/\\\\\\\\//'"
			-- "\\\\\\\\" is a TeX newline escaped in both Applescript and the shell
			
			set new_col to "&amp;"
			if sample_value = "" then
				set sample_value to do shell script "echo " &amp; the quoted form of trim_line &amp; " | cut -f " &amp; col_num &amp; "-" &amp; col_num &amp; " -d '&amp;'"
			end if
			if col_num = "1" then
				set line_start to ""
				set line_end to do shell script "echo " &amp; the quoted form of trim_line &amp; " | cut -f " &amp; col_num + 1 &amp; "- -d '&amp;'"
				set new_col to ""
			else
				set line_start to do shell script "echo " &amp; the quoted form of trim_line &amp; " | cut -f -" &amp; col_num - 1 &amp; " -d '&amp;'"
				set line_end to do shell script "echo " &amp; the quoted form of trim_line &amp; " | cut -f " &amp; col_num + 1 &amp; "- -d '&amp;'"
				if line_end = "" then
					set new_col to ""
				end if
			end if
			
			
			set new_line to indent &amp; indent &amp; line_start &amp; new_col &amp; line_end &amp; "\\\\"
			if new_tabular = "" then
				set new_tabular to new_line
			else
				set new_tabular to new_tabular &amp; return &amp; new_line
			end if
		else
			if new_tabular = "" then
				set new_tabular to this_line
			else
				set new_tabular to new_tabular &amp; return &amp; this_line
			end if
		end if
		
	end repeat
	
	if warn_before_delete then
		display dialog "Are you sure you want to delete the column that begins with “" &amp; sample_value &amp; "”?" buttons {"Cancel", "Delete"} default button "Delete"
	end if
	
	if tabular contains "\\multicolumn" then
		display dialog "I cannot parse lines with “\\multicolumn” in them. You'll have to do them by hand. Sorry." buttons {"Cancel", "Proceed"} default button "Proceed" with icon caution
	end if
	
	if texapp = "TeXShop" then
		tell application "TeXShop" to set the selection of the front document to new_tabular
	else if texapp = "iTeXMac" then
		--tell application "iTeXMac" to insert new_tabular in the text of the front document
	end if
	
	display dialog "Don't forget to remove a column from the column header!" buttons {"•"} giving up after 2
	
end tell

-- 2004 Will Robertson
-- (You may do what you like with this script)</string>
					<key>key</key>
					<string></string>
					<key>name</key>
					<string>Delete column</string>
				</dict>
			</array>
		</dict>
		<dict>
			<key>content</key>
			<string>--Applescript direct
--This script copyright 2009,2010 by Alan Munn &lt;amunn@msu.edu&gt;
--Version 1.1 2010/01/31
--Copy cells from Excel or other spreadsheet program and
-- use this script to paste the cells into your LaTeX source
-- in a variety of different table styles.
set mainList to {"cells","booktabs", "simple","longtable" }
choose from list mainList with prompt "Choose a table format"
if the result is not false then
	set tablestyle to result as text
	do shell script  "~/Library/TeXShop/bin/csv2latex" &amp; " " &amp;  tablestyle
	tell application "System Events" to keystroke "v" using {command down}
end if
--End of Applescript
</string>
			<key>key</key>
			<string></string>
			<key>name</key>
			<string>Paste Spreadsheet Cells</string>
		</dict>
		<dict>
			<key>content</key>
			<string></string>
			<key>key</key>
			<string></string>
			<key>name</key>
			<string>Claus Gerhardt Macros</string>
			<key>submenu</key>
			<array>
				<dict>
					<key>content</key>
					<string>--Applescript
-- Apply only to an already saved file
-- Claus Gerhardt, Nov. 2003

set scriptPath to (do shell script "dirname " &amp; "~/Library/TeXShop/Scripts/ex")
set scriptPath to scriptPath &amp; "/setname.scpt"
set scriptName to POSIX file scriptPath as alias
set scriptLiB to (load script scriptName)
tell scriptLib
set frontName to setname(#NAMEPATH#,#TEXPATH#)
end tell

set fileName to  #NAMEPATH#
set n to (number of characters of contents of fileName)
set fileNamequoted to quoted form of fileName
set baseName to do shell script "basename " &amp; fileNamequoted
set m to (number of characters of contents of baseName)
set dirName to quoted form of (characters 1 thru (n - m - 1) of fileName as string)
set texName to baseName &amp; ".tex"

set shellScript to "cd " &amp; dirName &amp; ";"
set shellScript to shellScript &amp; "~/Library/TeXShop/bin/bibtexc  " &amp; baseName
do shell script shellScript

set shellScript to "cd " &amp; dirName &amp; ";"
set shellScript to shellScript &amp; "~/Library/TeXShop/bin/pdflatexc  " &amp; texName
do shell script shellScript

set shellScript to "cd " &amp; dirName &amp; ";"
set shellScript to shellScript &amp; "~/Library/TeXShop/bin/pdflatexc  " &amp; texName
do shell script shellScript


set fileLog to fileName &amp; ".blg"
set theFile to alias (POSIX file fileLog)
set logName to baseName &amp;".blg"

tell document frontName of application "TeXShop"
refreshpdf
end tell

tell application "TeXShop"
open theFile
end tell

tell document logName of application "TeXShop"
refreshtext
end tell




</string>
					<key>key</key>
					<string></string>
					<key>name</key>
					<string>bibtexc</string>
				</dict>
				<dict>
					<key>content</key>
					<string>--Applescript
-- Apply only to an already saved file
-- Claus Gerhardt, Nov. 2003

set scriptPath to (do shell script "dirname " &amp; "~/Library/TeXShop/Scripts/ex")
set scriptPath to scriptPath &amp; "/setname.scpt"
set scriptName to POSIX file scriptPath as alias
set scriptLiB to (load script scriptName)
tell scriptLib
set frontName to setname(#NAMEPATH#,#TEXPATH#)
end tell

set fileName to  #NAMEPATH#
set n to (number of characters of contents of fileName)
set fileNamequoted to quoted form of fileName
set baseName to do shell script "basename " &amp; fileNamequoted
set m to (number of characters of contents of baseName)
set dirName to quoted form of (characters 1 thru (n - m - 1) of fileName as string)
set texName to baseName &amp; ".tex"

set shellScript to "cd " &amp; dirName &amp; ";"
set shellScript to shellScript &amp; "~/Library/TeXShop/bin/pdflatexc  " &amp; texName
do shell script shellScript


set shellScript to "cd " &amp; dirName &amp; ";"
set shellScript to shellScript &amp; "~/Library/TeXShop/bin/bibtexc  " &amp; baseName
do shell script shellScript

set shellScript to "cd " &amp; dirName &amp; ";"
set shellScript to shellScript &amp; "~/Library/TeXShop/bin/pdflatexc  " &amp; texName
do shell script shellScript

set shellScript to "cd " &amp; dirName &amp; ";"
set shellScript to shellScript &amp; "~/Library/TeXShop/bin/pdflatexc  " &amp; texName
do shell script shellScript


set fileLog to fileName &amp; ".blg"
set theFile to alias (POSIX file fileLog)
set logName to baseName &amp;".blg"

tell document frontName of application "TeXShop"
refreshpdf
end tell

tell application "TeXShop"
open theFile
end tell

tell document logName of application "TeXShop"
refreshtext
end tell




</string>
					<key>key</key>
					<string></string>
					<key>name</key>
					<string>bibtexcpl</string>
				</dict>
				<dict>
					<key>content</key>
					<string></string>
					<key>key</key>
					<string></string>
					<key>name</key>
					<string>Separator</string>
				</dict>
				<dict>
					<key>content</key>
					<string>--Applescript
-- Apply only to an already saved file
-- Claus Gerhardt, Nov. 2003

set scriptPath to (do shell script "dirname " &amp; "~/Library/TeXShop/Scripts/ex")
set scriptPath to scriptPath &amp; "/setname.scpt"
set scriptName to POSIX file scriptPath as alias
set scriptLiB to (load script scriptName)
tell scriptLib
set frontName to setname(#NAMEPATH#,#TEXPATH#)
end tell

set fileName to  #NAMEPATH#
set n to (number of characters of contents of fileName)
set fileNamequoted to quoted form of fileName
set baseName to do shell script "basename " &amp; fileNamequoted
set m to (number of characters of contents of baseName)
set dirName to quoted form of (characters 1 thru (n - m - 1) of fileName as string)
set texName to baseName &amp; ".tex"

set shellScript to "cd " &amp; dirName &amp; ";"
set shellScript to shellScript &amp; "~/Library/TeXShop/bin/mpostc  " &amp; baseName
do shell script shellScript

set fileLog to fileName &amp; ".log"
set theFile to alias (POSIX file fileLog)
set logName to baseName &amp;".log"

tell application "TeXShop"
open theFile
end tell

tell document logName of application "TeXShop"
refreshtext
end tell


set shellScript to "cd " &amp; dirName &amp; ";"
set shellScript to shellScript &amp; "~/Library/TeXShop/bin/pdflatexc  " &amp; texName
do shell script shellScript


tell document frontName of application "TeXShop"
refreshpdf
end tell

 </string>
					<key>key</key>
					<string></string>
					<key>name</key>
					<string>mpostc</string>
				</dict>
				<dict>
					<key>content</key>
					<string>--Applescript
-- Apply only to an already saved file
-- Claus Gerhardt, Nov. 2003

set scriptPath to (do shell script "dirname " &amp; "~/Library/TeXShop/Scripts/ex")
set scriptPath to scriptPath &amp; "/setname.scpt"
set scriptName to POSIX file scriptPath as alias
set scriptLiB to (load script scriptName)
tell scriptLib
set frontName to setname(#NAMEPATH#,#TEXPATH#)
end tell

set fileName to  #NAMEPATH#
set n to (number of characters of contents of fileName)
set fileNamequoted to quoted form of fileName
set baseName to do shell script "basename " &amp; fileNamequoted
set m to (number of characters of contents of baseName)
set dirName to quoted form of (characters 1 thru (n - m - 1) of fileName as string)
set texName to baseName &amp; ".tex"

set shellScript to "cd " &amp; dirName &amp; ";"
set shellScript to shellScript &amp; "~/Library/TeXShop/bin/pdflatexc  " &amp; texName
do shell script shellScript

set shellScript to "cd " &amp; dirName &amp; ";"
set shellScript to shellScript &amp; "~/Library/TeXShop/bin/mpostc  " &amp; baseName
do shell script shellScript

set fileLog to fileName &amp; ".log"
set theFile to alias (POSIX file fileLog)
set logName to baseName &amp;".log"

tell application "TeXShop"
open theFile
end tell

tell document logName of application "TeXShop"
refreshtext
end tell


set shellScript to "cd " &amp; dirName &amp; ";"
set shellScript to shellScript &amp; "~/Library/TeXShop/bin/pdflatexc  " &amp; texName
do shell script shellScript


tell document frontName of application "TeXShop"
refreshpdf
end tell

 </string>
					<key>key</key>
					<string></string>
					<key>name</key>
					<string>mpostcpl</string>
				</dict>
				<dict>
					<key>content</key>
					<string></string>
					<key>key</key>
					<string></string>
					<key>name</key>
					<string>Separator</string>
				</dict>
				<dict>
					<key>content</key>
					<string>--Applescript
-- Apply only to an already saved file
-- Claus Gerhardt, Nov. 2003

set scriptPath to (do shell script "dirname " &amp; "~/Library/TeXShop/Scripts/ex")
set scriptPath to scriptPath &amp; "/setname.scpt"
set scriptName to POSIX file scriptPath as alias
set scriptLiB to (load script scriptName)
tell scriptLib
set frontName to setname(#NAMEPATH#,#TEXPATH#)
end tell

set fileName to  #NAMEPATH#
set n to (number of characters of contents of fileName)
set fileNamequoted to quoted form of fileName
set baseName to do shell script "basename " &amp; fileNamequoted
set m to (number of characters of contents of baseName)
set dirName to quoted form of (characters 1 thru (n - m - 1) of fileName as string)
set texName to baseName &amp; ".tex"

set shellScript to "cd " &amp; dirName &amp; ";"
set shellScript to shellScript &amp; "~/Library/TeXShop/bin/htlatexc  " &amp; baseName
do shell script shellScript

set theHTML to #HTMLPATH#
set htmlFile to alias POSIX file theHTML

tell application "Safari"
  activate
  open htmlFile
end tell
</string>
					<key>key</key>
					<string></string>
					<key>name</key>
					<string>htlatexc</string>
				</dict>
				<dict>
					<key>content</key>
					<string>--Applescript
-- Apply only to an already saved file
-- Claus Gerhardt, Nov. 2003

set scriptPath to (do shell script "dirname " &amp; "~/Library/TeXShop/Scripts/ex")
set scriptPath to scriptPath &amp; "/setname.scpt"
set scriptName to POSIX file scriptPath as alias
set scriptLiB to (load script scriptName)
tell scriptLib
set frontName to setname(#NAMEPATH#,#TEXPATH#)
end tell

set fileName to  #NAMEPATH#
set n to (number of characters of contents of fileName)
set fileNamequoted to quoted form of fileName
set baseName to do shell script "basename " &amp; fileNamequoted
set m to (number of characters of contents of baseName)
set dirName to quoted form of (characters 1 thru (n - m - 1) of fileName as string)
set texName to baseName &amp; ".tex"

set shellScript to "cd " &amp; dirName &amp; ";"
set shellScript to shellScript &amp; "~/Library/TeXShop/bin/htlatexr  " &amp; baseName
do shell script shellScript

set theHTML to #HTMLPATH#
set htmlFile to alias POSIX file theHTML

tell application "Safari"
  activate
  open htmlFile
end tell
</string>
					<key>key</key>
					<string></string>
					<key>name</key>
					<string>htlatexr</string>
				</dict>
				<dict>
					<key>content</key>
					<string></string>
					<key>key</key>
					<string></string>
					<key>name</key>
					<string>Separator</string>
				</dict>
				<dict>
					<key>content</key>
					<string>--Applescript
-- Apply only to an already saved file.
-- Claus Gerhardt, Nov. 2003

set scriptPath to (do shell script "dirname " &amp; "~/Library/TeXShop/Scripts/ex")
set scriptPath to scriptPath &amp; "/setname.scpt"
set scriptName to POSIX file scriptPath as alias
set scriptLiB to (load script scriptName)
tell scriptLib
set frontName to setname(#NAMEPATH#,#TEXPATH#)
end tell

set fileName to  #TEXPATH#
set n to (number of characters of contents of fileName)
set fileNamequoted to quoted form of fileName
set baseName to do shell script "basename " &amp; fileNamequoted
set m to (number of characters of contents of baseName)
set dirName to quoted form of (characters 1 thru (n - m - 1) of fileName as string)

set shellScript to "cd " &amp; dirName &amp; ";"
set shellScript to shellScript &amp; "~/Library/TeXShop/bin/altpdflatexc  " &amp; baseName
do shell script shellScript

tell document frontName of application "TeXShop"
refreshpdf
end tell
</string>
					<key>key</key>
					<string></string>
					<key>name</key>
					<string>altpdflatexc</string>
				</dict>
				<dict>
					<key>content</key>
					<string>--Applescript
-- Apply only to an already saved file.
-- Claus Gerhardt, Nov. 2003

set scriptPath to (do shell script "dirname " &amp; "~/Library/TeXShop/Scripts/ex")
set scriptPath to scriptPath &amp; "/setname.scpt"
set scriptName to POSIX file scriptPath as alias
set scriptLiB to (load script scriptName)
tell scriptLib
set frontName to setname(#NAMEPATH#,#TEXPATH#)
end tell

set fileName to  #TEXPATH#
set n to (number of characters of contents of fileName)
set fileNamequoted to quoted form of fileName
set baseName to do shell script "basename " &amp; fileNamequoted
set m to (number of characters of contents of baseName)
set dirName to quoted form of (characters 1 thru (n - m - 1) of fileName as string)

set shellScript to "cd " &amp; dirName &amp; ";"
set shellScript to shellScript &amp; "~/Library/TeXShop/bin/pdflatexc  " &amp; baseName
do shell script shellScript

tell document frontName of application "TeXShop"
	refreshpdf
end tell
</string>
					<key>key</key>
					<string></string>
					<key>name</key>
					<string>pdflatexc</string>
				</dict>
				<dict>
					<key>content</key>
					<string></string>
					<key>key</key>
					<string></string>
					<key>name</key>
					<string>Separator</string>
				</dict>
				<dict>
					<key>content</key>
					<string>--AppleScript
-- Apply only to an already saved file
-- Claus Gerhardt, Nov. 2003

-- In the first dialog enter the number of pdf files you want to create.
-- In each of the following dialogs enter your selection of pages like
-- 3:4,6,8:12 This would be the selection for one output file
-- It would contain the pages 3-4, 6, and 8-12

set fileName to  #NAMEPATH#
set n to (number of characters of contents of fileName)
set fileNamequoted to quoted form of fileName
set baseName to do shell script "basename " &amp; fileNamequoted
set m to (number of characters of contents of baseName)
set dirName to quoted form of (characters 1 thru (n - m - 1) of fileName as string)

set dialogName to "The original file is " &amp; fileNamequoted &amp; ".pdf. How many files do you want?"
activate
set k to the text returned of (display dialog dialogName default answer "" buttons {"Cancel", "Next"} default button "Next") as number
set dialogSelection to "Your selection for  file # 1. The file will be saved as " &amp; baseName &amp; "-1.pdf."
set i to 1 as number

set input to the text returned of (display dialog dialogSelection default answer "" buttons {"Cancel", "Next"} default button "Next")

repeat while i ≤ k - 1
set j to i + 1 as number
set selectionName to "Selection for file #" &amp; j &amp; ". The file will be saved as " &amp; baseName &amp; "-" &amp; j &amp; ".pdf."
set input to input &amp; " " &amp; the text returned of (display dialog selectionName default answer "" buttons {"Cancel", "Next"} default button "Next")
set i to i + 1
end repeat

set input to input &amp; " " &amp; baseName

set shellScript to "cd " &amp; dirName &amp; ";"
set shellScript to shellScript &amp; "~/Library/TeXShop/bin/pdfselectc  " &amp; input
do shell script shellScript


</string>
					<key>key</key>
					<string></string>
					<key>name</key>
					<string>pdfselectc</string>
				</dict>
				<dict>
					<key>content</key>
					<string></string>
					<key>key</key>
					<string></string>
					<key>name</key>
					<string>Separator</string>
				</dict>
				<dict>
					<key>content</key>
					<string>--Applescript
-- Apply only to an already saved file.


set thePDF to  #PDFPATH#
set pdfFile to alias POSIX file thePDF
  tell application "TeXShop"
    activate
  open pdfFile
  end tell
</string>
					<key>key</key>
					<string></string>
					<key>name</key>
					<string>openpdf</string>
				</dict>
				<dict>
					<key>content</key>
					<string></string>
					<key>key</key>
					<string></string>
					<key>name</key>
					<string>Separator</string>
				</dict>
				<dict>
					<key>content</key>
					<string>--Applescript
-- Apply only to an already saved file
-- Claus Gerhardt, Nov. 2003


set scriptPath to (do shell script "dirname " &amp; "~/Library/TeXShop/Scripts/ex")
set scriptPath to scriptPath &amp; "/setname.scpt"
set scriptName to POSIX file scriptPath as alias
set scriptLiB to (load script scriptName)
tell scriptLib
set frontName to setname(#NAMEPATH#,#TEXPATH#)
end tell

set fileName to  #NAMEPATH#
set n to (number of characters of contents of fileName)
set fileNamequoted to quoted form of fileName
set baseName to do shell script "basename " &amp; fileNamequoted
set m to (number of characters of contents of baseName)
set dirName to quoted form of (characters 1 thru (n - m - 1) of fileName as string)
set texName to baseName &amp; ".tex"

set shellScript to "cd " &amp; dirName &amp; ";"
set shellScript to shellScript &amp; "~/Library/TeXShop/bin/pdflatexc  " &amp; texName
do shell script shellScript

set shellScript to "cd " &amp; dirName &amp; ";"
set shellScript to shellScript &amp; "~/Library/TeXShop/bin/makeindexk  " &amp; baseName
do shell script shellScript

set shellScript to "cd " &amp; dirName &amp; ";"
set shellScript to shellScript &amp; "~/Library/TeXShop/bin/mpostc  " &amp; baseName
do shell script shellScript

set fileLog to fileName &amp; ".log"
set theFile to alias (POSIX file fileLog)
set logName to baseName &amp;".log"

tell application "TeXShop"
open theFile
end tell

tell document logName of application "TeXShop"
refreshtext
end tell

set shellScript to "cd " &amp; dirName &amp; ";"
set shellScript to shellScript &amp; "~/Library/TeXShop/bin/pdflatexc  " &amp; texName
do shell script shellScript

tell document frontName of application "TeXShop"
refreshpdf
end tell


</string>
					<key>key</key>
					<string></string>
					<key>name</key>
					<string>latex-makeindex-mpost</string>
				</dict>
			</array>
		</dict>
		<dict>
			<key>content</key>
			<string></string>
			<key>key</key>
			<string></string>
			<key>name</key>
			<string>Separator</string>
		</dict>
		<dict>
			<key>content</key>
			<string></string>
			<key>key</key>
			<string></string>
			<key>name</key>
			<string>Headings</string>
			<key>submenu</key>
			<array>
				<dict>
					<key>content</key>
					<string></string>
					<key>key</key>
					<string></string>
					<key>name</key>
					<string>11pt</string>
					<key>submenu</key>
					<array>
						<dict>
							<key>content</key>
							<string>\documentclass[11pt]{article}
\begin{document}

\title{#INS#}
\author{}
\date{}
\maketitle


\end{document}
</string>
							<key>key</key>
							<string></string>
							<key>name</key>
							<string>article</string>
						</dict>
						<dict>
							<key>content</key>
							<string>\documentclass[11pt]{book}
\begin{document}

\title{#INS#}
\author{}
\date{}
\maketitle


\end{document}
</string>
							<key>key</key>
							<string></string>
							<key>name</key>
							<string>book</string>
						</dict>
						<dict>
							<key>content</key>
							<string>\documentclass[11pt]{report}
\begin{document}

\title{#INS#}
\author{}
\date{}
\maketitle


\end{document}
</string>
							<key>key</key>
							<string></string>
							<key>name</key>
							<string>report</string>
						</dict>
					</array>
				</dict>
				<dict>
					<key>content</key>
					<string></string>
					<key>key</key>
					<string></string>
					<key>name</key>
					<string>12pt</string>
					<key>submenu</key>
					<array>
						<dict>
							<key>content</key>
							<string>\documentclass[12pt]{article}
\begin{document}

\title{#INS#}
\author{}
\date{}
\maketitle


\end{document}
</string>
							<key>key</key>
							<string></string>
							<key>name</key>
							<string>article</string>
						</dict>
						<dict>
							<key>content</key>
							<string>\documentclass[12pt]{book}
\begin{document}

\title{#INS#}
\author{}
\date{}
\maketitle


\end{document}
</string>
							<key>key</key>
							<string></string>
							<key>name</key>
							<string>book</string>
						</dict>
						<dict>
							<key>content</key>
							<string>\documentclass[12pt]{report}
\begin{document}

\title{#INS#}
\author{}
\date{}
\maketitle


\end{document}
</string>
							<key>key</key>
							<string></string>
							<key>name</key>
							<string>report</string>
						</dict>
					</array>
				</dict>
			</array>
		</dict>
		<dict>
			<key>content</key>
			<string></string>
			<key>key</key>
			<string></string>
			<key>name</key>
			<string>Subdivisions</string>
			<key>submenu</key>
			<array>
				<dict>
					<key>content</key>
					<string>\chapter{#SEL##INS#}
</string>
					<key>key</key>
					<string></string>
					<key>name</key>
					<string>chapter</string>
				</dict>
				<dict>
					<key>content</key>
					<string>\paragraph{#SEL##INS#}
</string>
					<key>key</key>
					<string></string>
					<key>name</key>
					<string>paragraph</string>
				</dict>
				<dict>
					<key>content</key>
					<string>\subparagraph{#SEL##INS#}
</string>
					<key>key</key>
					<string></string>
					<key>name</key>
					<string>subparagraph</string>
				</dict>
				<dict>
					<key>content</key>
					<string>\section{#SEL##INS#}
</string>
					<key>key</key>
					<string></string>
					<key>name</key>
					<string>section</string>
				</dict>
				<dict>
					<key>content</key>
					<string>\subsection{#SEL##INS#}
</string>
					<key>key</key>
					<string></string>
					<key>name</key>
					<string>subsection</string>
				</dict>
				<dict>
					<key>content</key>
					<string>\subsubsection{#SEL##INS#}
</string>
					<key>key</key>
					<string></string>
					<key>name</key>
					<string>subsubsection</string>
				</dict>
			</array>
		</dict>
		<dict>
			<key>content</key>
			<string></string>
			<key>key</key>
			<string></string>
			<key>name</key>
			<string>Mathematics</string>
			<key>submenu</key>
			<array>
				<dict>
					<key>content</key>
					<string>\[
\left(
\begin{array}{ccc}
  &amp;   &amp;   \\
  &amp;   &amp;   \\
  &amp;   &amp;   
\end{array}
\right)
\]
</string>
					<key>key</key>
					<string></string>
					<key>name</key>
					<string>array</string>
				</dict>
				<dict>
					<key>content</key>
					<string>\begin{equation}
#INS#
\end{equation}
</string>
					<key>key</key>
					<string></string>
					<key>name</key>
					<string>equation</string>
				</dict>
				<dict>
					<key>content</key>
					<string>\begin{equation*}
#INS#
\end{equation*}
</string>
					<key>key</key>
					<string></string>
					<key>name</key>
					<string>equation*</string>
				</dict>
				<dict>
					<key>content</key>
					<string>\begin{eqnarray}
#INS#
\end{eqnarray}
</string>
					<key>key</key>
					<string></string>
					<key>name</key>
					<string>eqnarray</string>
				</dict>
				<dict>
					<key>content</key>
					<string>\begin{eqnarray*}
#INS#
\end{eqnarray*}
</string>
					<key>key</key>
					<string></string>
					<key>name</key>
					<string>eqnarray*</string>
				</dict>
			</array>
		</dict>
		<dict>
			<key>content</key>
			<string></string>
			<key>key</key>
			<string></string>
			<key>name</key>
			<string>Text Styles</string>
			<key>submenu</key>
			<array>
				<dict>
					<key>content</key>
					<string>\emph{#SEL##INS#}</string>
					<key>key</key>
					<string></string>
					<key>name</key>
					<string>emphasize</string>
				</dict>
				<dict>
					<key>content</key>
					<string></string>
					<key>key</key>
					<string></string>
					<key>name</key>
					<string>typeface</string>
					<key>submenu</key>
					<array>
						<dict>
							<key>content</key>
							<string>\mathbf{#SEL##INS#}</string>
							<key>key</key>
							<string></string>
							<key>name</key>
							<string>Bold</string>
						</dict>
						<dict>
							<key>content</key>
							<string>\mathcal{#SEL##INS#}</string>
							<key>key</key>
							<string></string>
							<key>name</key>
							<string>CAL</string>
						</dict>
						<dict>
							<key>content</key>
							<string>\mathit{#SEL##INS#}</string>
							<key>key</key>
							<string></string>
							<key>name</key>
							<string>Italic</string>
						</dict>
						<dict>
							<key>content</key>
							<string>\mathrm{#SEL##INS#}</string>
							<key>key</key>
							<string></string>
							<key>name</key>
							<string>Roman</string>
						</dict>
						<dict>
							<key>content</key>
							<string>\mathsf{#SEL##INS#}</string>
							<key>key</key>
							<string></string>
							<key>name</key>
							<string>Sans Serif</string>
						</dict>
						<dict>
							<key>content</key>
							<string>\mathtt{#SEL##INS#}</string>
							<key>key</key>
							<string></string>
							<key>name</key>
							<string>TypeWriter</string>
						</dict>
					</array>
				</dict>
				<dict>
					<key>content</key>
					<string></string>
					<key>key</key>
					<string></string>
					<key>name</key>
					<string>size</string>
					<key>submenu</key>
					<array>
						<dict>
							<key>content</key>
							<string>{\tiny #SEL##INS#}</string>
							<key>key</key>
							<string></string>
							<key>name</key>
							<string>tiny</string>
						</dict>
						<dict>
							<key>content</key>
							<string>{\scriptsize #SEL##INS#}</string>
							<key>key</key>
							<string></string>
							<key>name</key>
							<string>scriptsize</string>
						</dict>
						<dict>
							<key>content</key>
							<string>{\footnotesize #SEL##INS#}</string>
							<key>key</key>
							<string></string>
							<key>name</key>
							<string>footnotesize</string>
						</dict>
						<dict>
							<key>content</key>
							<string>{\small #SEL##INS#}</string>
							<key>key</key>
							<string></string>
							<key>name</key>
							<string>small</string>
						</dict>
						<dict>
							<key>content</key>
							<string>{\normalsize #SEL##INS#}</string>
							<key>key</key>
							<string></string>
							<key>name</key>
							<string>normalsize</string>
						</dict>
						<dict>
							<key>content</key>
							<string>{\large #SEL##INS#}</string>
							<key>key</key>
							<string></string>
							<key>name</key>
							<string>large</string>
						</dict>
						<dict>
							<key>content</key>
							<string>{\Large #SEL##INS#}</string>
							<key>key</key>
							<string></string>
							<key>name</key>
							<string>Large</string>
						</dict>
						<dict>
							<key>content</key>
							<string>{\LARGE #SEL##INS#}</string>
							<key>key</key>
							<string></string>
							<key>name</key>
							<string>LARGE</string>
						</dict>
						<dict>
							<key>content</key>
							<string>{\huge #SEL##INS#}</string>
							<key>key</key>
							<string></string>
							<key>name</key>
							<string>huge</string>
						</dict>
						<dict>
							<key>content</key>
							<string>{\Huge #SEL##INS#}</string>
							<key>key</key>
							<string></string>
							<key>name</key>
							<string>Huge</string>
						</dict>
					</array>
				</dict>
				<dict>
					<key>content</key>
					<string></string>
					<key>key</key>
					<string></string>
					<key>name</key>
					<string>style</string>
					<key>submenu</key>
					<array>
						<dict>
							<key>content</key>
							<string>\textbf{#SEL##INS#}</string>
							<key>key</key>
							<string></string>
							<key>name</key>
							<string>Bold</string>
						</dict>
						<dict>
							<key>content</key>
							<string>\textsc{#SEL##INS#}</string>
							<key>key</key>
							<string></string>
							<key>name</key>
							<string>Small Caps</string>
						</dict>
						<dict>
							<key>content</key>
							<string>\textmd{#SEL##INS#}</string>
							<key>key</key>
							<string></string>
							<key>name</key>
							<string>Medium</string>
						</dict>
						<dict>
							<key>content</key>
							<string>\textit{#SEL##INS#}</string>
							<key>key</key>
							<string></string>
							<key>name</key>
							<string>Italic</string>
						</dict>
						<dict>
							<key>content</key>
							<string>\textsl{#SEL##INS#}</string>
							<key>key</key>
							<string></string>
							<key>name</key>
							<string>Slanted</string>
						</dict>
						<dict>
							<key>content</key>
							<string>\textrm{#SEL##INS#}</string>
							<key>key</key>
							<string></string>
							<key>name</key>
							<string>Roman</string>
						</dict>
						<dict>
							<key>content</key>
							<string>\textsf{#SEL##INS#}</string>
							<key>key</key>
							<string></string>
							<key>name</key>
							<string>Sans Serif</string>
						</dict>
						<dict>
							<key>content</key>
							<string>\texttt{#SEL##INS#}</string>
							<key>key</key>
							<string></string>
							<key>name</key>
							<string>TypeWriter</string>
						</dict>
						<dict>
							<key>content</key>
							<string>\textup{#SEL##INS#}</string>
							<key>key</key>
							<string></string>
							<key>name</key>
							<string>Upright</string>
						</dict>
					</array>
				</dict>
				<dict>
					<key>content</key>
					<string>\underline{#SEL##INS#}</string>
					<key>key</key>
					<string></string>
					<key>name</key>
					<string>Underline</string>
				</dict>
			</array>
		</dict>
		<dict>
			<key>content</key>
			<string></string>
			<key>key</key>
			<string></string>
			<key>name</key>
			<string>Lists</string>
			<key>submenu</key>
			<array>
				<dict>
					<key>content</key>
					<string>\begin{description}
\item[ ] #SEL##INS#
\end{description}
</string>
					<key>key</key>
					<string></string>
					<key>name</key>
					<string>description</string>
				</dict>
				<dict>
					<key>content</key>
					<string>\begin{enumerate}
\item #SEL##INS#
\end{enumerate}
</string>
					<key>key</key>
					<string></string>
					<key>name</key>
					<string>enumerate</string>
				</dict>
				<dict>
					<key>content</key>
					<string>\begin{itemize}
\item #SEL##INS#
\end{itemize}
</string>
					<key>key</key>
					<string></string>
					<key>name</key>
					<string>itemize</string>
				</dict>
			</array>
		</dict>
		<dict>
			<key>content</key>
			<string></string>
			<key>key</key>
			<string></string>
			<key>name</key>
			<string>Offsets</string>
			<key>submenu</key>
			<array>
				<dict>
					<key>content</key>
					<string>\footnote{#SEL##INS#}</string>
					<key>key</key>
					<string></string>
					<key>name</key>
					<string>footnote</string>
				</dict>
				<dict>
					<key>content</key>
					<string>\marginpar{#SEL##INS#}</string>
					<key>key</key>
					<string></string>
					<key>name</key>
					<string>marginpar</string>
				</dict>
			</array>
		</dict>
		<dict>
			<key>content</key>
			<string></string>
			<key>key</key>
			<string></string>
			<key>name</key>
			<string>Insertions</string>
			<key>submenu</key>
			<array>
				<dict>
					<key>content</key>
					<string>\begin{quotation}
#SEL##INS#
\end{quotation}</string>
					<key>key</key>
					<string></string>
					<key>name</key>
					<string>quotation</string>
				</dict>
				<dict>
					<key>content</key>
					<string>\begin{quote}
#SEL##INS#
\end{quote}</string>
					<key>key</key>
					<string></string>
					<key>name</key>
					<string>quote</string>
				</dict>
				<dict>
					<key>content</key>
					<string>\begin{verbatim}
#SEL##INS#
\end{verbatim}
</string>
					<key>key</key>
					<string></string>
					<key>name</key>
					<string>verbatim</string>
				</dict>
				<dict>
					<key>content</key>
					<string>\begin{verse}
#SEL##INS#
\end{verse}</string>
					<key>key</key>
					<string></string>
					<key>name</key>
					<string>verse</string>
				</dict>
			</array>
		</dict>
		<dict>
			<key>content</key>
			<string></string>
			<key>key</key>
			<string></string>
			<key>name</key>
			<string>Tables</string>
			<key>submenu</key>
			<array>
				<dict>
					<key>content</key>
					<string>\hline</string>
					<key>key</key>
					<string></string>
					<key>name</key>
					<string>hline</string>
				</dict>
				<dict>
					<key>content</key>
					<string>\begin{table}[htp]
\caption{default}
\begin{center}
\begin{tabular}{|c|c|}
#SEL##INS#
\end{tabular}
\end{center}
\label{default}
\end{table}%
</string>
					<key>key</key>
					<string></string>
					<key>name</key>
					<string>table</string>
				</dict>
			</array>
		</dict>
		<dict>
			<key>content</key>
			<string></string>
			<key>key</key>
			<string></string>
			<key>name</key>
			<string>Figures</string>
			<key>submenu</key>
			<array>
				<dict>
					<key>content</key>
					<string>\begin{figure}[htbp]
\begin{center}
#SEL##INS#
\caption{default}
\label{default}
\end{center}
\end{figure}
</string>
					<key>key</key>
					<string></string>
					<key>name</key>
					<string>regular</string>
				</dict>
				<dict>
					<key>content</key>
					<string>\begin{figure}[htbp]
\begin{center}
\epsfile{file=#SEL##INS#,scale=0.8}
\caption{{\bf default}}
\label{default}
\end{center}
\end{figure}
</string>
					<key>key</key>
					<string></string>
					<key>name</key>
					<string>epsfile</string>
				</dict>
			</array>
		</dict>
	</array>
</dict>
</plist>
